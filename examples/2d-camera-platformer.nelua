--[[ This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. ]]

-- This code is based on the "2D camera platformer" example by raysan5, available at: https://www.raylib.com/examples.html

## strict = true

require 'math'
require 'raylib'

-- TODO: Include 'raymath', 'camera' and 'gestures' extra modules into raylib.nelua
-- in a nelua-ish way (for example, import the subrourines below, but also implement
-- Vector2 methods for them)

-- ('raymath', 'camera', 'gestures', 'raygui', 'easings', 'physac 'are extra modules with
-- additional features, however only 'raymath', 'camera 'and 'gestures 'are compiled
-- by default with raylib)

## cinclude '<raymath.h>'
local function Vector2Add(v1: Vector2, v2: Vector2): Vector2                <cimport 'Vector2Add'     , nodecl> end
local function Vector2Subtract(v1: Vector2, v2: Vector2): Vector2           <cimport 'Vector2Subtract', nodecl> end
local function Vector2Length(v: Vector2): float32                           <cimport 'Vector2Length'  , nodecl> end
local function Vector2Scale(v: Vector2, scale: float32 <autocast>): Vector2 <cimport 'Vector2Scale'   , nodecl> end

--[==[
#include "raymath.h"
--]==]

local G: integer <comptime> = 400
local PLAYER_JUMP_SPD: number <comptime> = 350
local PLAYER_HOR_SPD: number <comptime> = 200

local Player = @record{
   position: Vector2,
   speed: number,
   canJump: boolean
}

local EnvItem = @record{
   rect: Rectangle,
   blocking: integer,
   color: Color
}

local function UpdatePlayer(player: Player*, envItems: EnvItem[0], envItemsLength: uinteger, delta: number)
   if Raylib.IsKeyDown(KeyboardKey.LEFT) then
      player.position.x = player.position.x - PLAYER_HOR_SPD * delta
   end
   if Raylib.IsKeyDown(KeyboardKey.RIGHT) then
      player.position.x = player.position.x + PLAYER_HOR_SPD * delta
   end

   if Raylib.IsKeyDown(KeyboardKey.SPACE) and player.canJump then
      player.speed = -PLAYER_JUMP_SPD;
      player.canJump = false
   end

   local hitObstacle = false

   for i = 0_u, < envItemsLength do
      local p: Vector2* = &player.position
      local ei: EnvItem* = &envItems[i]

      if ei.blocking
         and ei.rect.x <= p.x
         and ei.rect.x + ei.rect.width >= p.x
         and ei.rect.y >= p.y
         and ei.rect.y < p.y + player.speed * delta
      then
         hitObstacle = true
         player.speed = 0
         p.y = ei.rect.y
      end
   end

   if not hitObstacle then
      player.position.y = player.position.y + player.speed * delta;
      player.speed = player.speed + G * delta;
      player.canJump = false
   else
      player.canJump = true
   end
end

--local function UpdateCameraCenter(camera: Camera2D*, player: Player*, envItems: EnvItem[0], envItemsLength: uinteger, delta: number, width: integer, height: integer)
local function UpdateCameraCenter(camera: Camera2D*, player: Player*, width: integer, height: integer)
   camera.offset = (@Vector2){ width/2, height/2 }
   camera.target = player.position
end

local function UpdateCameraCenterInsideMap(camera: Camera2D*, player: Player*, envItems: EnvItem[0], envItemsLength: uinteger, width: integer, height: integer)
   camera.target = player.position
   camera.offset = (@Vector2){ width/2, height/2 }
   local minX, minY, maxX, maxY = 1000.0, 1000.0, -1000.0, -1000.0

   for i = 0_u, < envItemsLength do
      local ei: EnvItem* = &envItems[i]

      minX = math.min(ei.rect.x, minX)
      maxX = math.max(ei.rect.x + ei.rect.width, maxX)
      minY = math.min(ei.rect.y, minY)
      maxY = math.max(ei.rect.y + ei.rect.height, maxY)
   end

   local max: Vector2 = Raylib.GetWorldToScreen2D((@Vector2){ maxX, maxY }, $camera)
   local min: Vector2 = Raylib.GetWorldToScreen2D((@Vector2){ minX, minY }, $camera)

   if max.x < width  then camera.offset.x = width  - (max.x - width/2)  end
   if max.y < height then camera.offset.y = height - (max.y - height/2) end
   if min.x > 0 then camera.offset.x = width/2  - min.x end
   if min.y > 0 then camera.offset.y = height/2 - min.y end
end

local function UpdateCameraCenterSmoothFollow(camera: Camera2D*, player: Player*, delta: number, width: integer, height: integer)
   local minSpeed: number <comptime> = 30
   local minEffectLength: number <comptime> = 10
   local fractionSpeed: number <comptime> = 0.8

   camera.offset = (@Vector2){ width/2, height/2 }
   local diff = Vector2Subtract(player.position, camera.target)
   local length = Vector2Length(diff)

   if length > minEffectLength then
      local speed = math.max(fractionSpeed * length, minSpeed)
      camera.target = Vector2Add(camera.target, Vector2Scale(diff, speed * delta / length))
   end
end

local function UpdateCameraEvenOutOnLanding(camera: Camera2D*, player: Player*, delta: number, width: integer, height: integer)
   local evenOutSpeed: number <comptime> = 700
   local eveningOut: boolean <static> = false
   local evenOutTarget: number <static>;

   camera.offset = (@Vector2){ width/2, height/2 }
   camera.target.x = player.position.x

   if eveningOut then
      if evenOutTarget > camera.target.y then
         camera.target.y = camera.target.y + evenOutSpeed * delta

         if camera.target.y > evenOutTarget then
            camera.target.y = evenOutTarget
            eveningOut = false
         end
      else
         camera.target.y = camera.target.y - evenOutSpeed * delta

         if camera.target.y < evenOutTarget then
            camera.target.y = evenOutTarget
            eveningOut = false
         end
      end
   else
      if player.canJump and player.speed == 0 and player.position.y ~= camera.target.y then
         eveningOut = true
         evenOutTarget = player.position.y
      end
   end
end

local function UpdateCameraPlayerBoundsPush(camera: Camera2D*, player: Player*, width: integer, height: integer)
   local bbox: Vector2 <const> = { 0.2, 0.2 }

   local bboxWorldMin = Raylib.GetScreenToWorld2D((@Vector2){ (1-bbox.x) * 0.5 * width, (1-bbox.y) * 0.5 * height }, $camera)
   local bboxWorldMax = Raylib.GetScreenToWorld2D((@Vector2){ (1+bbox.x) * 0.5 * width, (1+bbox.y) * 0.5 * height }, $camera)
   camera.offset = (@Vector2){ (1-bbox.x) * 0.5 * width, (1-bbox.y) * 0.5 * height }

   if player.position.x < bboxWorldMin.x then camera.target.x = player.position.x end
   if player.position.y < bboxWorldMin.y then camera.target.y = player.position.y end
   if player.position.x > bboxWorldMax.x then camera.target.x = bboxWorldMin.x + (player.position.x - bboxWorldMax.x) end
   if player.position.y > bboxWorldMax.y then camera.target.y = bboxWorldMin.y + (player.position.y - bboxWorldMax.y) end
end

--[===[
int main(void)
{
    // Initialization
    //--------------------------------------------------------------------------------------
    const int screenWidth = 800;
    const int screenHeight = 450;

    InitWindow(screenWidth, screenHeight, "raylib [core] example - 2d camera");

    Player player = { 0 };
    player.position = (Vector2){ 400, 280 };
    player.speed = 0;
    player.canJump = false;
    EnvItem envItems[] = {
        {{ 0, 0, 1000, 400 }, 0, LIGHTGRAY },
        {{ 0, 400, 1000, 200 }, 1, GRAY },
        {{ 300, 200, 400, 10 }, 1, GRAY },
        {{ 250, 300, 100, 10 }, 1, GRAY },
        {{ 650, 300, 100, 10 }, 1, GRAY }
    };

    int envItemsLength = sizeof(envItems)/sizeof(envItems[0]);

    Camera2D camera = { 0 };
    camera.target = player.position;
    camera.offset = (Vector2){ screenWidth/2, screenHeight/2 };
    camera.rotation = 0.0f;
    camera.zoom = 1.0f;

    // Store pointers to the multiple update camera functions
    void (*cameraUpdaters[])(Camera2D*, Player*, EnvItem*, int, float, int, int) = {
        UpdateCameraCenter,
        UpdateCameraCenterInsideMap,
        UpdateCameraCenterSmoothFollow,
        UpdateCameraEvenOutOnLanding,
        UpdateCameraPlayerBoundsPush
    };

    int cameraOption = 0;
    int cameraUpdatersLength = sizeof(cameraUpdaters)/sizeof(cameraUpdaters[0]);

    char *cameraDescriptions[] = {
        "Follow player center",
        "Follow player center, but clamp to map edges",
        "Follow player center; smoothed",
        "Follow player center horizontally; updateplayer center vertically after landing",
        "Player push camera on getting too close to screen edge"
    };

    SetTargetFPS(60);
    //--------------------------------------------------------------------------------------

    // Main game loop
    while (!WindowShouldClose())
    {
        // Update
        //----------------------------------------------------------------------------------
        float deltaTime = GetFrameTime();

        UpdatePlayer(&player, envItems, envItemsLength, deltaTime);

        camera.zoom += ((float)GetMouseWheelMove()*0.05f);

        if (camera.zoom > 3.0f) camera.zoom = 3.0f;
        else if (camera.zoom < 0.25f) camera.zoom = 0.25f;

        if (IsKeyPressed(KEY_R))
        {
            camera.zoom = 1.0f;
            player.position = (Vector2){ 400, 280 };
        }

        if (IsKeyPressed(KEY_C)) cameraOption = (cameraOption + 1)%cameraUpdatersLength;

        // Call update camera function by its pointer
        cameraUpdaters[cameraOption](&camera, &player, envItems, envItemsLength, deltaTime, screenWidth, screenHeight);
        //----------------------------------------------------------------------------------

        // Draw
        //----------------------------------------------------------------------------------
        BeginDrawing();

            ClearBackground(LIGHTGRAY);

            BeginMode2D(camera);

                for (int i = 0; i < envItemsLength; i++) DrawRectangleRec(envItems[i].rect, envItems[i].color);

                Rectangle playerRect = { player.position.x - 20, player.position.y - 40, 40, 40 };
                DrawRectangleRec(playerRect, RED);

            EndMode2D();

            DrawText("Controls:", 20, 20, 10, BLACK);
            DrawText("- Right/Left to move", 40, 40, 10, DARKGRAY);
            DrawText("- Space to jump", 40, 60, 10, DARKGRAY);
            DrawText("- Mouse Wheel to Zoom in-out, R to reset zoom", 40, 80, 10, DARKGRAY);
            DrawText("- C to change camera mode", 40, 100, 10, DARKGRAY);
            DrawText("Current camera mode:", 20, 120, 10, BLACK);
            DrawText(cameraDescriptions[cameraOption], 40, 140, 10, DARKGRAY);

        EndDrawing();
        //----------------------------------------------------------------------------------
    }

    // De-Initialization
    //--------------------------------------------------------------------------------------
    CloseWindow();        // Close window and OpenGL context
    //--------------------------------------------------------------------------------------

    return 0;
}
--]===]
