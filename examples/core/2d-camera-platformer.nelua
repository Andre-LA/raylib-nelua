--[[ This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. ]]

-- This code is based on the "2D camera platformer" example by raysan5, available at: https://www.raylib.com/examples.html

require 'raylib'
require 'math'
require 'vector'

local G: integer <comptime> = 400
local PLAYER_JUMP_SPD: number <comptime> = 350
local PLAYER_HOR_SPD: number <comptime> = 200

local Player = @record{
   position: Vector2,
   speed: number,
   canJump: boolean
}

local EnvItem = @record{
   rect: Rectangle,
   blocking: boolean,
   color: Color
}

local function UpdatePlayer(player: Player*, envItems: vector(EnvItem)*, delta: number)
   if Raylib.IsKeyDown(KeyboardKey.LEFT) then
      player.position.x = player.position.x - PLAYER_HOR_SPD * delta
   end
   if Raylib.IsKeyDown(KeyboardKey.RIGHT) then
      player.position.x = player.position.x + PLAYER_HOR_SPD * delta
   end

   if Raylib.IsKeyDown(KeyboardKey.SPACE) and player.canJump then
      player.speed = -PLAYER_JUMP_SPD;
      player.canJump = false
   end

   local hitObstacle = false

   for i = 0_u, < envItems:__len() do
      local p: Vector2* = &player.position
      local ei: EnvItem* = &envItems[i]

      if ei.blocking
         and ei.rect.x <= p.x
         and ei.rect.x + ei.rect.width >= p.x
         and ei.rect.y >= p.y
         and ei.rect.y < p.y + player.speed * delta
      then
         hitObstacle = true
         player.speed = 0
         p.y = ei.rect.y
      end
   end

   if not hitObstacle then
      player.position.y = player.position.y + player.speed * delta;
      player.speed = player.speed + G * delta;
      player.canJump = false
   else
      player.canJump = true
   end
end

local function UpdateCameraCenter(camera: Camera2D*, player: Player*, width: integer, height: integer)
   camera.offset = (@Vector2){ width/2, height/2 }
   camera.target = player.position
end

local function UpdateCameraCenterInsideMap(camera: Camera2D*, player: Player*, envItems: vector(EnvItem)*, width: integer, height: integer)
   camera.target = player.position
   camera.offset = (@Vector2){ width/2, height/2 }
   local minX, minY, maxX, maxY = 1000.0, 1000.0, -1000.0, -1000.0

   for i = 0_u, < envItems:__len() do
      local ei = envItems[i]

      minX = math.min(ei.rect.x, minX)
      maxX = math.max(ei.rect.x + ei.rect.width, maxX)
      minY = math.min(ei.rect.y, minY)
      maxY = math.max(ei.rect.y + ei.rect.height, maxY)
   end

   local max: Vector2 = Raylib.GetWorldToScreen2D((@Vector2){ maxX, maxY }, $camera)
   local min: Vector2 = Raylib.GetWorldToScreen2D((@Vector2){ minX, minY }, $camera)

   if max.x < width  then camera.offset.x = width  - (max.x - width/2)  end
   if max.y < height then camera.offset.y = height - (max.y - height/2) end
   if min.x > 0 then camera.offset.x = width/2  - min.x end
   if min.y > 0 then camera.offset.y = height/2 - min.y end
end

local function UpdateCameraCenterSmoothFollow(camera: Camera2D*, player: Player*, delta: number, width: integer, height: integer)
   local minSpeed: number <comptime> = 30
   local minEffectLength: number <comptime> = 10
   local fractionSpeed: number <comptime> = 0.8

   camera.offset = (@Vector2){ width/2, height/2 }
   local diff: Vector2 = player.position - camera.target
   local length = #diff

   if length > minEffectLength then
      local speed = math.max(fractionSpeed * length, minSpeed)
      camera.target = camera.target + diff * (speed * delta / length)
   end
end

local function UpdateCameraEvenOutOnLanding(camera: Camera2D*, player: Player*, delta: number, width: integer, height: integer)
   local evenOutSpeed: number <comptime> = 700
   local eveningOut: boolean <static> = false
   local evenOutTarget: number <static>;

   camera.offset = (@Vector2){ width/2, height/2 }
   camera.target.x = player.position.x

   if eveningOut then
      if evenOutTarget > camera.target.y then
         camera.target.y = camera.target.y + evenOutSpeed * delta

         if camera.target.y > evenOutTarget then
            camera.target.y = evenOutTarget
            eveningOut = false
         end
      else
         camera.target.y = camera.target.y - evenOutSpeed * delta

         if camera.target.y < evenOutTarget then
            camera.target.y = evenOutTarget
            eveningOut = false
         end
      end
   else
      if player.canJump and player.speed == 0 and player.position.y ~= camera.target.y then
         eveningOut = true
         evenOutTarget = player.position.y
      end
   end
end

local function UpdateCameraPlayerBoundsPush(camera: Camera2D*, player: Player*, width: integer, height: integer)
   local bbox: Vector2 <const> = { 0.2, 0.2 }

   local bboxWorldMin = Raylib.GetScreenToWorld2D((@Vector2){ (1-bbox.x) * 0.5 * width, (1-bbox.y) * 0.5 * height }, $camera)
   local bboxWorldMax = Raylib.GetScreenToWorld2D((@Vector2){ (1+bbox.x) * 0.5 * width, (1+bbox.y) * 0.5 * height }, $camera)
   camera.offset = (@Vector2){ (1-bbox.x) * 0.5 * width, (1-bbox.y) * 0.5 * height }

   if player.position.x < bboxWorldMin.x then camera.target.x = player.position.x end
   if player.position.y < bboxWorldMin.y then camera.target.y = player.position.y end
   if player.position.x > bboxWorldMax.x then camera.target.x = bboxWorldMin.x + (player.position.x - bboxWorldMax.x) end
   if player.position.y > bboxWorldMax.y then camera.target.y = bboxWorldMin.y + (player.position.y - bboxWorldMax.y) end
end

local function UpdateCamera(cameraOption: uinteger, camera: Camera2D*, player: Player*, envItems: vector(EnvItem)*, delta: number, width: integer, height: integer)
   -- TODO: change to C callbacks:
   -- https://github.com/edubart/nelua-lang/commit/cf006db8fb7b85e5cc44fd8cc13da8bdcb1ad3a3

   switch cameraOption
   case 0 then
      UpdateCameraCenter(camera, player, width, height)
   case 1 then
      UpdateCameraCenterInsideMap(camera, player, envItems, width, height)
   case 2 then
      UpdateCameraCenterSmoothFollow(camera, player, delta, width, height)
   case 3 then
      UpdateCameraEvenOutOnLanding(camera, player, delta, width, height)
   case 4 then
      UpdateCameraPlayerBoundsPush(camera, player, width, height)
   else
      print("invalid camera mode")
   end
end

-- [ Initialization [
local screenWidth: integer <comptime> = 800
local screenHeight: integer <comptime> = 450

Raylib.InitWindow(screenWidth, screenHeight, "raylib [core] example - 2d camera platformer")

local player: Player = {
   position = (@Vector2){ 400, 280 },
   speed = 0,
   canJump = false
}

local envItems: vector(EnvItem) = {
   { (@Rectangle){   0,   0, 1000, 400 }, false, RaylibColors.Lightgray },
   { (@Rectangle){   0, 400, 1000, 200 },  true, RaylibColors.Gray      },
   { (@Rectangle){ 300, 200,  400,  10 },  true, RaylibColors.Gray      },
   { (@Rectangle){ 250, 300,  100,  10 },  true, RaylibColors.Gray      },
   { (@Rectangle){ 650, 300,  100,  10 },  true, RaylibColors.Gray      }
}

local camera: Camera2D = {
   target = player.position,
   offset = (@Vector2){ screenWidth/2, screenHeight/2 },
   rotation = 0,
   zoom = 1
}

local cameraOption = 0_u

local cameraDescriptions: stringview[5] = {
   "Follow player center",
   "Follow player center, but clamp to map edges",
   "Follow player center; smoothed",
   "Follow player center horizontally; updateplayer center vertically after landing",
   "Player push camera on getting too close to screen edge"
}

Raylib.SetTargetFPS(60)
-- ] Initialization ]

-- Main game loop
while not Raylib.WindowShouldClose() do
   -- [ Update [
   local deltaTime = Raylib.GetFrameTime()

   -- TODO: there is a way to simplify this?
   UpdatePlayer(&player, &envItems, deltaTime)

   camera.zoom = math.max(math.min(camera.zoom + Raylib.GetMouseWheelMove() * 0.05, 3), 0.25)

   if Raylib.IsKeyPressed(KeyboardKey.R) then
      camera.zoom = 1
      player.position = (@Vector2){ 400, 280 }
   end

   if Raylib.IsKeyPressed(KeyboardKey.C) then
     cameraOption = (cameraOption + 1)  % #cameraDescriptions
   end

   UpdateCamera(cameraOption, &camera, &player, &envItems, deltaTime, screenWidth, screenHeight)
   -- ] Update ]

   -- [ Draw [
   Raylib.BeginDrawing()
      Raylib.ClearBackground(RaylibColors.Lightgray)

      Raylib.BeginMode2D(camera)
         for i = 0, < envItems:__len() do
            Raylib.DrawRectangleRec(envItems[i].rect, envItems[i].color)
         end

         local playerRect: Rectangle = { player.position.x - 20, player.position.y - 40, 40, 40 }
         Raylib.DrawRectangleRec(playerRect, RaylibColors.Red)
      Raylib.EndMode2D()

      Raylib.DrawText("Controls:", 20, 20, 10, RaylibColors.Black)
      Raylib.DrawText("- Right/Left to move", 40, 40, 10, RaylibColors.Darkgray)
      Raylib.DrawText("- Space to jump", 40, 60, 10, RaylibColors.Darkgray)
      Raylib.DrawText("- Mouse wheel to zoom in-out, R to reset zoom", 40, 80, 10, RaylibColors.Darkgray)
      Raylib.DrawText("- C to change camera mode", 40, 100, 10, RaylibColors.Darkgray)
      Raylib.DrawText("Current camera mode:", 20, 120, 10, RaylibColors.Black)
      Raylib.DrawText(cameraDescriptions[cameraOption], 40, 140, 10, RaylibColors.Darkgray)
   Raylib.EndDrawing()
   -- ] Draw ]
end

-- De-initialization
Raylib.CloseWindow() -- close window and OpenGL context
