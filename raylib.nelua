--[[ This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. ]]

-- Raylib and Raymath 3.0 wrapper
-- based on raylib.h (https://github.com/raysan5/raylib/blob/3.0.0/src/raylib.h)
-- and raymath.h (https://github.com/raysan5/raylib/blob/3.0.0/src/raymath.h)

## linklib 'raylib'
## linklib 'GL'
## linklib 'glfw'
## linklib 'openal'
## linklib 'm'
## linklib 'pthread'
## linklib 'dl'
## linklib 'X11'
## linklib 'Xrandr'
## linklib 'Xinerama'
## linklib 'Xi'
## linklib 'Xxf86vm'
## linklib 'Xcursor'

## cinclude '<raylib.h>'
## cinclude '<raymath.h>'

global Raymath = @record{}
global Raylib  = @record{}

local va_list <cimport, nodecl> = @record{}
-- Callbacks to be implemented by users 
global TraceLogCallback: type = @function( cint, cstring, va_list )

-- Enumerators Definition
-- System config flags
-- NOTE: Used for bit masks 
global ConfigFlag = @enum {
   -- Reserved
   FLAG_RESERVED = 1,
   -- Set to run program in fullscreen
   FLAG_FULLSCREEN_MODE = 2,
   -- Set to allow resizable window
   FLAG_WINDOW_RESIZABLE = 4,
   -- Set to disable window decoration frame and buttons
   FLAG_WINDOW_UNDECORATED = 8,
   -- Set to allow transparent window
   FLAG_WINDOW_TRANSPARENT = 16,
   -- Set to create the window initially hidden
   FLAG_WINDOW_HIDDEN = 128,
   -- Set to allow windows running while minimized
   FLAG_WINDOW_ALWAYS_RUN = 256,
   -- Set to try enabling MSAA 4X
   FLAG_MSAA_4X_HINT = 32,
   -- Set to try enabling V Sync on GPU
   FLAG_VSYNC_HINT = 64,
}

-- Trace log type 
global TraceLogType = @enum {
   -- Display all logs
   LOG_ALL = 0,
   LOG_TRACE = 1,
   LOG_DEBUG = 2,
   LOG_INFO = 3,
   LOG_WARNING = 4,
   LOG_ERROR = 5,
   LOG_FATAL = 6,
   -- Disable logging
   LOG_NONE = 7,
}

-- Keyboard keys 
global KeyboardKey = @enum {
   -- Alphanumeric keys
   KEY_APOSTROPHE = 39,
   KEY_COMMA = 44,
   KEY_MINUS = 45,
   KEY_PERIOD = 46,
   KEY_SLASH = 47,
   KEY_ZERO = 48,
   KEY_ONE = 49,
   KEY_TWO = 50,
   KEY_THREE = 51,
   KEY_FOUR = 52,
   KEY_FIVE = 53,
   KEY_SIX = 54,
   KEY_SEVEN = 55,
   KEY_EIGHT = 56,
   KEY_NINE = 57,
   KEY_SEMICOLON = 59,
   KEY_EQUAL = 61,
   KEY_A = 65,
   KEY_B = 66,
   KEY_C = 67,
   KEY_D = 68,
   KEY_E = 69,
   KEY_F = 70,
   KEY_G = 71,
   KEY_H = 72,
   KEY_I = 73,
   KEY_J = 74,
   KEY_K = 75,
   KEY_L = 76,
   KEY_M = 77,
   KEY_N = 78,
   KEY_O = 79,
   KEY_P = 80,
   KEY_Q = 81,
   KEY_R = 82,
   KEY_S = 83,
   KEY_T = 84,
   KEY_U = 85,
   KEY_V = 86,
   KEY_W = 87,
   KEY_X = 88,
   KEY_Y = 89,
   KEY_Z = 90,
 
   -- Function keys
   KEY_SPACE = 32,
   KEY_ESCAPE = 256,
   KEY_ENTER = 257,
   KEY_TAB = 258,
   KEY_BACKSPACE = 259,
   KEY_INSERT = 260,
   KEY_DELETE = 261,
   KEY_RIGHT = 262,
   KEY_LEFT = 263,
   KEY_DOWN = 264,
   KEY_UP = 265,
   KEY_PAGE_UP = 266,
   KEY_PAGE_DOWN = 267,
   KEY_HOME = 268,
   KEY_END = 269,
   KEY_CAPS_LOCK = 280,
   KEY_SCROLL_LOCK = 281,
   KEY_NUM_LOCK = 282,
   KEY_PRINT_SCREEN = 283,
   KEY_PAUSE = 284,
   KEY_F1 = 290,
   KEY_F2 = 291,
   KEY_F3 = 292,
   KEY_F4 = 293,
   KEY_F5 = 294,
   KEY_F6 = 295,
   KEY_F7 = 296,
   KEY_F8 = 297,
   KEY_F9 = 298,
   KEY_F10 = 299,
   KEY_F11 = 300,
   KEY_F12 = 301,
   KEY_LEFT_SHIFT = 340,
   KEY_LEFT_CONTROL = 341,
   KEY_LEFT_ALT = 342,
   KEY_LEFT_SUPER = 343,
   KEY_RIGHT_SHIFT = 344,
   KEY_RIGHT_CONTROL = 345,
   KEY_RIGHT_ALT = 346,
   KEY_RIGHT_SUPER = 347,
   KEY_KB_MENU = 348,
   KEY_LEFT_BRACKET = 91,
   KEY_BACKSLASH = 92,
   KEY_RIGHT_BRACKET = 93,
   KEY_GRAVE = 96,
 
   -- Keypad keys
   KEY_KP_0 = 320,
   KEY_KP_1 = 321,
   KEY_KP_2 = 322,
   KEY_KP_3 = 323,
   KEY_KP_4 = 324,
   KEY_KP_5 = 325,
   KEY_KP_6 = 326,
   KEY_KP_7 = 327,
   KEY_KP_8 = 328,
   KEY_KP_9 = 329,
   KEY_KP_DECIMAL = 330,
   KEY_KP_DIVIDE = 331,
   KEY_KP_MULTIPLY = 332,
   KEY_KP_SUBTRACT = 333,
   KEY_KP_ADD = 334,
   KEY_KP_ENTER = 335,
   KEY_KP_EQUAL = 336,
}

-- Android buttons 
global AndroidButton = @enum {
   KEY_BACK = 4,
   KEY_MENU = 82,
   KEY_VOLUME_UP = 24,
   KEY_VOLUME_DOWN = 25,
}

-- Mouse buttons 
global MouseButton = @enum {
   MOUSE_LEFT_BUTTON = 0,
   MOUSE_RIGHT_BUTTON = 1,
   MOUSE_MIDDLE_BUTTON = 2,
}

-- Gamepad number 
global GamepadNumber = @enum {
   GAMEPAD_PLAYER1 = 0,
   GAMEPAD_PLAYER2 = 1,
   GAMEPAD_PLAYER3 = 2,
   GAMEPAD_PLAYER4 = 3,
}

-- Gamepad Buttons 
global GamepadButton = @enum {
   -- This is here just for error checking
   GAMEPAD_BUTTON_UNKNOWN = 0,
 
   -- This is normally a DPAD
   GAMEPAD_BUTTON_LEFT_FACE_UP = 1,
   GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2,
   GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3,
   GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4,
 
   -- This normally corresponds with PlayStation and Xbox controllers
   -- XBOX Y X A B
   -- PS3 Triangle Square Cross Circle
   -- No support for 6 button controllers though
   GAMEPAD_BUTTON_RIGHT_FACE_UP = 1,
   GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 2,
   GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 3,
   GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 4,
 
   -- Triggers
   GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 1,
   GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 2,
   GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 3,
   GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 4,
 
   -- These are buttons in the center of the gamepad
   -- PS3 Select
   GAMEPAD_BUTTON_MIDDLE_LEFT = 1,
   -- PS Button/XBOX Button
   GAMEPAD_BUTTON_MIDDLE = 2,
   -- PS3 Start
   GAMEPAD_BUTTON_MIDDLE_RIGHT = 3,
 
   -- These are the joystick press in buttons
   GAMEPAD_BUTTON_LEFT_THUMB = 1,
   GAMEPAD_BUTTON_RIGHT_THUMB = 2,
}

 
global GamepadAxis = @enum {
   -- This is here just for error checking
   GAMEPAD_AXIS_UNKNOWN = 0,
 
   -- Left stick
   GAMEPAD_AXIS_LEFT_X = 1,
   GAMEPAD_AXIS_LEFT_Y = 2,
 
   -- Right stick
   GAMEPAD_AXIS_RIGHT_X = 1,
   GAMEPAD_AXIS_RIGHT_Y = 2,
 
   -- Pressure levels for the back triggers
   -- 1 1 pressure level
   GAMEPAD_AXIS_LEFT_TRIGGER = 1,
   -- 1 1 pressure level
   GAMEPAD_AXIS_RIGHT_TRIGGER = 2,
}

-- Shader location point type 
global ShaderLocationIndex = @enum {
   LOC_VERTEX_POSITION = 0,
   LOC_VERTEX_TEXCOORD01 = 1,
   LOC_VERTEX_TEXCOORD02 = 2,
   LOC_VERTEX_NORMAL = 3,
   LOC_VERTEX_TANGENT = 4,
   LOC_VERTEX_COLOR = 5,
   LOC_MATRIX_MVP = 6,
   LOC_MATRIX_MODEL = 7,
   LOC_MATRIX_VIEW = 8,
   LOC_MATRIX_PROJECTION = 9,
   LOC_VECTOR_VIEW = 10,
   LOC_COLOR_DIFFUSE = 11,
   LOC_COLOR_SPECULAR = 12,
   LOC_COLOR_AMBIENT = 13,
   -- LOC_MAP_DIFFUSE
   LOC_MAP_ALBEDO = 14,
   -- LOC_MAP_SPECULAR
   LOC_MAP_METALNESS = 15,
   LOC_MAP_NORMAL = 16,
   LOC_MAP_ROUGHNESS = 17,
   LOC_MAP_OCCLUSION = 18,
   LOC_MAP_EMISSION = 19,
   LOC_MAP_HEIGHT = 20,
   LOC_MAP_CUBEMAP = 21,
   LOC_MAP_IRRADIANCE = 22,
   LOC_MAP_PREFILTER = 23,
   LOC_MAP_BRDF = 24,
}

-- Shader uniform data types 
global ShaderUniformDataType = @enum {
   UNIFORM_FLOAT = 0,
   UNIFORM_VEC2 = 1,
   UNIFORM_VEC3 = 2,
   UNIFORM_VEC4 = 3,
   UNIFORM_INT = 4,
   UNIFORM_IVEC2 = 5,
   UNIFORM_IVEC3 = 6,
   UNIFORM_IVEC4 = 7,
   UNIFORM_SAMPLER2D = 8,
}

-- Material map type 
global MaterialMapType = @enum {
   -- MAP_DIFFUSE
   MAP_ALBEDO = 0,
   -- MAP_SPECULAR
   MAP_METALNESS = 1,
   MAP_NORMAL = 2,
   MAP_ROUGHNESS = 3,
   MAP_OCCLUSION = 4,
   MAP_EMISSION = 5,
   MAP_HEIGHT = 6,
   -- NOTE Uses GL_TEXTURE_CUBE_MAP
   MAP_CUBEMAP = 7,
   -- NOTE Uses GL_TEXTURE_CUBE_MAP
   MAP_IRRADIANCE = 8,
   -- NOTE Uses GL_TEXTURE_CUBE_MAP
   MAP_PREFILTER = 9,
   MAP_BRDF = 10,
}

-- Pixel formats
-- NOTE: Support depends on OpenGL version and platform 
global PixelFormat = @enum {
   -- 8 bit per pixel no alpha
   UNCOMPRESSED_GRAYSCALE = 1,
   -- 8* 2 bpp 2 channels
   UNCOMPRESSED_GRAY_ALPHA = 2,
   -- 16 bpp
   UNCOMPRESSED_R5G6B5 = 3,
   -- 24 bpp
   UNCOMPRESSED_R8G8B8 = 4,
   -- 16 bpp 1 bit alpha
   UNCOMPRESSED_R5G5B5A1 = 5,
   -- 16 bpp 4 bit alpha
   UNCOMPRESSED_R4G4B4A4 = 6,
   -- 32 bpp
   UNCOMPRESSED_R8G8B8A8 = 7,
   -- 32 bpp 1 channel float
   UNCOMPRESSED_R32 = 8,
   -- 32* 3 bpp 3 channels float
   UNCOMPRESSED_R32G32B32 = 9,
   -- 32* 4 bpp 4 channels float
   UNCOMPRESSED_R32G32B32A32 = 10,
   -- 4 bpp no alpha
   COMPRESSED_DXT1_RGB = 11,
   -- 4 bpp 1 bit alpha
   COMPRESSED_DXT1_RGBA = 12,
   -- 8 bpp
   COMPRESSED_DXT3_RGBA = 13,
   -- 8 bpp
   COMPRESSED_DXT5_RGBA = 14,
   -- 4 bpp
   COMPRESSED_ETC1_RGB = 15,
   -- 4 bpp
   COMPRESSED_ETC2_RGB = 16,
   -- 8 bpp
   COMPRESSED_ETC2_EAC_RGBA = 17,
   -- 4 bpp
   COMPRESSED_PVRT_RGB = 18,
   -- 4 bpp
   COMPRESSED_PVRT_RGBA = 19,
   -- 8 bpp
   COMPRESSED_ASTC_4x4_RGBA = 20,
   -- 2 bpp
   COMPRESSED_ASTC_8x8_RGBA = 21,
}

-- Texture parameters: filter mode
-- NOTE 1: Filtering considers mipmaps if available in the texture
-- NOTE 2: Filter is accordingly set for minification and magnification 
global TextureFilterMode = @enum {
   -- No filter just pixel aproximation
   FILTER_POINT = 0,
   -- Linear filtering
   FILTER_BILINEAR = 1,
   -- Trilinear filtering linear with mipmaps
   FILTER_TRILINEAR = 2,
   -- Anisotropic filtering 4x
   FILTER_ANISOTROPIC_4X = 3,
   -- Anisotropic filtering 8x
   FILTER_ANISOTROPIC_8X = 4,
   -- Anisotropic filtering 16x
   FILTER_ANISOTROPIC_16X = 5,
}

-- Cubemap layout type 
global CubemapLayoutType = @enum {
   -- Automatically detect layout type
   CUBEMAP_AUTO_DETECT = 0,
   -- Layout is defined by a vertical line with faces
   CUBEMAP_LINE_VERTICAL = 1,
   -- Layout is defined by an horizontal line with faces
   CUBEMAP_LINE_HORIZONTAL = 2,
   -- Layout is defined by a 3x4 cross with cubemap faces
   CUBEMAP_CROSS_THREE_BY_FOUR = 3,
   -- Layout is defined by a 4x3 cross with cubemap faces
   CUBEMAP_CROSS_FOUR_BY_THREE = 4,
   -- Layout is defined by a panorama image equirectangular map
   CUBEMAP_PANORAMA = 5,
}

-- Texture parameters: wrap mode 
global TextureWrapMode = @enum {
   -- Repeats texture in tiled mode
   WRAP_REPEAT = 0,
   -- Clamps texture to edge pixel in tiled mode
   WRAP_CLAMP = 1,
   -- Mirrors and repeats the texture in tiled mode
   WRAP_MIRROR_REPEAT = 2,
   -- Mirrors and clamps to border the texture in tiled mode
   WRAP_MIRROR_CLAMP = 3,
}

-- Font type, defines generation method 
global FontType = @enum {
   -- Default font generation anti aliased
   FONT_DEFAULT = 0,
   -- Bitmap font generation no anti aliasing
   FONT_BITMAP = 1,
   -- SDF font generation requires external shader
   FONT_SDF = 2,
}

-- Color blending modes ( pre-defined )  
global BlendMode = @enum {
   -- Blend textures considering alpha default
   BLEND_ALPHA = 0,
   -- Blend textures adding colors
   BLEND_ADDITIVE = 1,
   -- Blend textures multiplying colors
   BLEND_MULTIPLIED = 2,
}

-- Gestures type
-- NOTE: It could be used as flags to enable only some gestures 
global GestureType = @enum {
   GESTURE_NONE = 0,
   GESTURE_TAP = 1,
   GESTURE_DOUBLETAP = 2,
   GESTURE_HOLD = 4,
   GESTURE_DRAG = 8,
   GESTURE_SWIPE_RIGHT = 16,
   GESTURE_SWIPE_LEFT = 32,
   GESTURE_SWIPE_UP = 64,
   GESTURE_SWIPE_DOWN = 128,
   GESTURE_PINCH_IN = 256,
   GESTURE_PINCH_OUT = 512,
}

-- Camera system modes 
global CameraMode = @enum {
   CAMERA_CUSTOM = 0,
   CAMERA_FREE = 1,
   CAMERA_ORBITAL = 2,
   CAMERA_FIRST_PERSON = 3,
   CAMERA_THIRD_PERSON = 4,
}

-- Camera projection modes 
global CameraType = @enum {
   CAMERA_PERSPECTIVE = 0,
   CAMERA_ORTHOGRAPHIC = 1,
}

-- Type of n-patch 
global NPatchType = @enum {
   -- Npatch defined by 3x3 tiles
   NPT_9PATCH = 0,
   -- Npatch defined by 1x3 tiles
   NPT_3PATCH_VERTICAL = 1,
   -- Npatch defined by 3x1 tiles
   NPT_3PATCH_HORIZONTAL = 2,
}


-- Temporal hack to avoid breaking old codebases using
-- deprecated raylib implementation of these functions
-- Structures Definition
-- Boolean type
-- Vector2 type 
global Vector2 <cimport, nodecl> = @record{
   x: float32,
   y: float32,
}

-- Vector3 type 
global Vector3 <cimport, nodecl> = @record{
   x: float32,
   y: float32,
   z: float32,
}

-- Vector4 type 
global Vector4 <cimport, nodecl> = @record{
   x: float32,
   y: float32,
   z: float32,
   w: float32,
}

global Quaternion: type = @Vector4 

-- Quaternion type, same as Vector4
-- Matrix type ( OpenGL style 4x4 - right handed, column major )  
global Matrix <cimport, nodecl> = @record{
   m0: float32,
   m4: float32,
   m8: float32,
   m12: float32,
   m1: float32,
   m5: float32,
   m9: float32,
   m13: float32,
   m2: float32,
   m6: float32,
   m10: float32,
   m14: float32,
   m3: float32,
   m7: float32,
   m11: float32,
   m15: float32,
}

-- Color type, RGBA ( 32bit )  
global Color <cimport, nodecl> = @record{
   r: uint8,
   g: uint8,
   b: uint8,
   a: uint8,
}

-- Rectangle type 
global Rectangle <cimport, nodecl> = @record{
   x: float32,
   y: float32,
   width: float32,
   height: float32,
}

-- Image type, bpp always RGBA ( 32bit ) 
-- NOTE: Data stored in CPU memory ( RAM )  
global Image <cimport, nodecl> = @record{
   -- Image raw data
   data: pointer,
   -- Image base width
   width: cint,
   -- Image base height
   height: cint,
   -- Mipmap levels 1 by default
   mipmaps: cint,
   -- Data format PixelFormat type
   format: cint,
}

-- Texture2D type
-- NOTE: Data stored in GPU memory 
global Texture2D <cimport, nodecl> = @record{
   -- OpenGL texture id
   id: cint,
   -- Texture base width
   width: cint,
   -- Texture base height
   height: cint,
   -- Mipmap levels 1 by default
   mipmaps: cint,
   -- Data format PixelFormat type
   format: cint,
}

global Texture: type = @Texture2D 

global TextureCubemap: type = @Texture2D 

-- Texture type, same as Texture2D
-- TextureCubemap type, actually, same as Texture2D
-- RenderTexture2D type, for texture rendering 
global RenderTexture2D <cimport, nodecl> = @record{
   -- OpenGL Framebuffer Object FBO id
   id: cint,
   -- Color buffer attachment texture
   texture: Texture2D,
   -- Depth buffer attachment texture
   depth: Texture2D,
   -- Track if depth attachment is a texture or renderbuffer
   depthTexture: boolean,
}

global RenderTexture: type = @RenderTexture2D 

-- RenderTexture type, same as RenderTexture2D
-- N-Patch layout info 
global NPatchInfo <cimport, nodecl> = @record{
   -- Region in the texture
   sourceRec: Rectangle,
   -- left border offset
   left: cint,
   -- top border offset
   top: cint,
   -- right border offset
   right: cint,
   -- bottom border offset
   bottom: cint,
   -- layout of the n patch 3x3 1x3 or 3x1
   type: cint,
}

-- Font character info 
global CharInfo <cimport, nodecl> = @record{
   -- Character value Unicode
   value: cint,
   -- Character offset X when drawing
   offsetX: cint,
   -- Character offset Y when drawing
   offsetY: cint,
   -- Character advance position X
   advanceX: cint,
   -- Character image data
   image: Image,
}

-- Font type, includes texture and charSet array data 
global Font <cimport, nodecl> = @record{
   -- Base size default chars height
   baseSize: cint,
   -- Number of characters
   charsCount: cint,
   -- Characters texture atlas
   texture: Texture2D,
   -- Characters rectangles in texture
   recs: pointer(Rectangle),
   -- Characters info data
   chars: pointer(CharInfo),
}

-- Camera type, defines a camera position/orientation in 3d space 
global Camera3D <cimport, nodecl> = @record{
   -- Camera position
   position: Vector3,
   -- Camera target it looks at
   target: Vector3,
   -- Camera up vector rotation over its axis
   up: Vector3,
   -- Camera field of view apperture in Y degrees in perspective used as near plane width in orthographic
   fovy: float32,
   -- Camera type defines projection type CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
   type: cint,
}

global Camera: type = @Camera3D 

-- Camera2D type, defines a 2d camera 
global Camera2D <cimport, nodecl> = @record{
   -- Camera offset displacement from target
   offset: Vector2,
   -- Camera target rotation and zoom origin
   target: Vector2,
   -- Camera rotation in degrees
   rotation: float32,
   -- Camera zoom scaling should be 1 0f by default
   zoom: float32,
}

-- Vertex data definning a mesh
-- NOTE: Data stored in CPU memory ( and GPU )  
global Mesh <cimport, nodecl> = @record{
   -- Number of vertices stored in arrays
   vertexCount: cint,
   -- Number of triangles stored indexed or not
   triangleCount: cint,
   -- Vertex position XYZ 3 components per vertex shader location 0
   vertices: pointer(float32),
   -- Vertex texture coordinates UV 2 components per vertex shader location 1
   texcoords: pointer(float32),
   -- Vertex second texture coordinates useful for lightmaps shader location 5
   texcoords2: pointer(float32),
   -- Vertex normals XYZ 3 components per vertex shader location 2
   normals: pointer(float32),
   -- Vertex tangents XYZW 4 components per vertex shader location 4
   tangents: pointer(float32),
   -- Vertex colors RGBA 4 components per vertex shader location 3
   colors: cstring,
   -- Vertex indices in case vertex data comes indexed
   indices: pointer(cshort),
   -- Animated vertex positions after bones transformations
   animVertices: pointer(float32),
   -- Animated normals after bones transformations
   animNormals: pointer(float32),
   -- Vertex bone ids up to 4 bones influence by vertex skinning
   boneIds: pointer(cint),
   -- Vertex bone weight up to 4 bones influence by vertex skinning
   boneWeights: pointer(float32),
   -- OpenGL Vertex Array Object id
   vaoId: cint,
   -- OpenGL Vertex Buffer Objects id default vertex data
   vboId: pointer(cint),
}

-- Shader type ( generic )  
global Shader <cimport, nodecl> = @record{
   -- Shader program id
   id: cint,
   -- Shader locations array MAX_SHADER_LOCATIONS
   locs: pointer(cint),
}

-- Material texture map 
global MaterialMap <cimport, nodecl> = @record{
   -- Material map texture
   texture: Texture2D,
   -- Material map color
   color: Color,
   -- Material map value
   value: float32,
}

-- Material type ( generic )  
global Material <cimport, nodecl> = @record{
   -- Material shader
   shader: Shader,
   -- Material maps array MAX_MATERIAL_MAPS
   maps: pointer(MaterialMap),
   -- Material generic parameters if required
   params: pointer(float32),
}

-- Transformation properties 
global Transform <cimport, nodecl> = @record{
   -- Translation
   translation: Vector3,
   -- Rotation
   rotation: Quaternion,
   -- Scale
   scale: Vector3,
}

-- Bone information 
global BoneInfo <cimport, nodecl> = @record{
   -- Bone name
   name: array(cchar, 32),
   -- Bone parent
   parent: cint,
}

-- Model type 
global Model <cimport, nodecl> = @record{
   -- Local transform matrix
   transform: Matrix,
   -- Number of meshes
   meshCount: cint,
   -- Meshes array
   meshes: pointer(Mesh),
   -- Number of materials
   materialCount: cint,
   -- Materials array
   materials: pointer(Material),
   -- Mesh material number
   meshMaterial: pointer(cint),
   -- Number of bones
   boneCount: cint,
   -- Bones information skeleton
   bones: pointer(BoneInfo),
   -- Bones base transformation pose
   bindPose: pointer(Transform),
}

-- Model animation 
global ModelAnimation <cimport, nodecl> = @record{
   -- Number of bones
   boneCount: cint,
   -- Bones information skeleton
   bones: pointer(BoneInfo),
   -- Number of animation frames
   frameCount: cint,
   -- Poses array by frame
   framePoses: pointer(pointer(Transform)),
}

-- Ray type ( useful for raycast )  
global Ray <cimport, nodecl> = @record{
   -- Ray position origin
   position: Vector3,
   -- Ray direction
   direction: Vector3,
}

-- Raycast hit information 
global RayHitInfo <cimport, nodecl> = @record{
   -- Did the ray hit something
   hit: boolean,
   -- Distance to nearest hit
   distance: float32,
   -- Position of nearest hit
   position: Vector3,
   -- Surface normal of hit
   normal: Vector3,
}

-- Bounding box type 
global BoundingBox <cimport, nodecl> = @record{
   -- Minimum vertex box corner
   min: Vector3,
   -- Maximum vertex box corner
   max: Vector3,
}

-- Wave type, defines audio wave data 
global Wave <cimport, nodecl> = @record{
   -- Total number of samples
   sampleCount: cint,
   -- Frequency samples per second
   sampleRate: cint,
   -- Bit depth bits per sample 8 16 32 24 not supported
   sampleSize: cint,
   -- Number of channels 1 mono 2 stereo
   channels: cint,
   -- Buffer data pointer
   data: pointer,
}

 
global rAudioBuffer <cimport, nodecl> = @record{
}

-- Audio stream type
-- NOTE: Useful to create custom audio streams not bound to a specific file 
global AudioStream <cimport, nodecl> = @record{
   -- Frequency samples per second
   sampleRate: cint,
   -- Bit depth bits per sample 8 16 32 24 not supported
   sampleSize: cint,
   -- Number of channels 1 mono 2 stereo
   channels: cint,
   -- Pointer to internal data used by the audio system
   buffer: pointer(rAudioBuffer),
}

-- Sound source type 
global Sound <cimport, nodecl> = @record{
   -- Total number of samples
   sampleCount: cint,
   -- Audio stream
   stream: AudioStream,
}

-- Music stream type ( audio file streaming from memory ) 
-- NOTE: Anything longer than ~10 seconds should be streamed 
global Music <cimport, nodecl> = @record{
   -- Type of music context audio filetype
   ctxType: cint,
   -- Audio context data depends on type
   ctxData: pointer,
   -- Total number of samples
   sampleCount: cint,
   -- Loops count times music will play 0 means infinite loop
   loopCount: cint,
   -- Audio stream
   stream: AudioStream,
}

-- Head-Mounted-Display device parameters 
global VrDeviceInfo <cimport, nodecl> = @record{
   -- HMD horizontal resolution in pixels
   hResolution: cint,
   -- HMD vertical resolution in pixels
   vResolution: cint,
   -- HMD horizontal size in meters
   hScreenSize: float32,
   -- HMD vertical size in meters
   vScreenSize: float32,
   -- HMD screen center in meters
   vScreenCenter: float32,
   -- HMD distance between eye and display in meters
   eyeToScreenDistance: float32,
   -- HMD lens separation distance in meters
   lensSeparationDistance: float32,
   -- HMD IPD distance between pupils in meters
   interpupillaryDistance: float32,
   -- HMD lens distortion constant parameters
   lensDistortionValues: array(float32, 4),
   -- HMD chromatic aberration correction parameters
   chromaAbCorrection: array(float32, 4),
}



-- Initialize window and OpenGL context 
function Raylib.InitWindow( width: cint, height: cint, title: cstring ):  void <cimport 'InitWindow', nodecl> end

-- Check if KEY_ESCAPE pressed or Close icon pressed 
function Raylib.WindowShouldClose( ):  boolean <cimport 'WindowShouldClose', nodecl> end

-- Close window and unload OpenGL context 
function Raylib.CloseWindow( ):  void <cimport 'CloseWindow', nodecl> end

-- Check if window has been initialized successfully 
function Raylib.IsWindowReady( ):  boolean <cimport 'IsWindowReady', nodecl> end

-- Check if window has been minimized or lost focus 
function Raylib.IsWindowMinimized( ):  boolean <cimport 'IsWindowMinimized', nodecl> end

-- Check if window has been resized 
function Raylib.IsWindowResized( ):  boolean <cimport 'IsWindowResized', nodecl> end

-- Check if window is currently hidden 
function Raylib.IsWindowHidden( ):  boolean <cimport 'IsWindowHidden', nodecl> end

-- Check if window is currently fullscreen 
function Raylib.IsWindowFullscreen( ):  boolean <cimport 'IsWindowFullscreen', nodecl> end

-- Toggle fullscreen mode only PLATFORM_DESKTOP 
function Raylib.ToggleFullscreen( ):  void <cimport 'ToggleFullscreen', nodecl> end

-- Show the window 
function Raylib.UnhideWindow( ):  void <cimport 'UnhideWindow', nodecl> end

-- Hide the window 
function Raylib.HideWindow( ):  void <cimport 'HideWindow', nodecl> end

-- Set icon for window only PLATFORM_DESKTOP 
function Raylib.SetWindowIcon( image: Image ):  void <cimport 'SetWindowIcon', nodecl> end

-- Set title for window only PLATFORM_DESKTOP 
function Raylib.SetWindowTitle( title: cstring ):  void <cimport 'SetWindowTitle', nodecl> end

-- Set window position on screen only PLATFORM_DESKTOP 
function Raylib.SetWindowPosition( x: cint, y: cint ):  void <cimport 'SetWindowPosition', nodecl> end

-- Set monitor for the current window fullscreen mode 
function Raylib.SetWindowMonitor( monitor: cint ):  void <cimport 'SetWindowMonitor', nodecl> end

-- Set window minimum dimensions for FLAG_WINDOW_RESIZABLE 
function Raylib.SetWindowMinSize( width: cint, height: cint ):  void <cimport 'SetWindowMinSize', nodecl> end

-- Set window dimensions 
function Raylib.SetWindowSize( width: cint, height: cint ):  void <cimport 'SetWindowSize', nodecl> end

-- Get native window handle 
function Raylib.GetWindowHandle( ):  pointer <cimport 'GetWindowHandle', nodecl> end

-- Get current screen width 
function Raylib.GetScreenWidth( ):  cint <cimport 'GetScreenWidth', nodecl> end

-- Get current screen height 
function Raylib.GetScreenHeight( ):  cint <cimport 'GetScreenHeight', nodecl> end

-- Get number of connected monitors 
function Raylib.GetMonitorCount( ):  cint <cimport 'GetMonitorCount', nodecl> end

-- Get primary monitor width 
function Raylib.GetMonitorWidth( monitor: cint ):  cint <cimport 'GetMonitorWidth', nodecl> end

-- Get primary monitor height 
function Raylib.GetMonitorHeight( monitor: cint ):  cint <cimport 'GetMonitorHeight', nodecl> end

-- Get primary monitor physical width in millimetres 
function Raylib.GetMonitorPhysicalWidth( monitor: cint ):  cint <cimport 'GetMonitorPhysicalWidth', nodecl> end

-- Get primary monitor physical height in millimetres 
function Raylib.GetMonitorPhysicalHeight( monitor: cint ):  cint <cimport 'GetMonitorPhysicalHeight', nodecl> end

-- Get window position XY on monitor 
function Raylib.GetWindowPosition( ):  Vector2 <cimport 'GetWindowPosition', nodecl> end

-- Get the human readable UTF 8 encoded name of the primary monitor 
function Raylib.GetMonitorName( monitor: cint ):  cstring <cimport 'GetMonitorName', nodecl> end

-- Get clipboard text content 
function Raylib.GetClipboardText( ):  cstring <cimport 'GetClipboardText', nodecl> end

-- Set clipboard text content 
function Raylib.SetClipboardText( text: cstring ):  void <cimport 'SetClipboardText', nodecl> end

-- Shows cursor 
function Raylib.ShowCursor( ):  void <cimport 'ShowCursor', nodecl> end

-- Hides cursor 
function Raylib.HideCursor( ):  void <cimport 'HideCursor', nodecl> end

-- Check if cursor is not visible 
function Raylib.IsCursorHidden( ):  boolean <cimport 'IsCursorHidden', nodecl> end

-- Enables cursor unlock cursor 
function Raylib.EnableCursor( ):  void <cimport 'EnableCursor', nodecl> end

-- Disables cursor lock cursor 
function Raylib.DisableCursor( ):  void <cimport 'DisableCursor', nodecl> end

-- Set background color framebuffer clear color 
function Raylib.ClearBackground( color: Color ):  void <cimport 'ClearBackground', nodecl> end

-- Setup canvas framebuffer to start drawing 
function Raylib.BeginDrawing( ):  void <cimport 'BeginDrawing', nodecl> end

-- End canvas drawing and swap buffers double buffering 
function Raylib.EndDrawing( ):  void <cimport 'EndDrawing', nodecl> end

-- Initialize 2D mode with custom camera 2D 
function Raylib.BeginMode2D( camera: Camera2D ):  void <cimport 'BeginMode2D', nodecl> end

-- Ends 2D mode with custom camera 
function Raylib.EndMode2D( ):  void <cimport 'EndMode2D', nodecl> end

-- Initializes 3D mode with custom camera 3D 
function Raylib.BeginMode3D( camera: Camera3D ):  void <cimport 'BeginMode3D', nodecl> end

-- Ends 3D mode and returns to default 2D orthographic mode 
function Raylib.EndMode3D( ):  void <cimport 'EndMode3D', nodecl> end

-- Initializes render texture for drawing 
function Raylib.BeginTextureMode( target: RenderTexture2D ):  void <cimport 'BeginTextureMode', nodecl> end

-- Ends drawing to render texture 
function Raylib.EndTextureMode( ):  void <cimport 'EndTextureMode', nodecl> end

-- Begin scissor mode define screen area for following drawing 
function Raylib.BeginScissorMode( x: cint, y: cint, width: cint, height: cint ):  void <cimport 'BeginScissorMode', nodecl> end

-- End scissor mode 
function Raylib.EndScissorMode( ):  void <cimport 'EndScissorMode', nodecl> end

-- Returns a ray trace from mouse position 
function Raylib.GetMouseRay( mousePosition: Vector2, camera: Camera ):  Ray <cimport 'GetMouseRay', nodecl> end

-- Returns camera transform matrix view matrix 
function Raylib.GetCameraMatrix( camera: Camera ):  Matrix <cimport 'GetCameraMatrix', nodecl> end

-- Returns camera 2d transform matrix 
function Raylib.GetCameraMatrix2D( camera: Camera2D ):  Matrix <cimport 'GetCameraMatrix2D', nodecl> end

-- Returns the screen space position for a 3d world space position 
function Raylib.GetWorldToScreen( position: Vector3, camera: Camera ):  Vector2 <cimport 'GetWorldToScreen', nodecl> end

-- Returns size position for a 3d world space position 
function Raylib.GetWorldToScreenEx( position: Vector3, camera: Camera, width: cint, height: cint ):  Vector2 <cimport 'GetWorldToScreenEx', nodecl> end

-- Returns the screen space position for a 2d camera world space position 
function Raylib.GetWorldToScreen2D( position: Vector2, camera: Camera2D ):  Vector2 <cimport 'GetWorldToScreen2D', nodecl> end

-- Returns the world space position for a 2d camera screen space position 
function Raylib.GetScreenToWorld2D( position: Vector2, camera: Camera2D ):  Vector2 <cimport 'GetScreenToWorld2D', nodecl> end

-- Set target FPS maximum 
function Raylib.SetTargetFPS( fps: cint ):  void <cimport 'SetTargetFPS', nodecl> end

-- Returns current FPS 
function Raylib.GetFPS( ):  cint <cimport 'GetFPS', nodecl> end

-- Returns time in seconds for last frame drawn 
function Raylib.GetFrameTime( ):  float32 <cimport 'GetFrameTime', nodecl> end

-- Returns elapsed time in seconds since InitWindow 
function Raylib.GetTime( ):  float64 <cimport 'GetTime', nodecl> end

-- Returns hexadecimal value for a Color 
function Raylib.ColorToInt( color: Color ):  cint <cimport 'ColorToInt', nodecl> end

-- Returns color normalized as float 0 1 
function Raylib.ColorNormalize( color: Color ):  Vector4 <cimport 'ColorNormalize', nodecl> end

-- Returns color from normalized values 0 1 
function Raylib.ColorFromNormalized( normalized: Vector4 ):  Color <cimport 'ColorFromNormalized', nodecl> end

-- Returns HSV values for a Color 
function Raylib.ColorToHSV( color: Color ):  Vector3 <cimport 'ColorToHSV', nodecl> end

-- Returns a Color from HSV values 
function Raylib.ColorFromHSV( hsv: Vector3 ):  Color <cimport 'ColorFromHSV', nodecl> end

-- Returns a Color struct from hexadecimal value 
function Raylib.GetColor( hexValue: cint ):  Color <cimport 'GetColor', nodecl> end

-- Color fade in or fade out alpha goes from 0 0f to 1 0f 
function Raylib.Fade( color: Color, alpha: float32 ):  Color <cimport 'Fade', nodecl> end

-- Setup window configuration flags view FLAGS 
function Raylib.SetConfigFlags( flags: cint ):  void <cimport 'SetConfigFlags', nodecl> end

-- Set the current threshold minimum log level 
function Raylib.SetTraceLogLevel( logType: cint ):  void <cimport 'SetTraceLogLevel', nodecl> end

-- Set the exit threshold minimum log level 
function Raylib.SetTraceLogExit( logType: cint ):  void <cimport 'SetTraceLogExit', nodecl> end

-- Set a trace log callback to enable custom logging 
function Raylib.SetTraceLogCallback( callback: TraceLogCallback ):  void <cimport 'SetTraceLogCallback', nodecl> end

-- Show trace log messages LOG_DEBUG LOG_INFO LOG_WARNING LOG_ERROR 
function Raylib.TraceLog( logType: cint, text: cstring, ... ):  void <cimport 'TraceLog', nodecl> end

-- Takes a screenshot of current screen saved a png 
function Raylib.TakeScreenshot( fileName: cstring ):  void <cimport 'TakeScreenshot', nodecl> end

-- Returns a random value between min and max both included 
function Raylib.GetRandomValue( min: cint, max: cint ):  cint <cimport 'GetRandomValue', nodecl> end

-- Load file data as byte array read 
function Raylib.LoadFileData( fileName: cstring, bytesRead: pointer(cint) ):  cstring <cimport 'LoadFileData', nodecl> end

-- Save data to file from byte array write 
function Raylib.SaveFileData( fileName: cstring, data: pointer, bytesToWrite: cint ):  void <cimport 'SaveFileData', nodecl> end

-- Load text data from file read returns a 0 terminated string 
function Raylib.LoadFileText( fileName: cstring ):  cstring <cimport 'LoadFileText', nodecl> end

-- Save text data to file write string must be 0 terminated 
function Raylib.SaveFileText( fileName: cstring, text: cstring ):  void <cimport 'SaveFileText', nodecl> end

-- Check if file exists 
function Raylib.FileExists( fileName: cstring ):  boolean <cimport 'FileExists', nodecl> end

-- Check file extension 
function Raylib.IsFileExtension( fileName: cstring, ext: cstring ):  boolean <cimport 'IsFileExtension', nodecl> end

-- Check if a directory path exists 
function Raylib.DirectoryExists( dirPath: cstring ):  boolean <cimport 'DirectoryExists', nodecl> end

-- Get pointer to extension for a filename string 
function Raylib.GetExtension( fileName: cstring ):  cstring <cimport 'GetExtension', nodecl> end

-- Get pointer to filename for a path string 
function Raylib.GetFileName( filePath: cstring ):  cstring <cimport 'GetFileName', nodecl> end

-- Get filename string without extension uses static string 
function Raylib.GetFileNameWithoutExt( filePath: cstring ):  cstring <cimport 'GetFileNameWithoutExt', nodecl> end

-- Get full path for a given fileName with path uses static string 
function Raylib.GetDirectoryPath( filePath: cstring ):  cstring <cimport 'GetDirectoryPath', nodecl> end

-- Get previous directory path for a given path uses static string 
function Raylib.GetPrevDirectoryPath( dirPath: cstring ):  cstring <cimport 'GetPrevDirectoryPath', nodecl> end

-- Get current working directory uses static string 
function Raylib.GetWorkingDirectory( ):  cstring <cimport 'GetWorkingDirectory', nodecl> end

-- Get filenames in a directory path memory should be freed 
function Raylib.GetDirectoryFiles( dirPath: cstring, count: pointer(cint) ):  pointer(pointer(cchar)) <cimport 'GetDirectoryFiles', nodecl> end

-- Clear directory files paths buffers free memory 
function Raylib.ClearDirectoryFiles( ):  void <cimport 'ClearDirectoryFiles', nodecl> end

-- Change working directory returns true if success 
function Raylib.ChangeDirectory( dir: cstring ):  boolean <cimport 'ChangeDirectory', nodecl> end

-- Check if a file has been dropped into window 
function Raylib.IsFileDropped( ):  boolean <cimport 'IsFileDropped', nodecl> end

-- Get dropped files names memory should be freed 
function Raylib.GetDroppedFiles( count: pointer(cint) ):  pointer(pointer(cchar)) <cimport 'GetDroppedFiles', nodecl> end

-- Clear dropped files paths buffer free memory 
function Raylib.ClearDroppedFiles( ):  void <cimport 'ClearDroppedFiles', nodecl> end

-- Get file modification time last write time 
function Raylib.GetFileModTime( fileName: cstring ):  clong <cimport 'GetFileModTime', nodecl> end

-- Compress data DEFLATE algorythm 
function Raylib.CompressData( data: cstring, dataLength: cint, compDataLength: pointer(cint) ):  cstring <cimport 'CompressData', nodecl> end

-- Decompress data DEFLATE algorythm 
function Raylib.DecompressData( compData: cstring, compDataLength: cint, dataLength: pointer(cint) ):  cstring <cimport 'DecompressData', nodecl> end

-- Save integer value to storage file to defined position 
function Raylib.SaveStorageValue( position: cint, value: cint ):  void <cimport 'SaveStorageValue', nodecl> end

-- Load integer value from storage file from defined position 
function Raylib.LoadStorageValue( position: cint ):  cint <cimport 'LoadStorageValue', nodecl> end

-- Open URL with default system browser if available 
function Raylib.OpenURL( url: cstring ):  void <cimport 'OpenURL', nodecl> end

-- Detect if a key has been pressed once 
function Raylib.IsKeyPressed( key: cint ):  boolean <cimport 'IsKeyPressed', nodecl> end

-- Detect if a key is being pressed 
function Raylib.IsKeyDown( key: cint ):  boolean <cimport 'IsKeyDown', nodecl> end

-- Detect if a key has been released once 
function Raylib.IsKeyReleased( key: cint ):  boolean <cimport 'IsKeyReleased', nodecl> end

-- Detect if a key is NOT being pressed 
function Raylib.IsKeyUp( key: cint ):  boolean <cimport 'IsKeyUp', nodecl> end

-- Set a custom key to exit program default is ESC 
function Raylib.SetExitKey( key: cint ):  void <cimport 'SetExitKey', nodecl> end

-- Get key pressed call it multiple times for chars queued 
function Raylib.GetKeyPressed( ):  cint <cimport 'GetKeyPressed', nodecl> end

-- Detect if a gamepad is available 
function Raylib.IsGamepadAvailable( gamepad: cint ):  boolean <cimport 'IsGamepadAvailable', nodecl> end

-- Check gamepad name if available 
function Raylib.IsGamepadName( gamepad: cint, name: cstring ):  boolean <cimport 'IsGamepadName', nodecl> end

-- Return gamepad internal name id 
function Raylib.GetGamepadName( gamepad: cint ):  cstring <cimport 'GetGamepadName', nodecl> end

-- Detect if a gamepad button has been pressed once 
function Raylib.IsGamepadButtonPressed( gamepad: cint, button: cint ):  boolean <cimport 'IsGamepadButtonPressed', nodecl> end

-- Detect if a gamepad button is being pressed 
function Raylib.IsGamepadButtonDown( gamepad: cint, button: cint ):  boolean <cimport 'IsGamepadButtonDown', nodecl> end

-- Detect if a gamepad button has been released once 
function Raylib.IsGamepadButtonReleased( gamepad: cint, button: cint ):  boolean <cimport 'IsGamepadButtonReleased', nodecl> end

-- Detect if a gamepad button is NOT being pressed 
function Raylib.IsGamepadButtonUp( gamepad: cint, button: cint ):  boolean <cimport 'IsGamepadButtonUp', nodecl> end

-- Get the last gamepad button pressed 
function Raylib.GetGamepadButtonPressed( ):  cint <cimport 'GetGamepadButtonPressed', nodecl> end

-- Return gamepad axis count for a gamepad 
function Raylib.GetGamepadAxisCount( gamepad: cint ):  cint <cimport 'GetGamepadAxisCount', nodecl> end

-- Return axis movement value for a gamepad axis 
function Raylib.GetGamepadAxisMovement( gamepad: cint, axis: cint ):  float32 <cimport 'GetGamepadAxisMovement', nodecl> end

-- Detect if a mouse button has been pressed once 
function Raylib.IsMouseButtonPressed( button: cint ):  boolean <cimport 'IsMouseButtonPressed', nodecl> end

-- Detect if a mouse button is being pressed 
function Raylib.IsMouseButtonDown( button: cint ):  boolean <cimport 'IsMouseButtonDown', nodecl> end

-- Detect if a mouse button has been released once 
function Raylib.IsMouseButtonReleased( button: cint ):  boolean <cimport 'IsMouseButtonReleased', nodecl> end

-- Detect if a mouse button is NOT being pressed 
function Raylib.IsMouseButtonUp( button: cint ):  boolean <cimport 'IsMouseButtonUp', nodecl> end

-- Returns mouse position X 
function Raylib.GetMouseX( ):  cint <cimport 'GetMouseX', nodecl> end

-- Returns mouse position Y 
function Raylib.GetMouseY( ):  cint <cimport 'GetMouseY', nodecl> end

-- Returns mouse position XY 
function Raylib.GetMousePosition( ):  Vector2 <cimport 'GetMousePosition', nodecl> end

-- Set mouse position XY 
function Raylib.SetMousePosition( x: cint, y: cint ):  void <cimport 'SetMousePosition', nodecl> end

-- Set mouse offset 
function Raylib.SetMouseOffset( offsetX: cint, offsetY: cint ):  void <cimport 'SetMouseOffset', nodecl> end

-- Set mouse scaling 
function Raylib.SetMouseScale( scaleX: float32, scaleY: float32 ):  void <cimport 'SetMouseScale', nodecl> end

-- Returns mouse wheel movement Y 
function Raylib.GetMouseWheelMove( ):  cint <cimport 'GetMouseWheelMove', nodecl> end

-- Returns touch position X for touch point 0 relative to screen size 
function Raylib.GetTouchX( ):  cint <cimport 'GetTouchX', nodecl> end

-- Returns touch position Y for touch point 0 relative to screen size 
function Raylib.GetTouchY( ):  cint <cimport 'GetTouchY', nodecl> end

-- Returns touch position XY for a touch point index relative to screen size 
function Raylib.GetTouchPosition( index: cint ):  Vector2 <cimport 'GetTouchPosition', nodecl> end

-- Enable a set of gestures using flags 
function Raylib.SetGesturesEnabled( gestureFlags: cint ):  void <cimport 'SetGesturesEnabled', nodecl> end

-- Check if a gesture have been detected 
function Raylib.IsGestureDetected( gesture: cint ):  boolean <cimport 'IsGestureDetected', nodecl> end

-- Get latest detected gesture 
function Raylib.GetGestureDetected( ):  cint <cimport 'GetGestureDetected', nodecl> end

-- Get touch points count 
function Raylib.GetTouchPointsCount( ):  cint <cimport 'GetTouchPointsCount', nodecl> end

-- Get gesture hold time in milliseconds 
function Raylib.GetGestureHoldDuration( ):  float32 <cimport 'GetGestureHoldDuration', nodecl> end

-- Get gesture drag vector 
function Raylib.GetGestureDragVector( ):  Vector2 <cimport 'GetGestureDragVector', nodecl> end

-- Get gesture drag angle 
function Raylib.GetGestureDragAngle( ):  float32 <cimport 'GetGestureDragAngle', nodecl> end

-- Get gesture pinch delta 
function Raylib.GetGesturePinchVector( ):  Vector2 <cimport 'GetGesturePinchVector', nodecl> end

-- Get gesture pinch angle 
function Raylib.GetGesturePinchAngle( ):  float32 <cimport 'GetGesturePinchAngle', nodecl> end

-- Set camera mode multiple camera modes available 
function Raylib.SetCameraMode( camera: Camera, mode: cint ):  void <cimport 'SetCameraMode', nodecl> end

-- Update camera position for selected mode 
function Raylib.UpdateCamera( camera: pointer(Camera) ):  void <cimport 'UpdateCamera', nodecl> end

-- Set camera pan key to combine with mouse movement free camera 
function Raylib.SetCameraPanControl( panKey: cint ):  void <cimport 'SetCameraPanControl', nodecl> end

-- Set camera alt key to combine with mouse movement free camera 
function Raylib.SetCameraAltControl( altKey: cint ):  void <cimport 'SetCameraAltControl', nodecl> end

-- Set camera smooth zoom key to combine with mouse free camera 
function Raylib.SetCameraSmoothZoomControl( szKey: cint ):  void <cimport 'SetCameraSmoothZoomControl', nodecl> end

-- Set camera move controls 1st person and 3rd person cameras 
function Raylib.SetCameraMoveControls( frontKey: cint, backKey: cint, rightKey: cint, leftKey: cint, upKey: cint, downKey: cint ):  void <cimport 'SetCameraMoveControls', nodecl> end

-- Draw a pixel 
function Raylib.DrawPixel( posX: cint, posY: cint, color: Color ):  void <cimport 'DrawPixel', nodecl> end

-- Draw a pixel Vector version 
function Raylib.DrawPixelV( position: Vector2, color: Color ):  void <cimport 'DrawPixelV', nodecl> end

-- Draw a line 
function Raylib.DrawLine( startPosX: cint, startPosY: cint, endPosX: cint, endPosY: cint, color: Color ):  void <cimport 'DrawLine', nodecl> end

-- Draw a line Vector version 
function Raylib.DrawLineV( startPos: Vector2, endPos: Vector2, color: Color ):  void <cimport 'DrawLineV', nodecl> end

-- Draw a line defining thickness 
function Raylib.DrawLineEx( startPos: Vector2, endPos: Vector2, thick: float32, color: Color ):  void <cimport 'DrawLineEx', nodecl> end

-- Draw a line using cubic bezier curves in out 
function Raylib.DrawLineBezier( startPos: Vector2, endPos: Vector2, thick: float32, color: Color ):  void <cimport 'DrawLineBezier', nodecl> end

-- Draw lines sequence 
function Raylib.DrawLineStrip( points: pointer(Vector2), numPoints: cint, color: Color ):  void <cimport 'DrawLineStrip', nodecl> end

-- Draw a color filled circle 
function Raylib.DrawCircle( centerX: cint, centerY: cint, radius: float32, color: Color ):  void <cimport 'DrawCircle', nodecl> end

-- Draw a piece of a circle 
function Raylib.DrawCircleSector( center: Vector2, radius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color ):  void <cimport 'DrawCircleSector', nodecl> end

-- Draw circle sector outline 
function Raylib.DrawCircleSectorLines( center: Vector2, radius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color ):  void <cimport 'DrawCircleSectorLines', nodecl> end

-- Draw a gradient filled circle 
function Raylib.DrawCircleGradient( centerX: cint, centerY: cint, radius: float32, color1: Color, color2: Color ):  void <cimport 'DrawCircleGradient', nodecl> end

-- Draw a color filled circle Vector version 
function Raylib.DrawCircleV( center: Vector2, radius: float32, color: Color ):  void <cimport 'DrawCircleV', nodecl> end

-- Draw circle outline 
function Raylib.DrawCircleLines( centerX: cint, centerY: cint, radius: float32, color: Color ):  void <cimport 'DrawCircleLines', nodecl> end

-- Draw ellipse 
function Raylib.DrawEllipse( centerX: cint, centerY: cint, radiusH: float32, radiusV: float32, color: Color ):  void <cimport 'DrawEllipse', nodecl> end

-- Draw ellipse outline 
function Raylib.DrawEllipseLines( centerX: cint, centerY: cint, radiusH: float32, radiusV: float32, color: Color ):  void <cimport 'DrawEllipseLines', nodecl> end

-- Draw ring 
function Raylib.DrawRing( center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color ):  void <cimport 'DrawRing', nodecl> end

-- Draw ring outline 
function Raylib.DrawRingLines( center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color ):  void <cimport 'DrawRingLines', nodecl> end

-- Draw a color filled rectangle 
function Raylib.DrawRectangle( posX: cint, posY: cint, width: cint, height: cint, color: Color ):  void <cimport 'DrawRectangle', nodecl> end

-- Draw a color filled rectangle Vector version 
function Raylib.DrawRectangleV( position: Vector2, size: Vector2, color: Color ):  void <cimport 'DrawRectangleV', nodecl> end

-- Draw a color filled rectangle 
function Raylib.DrawRectangleRec( rec: Rectangle, color: Color ):  void <cimport 'DrawRectangleRec', nodecl> end

-- Draw a color filled rectangle with pro parameters 
function Raylib.DrawRectanglePro( rec: Rectangle, origin: Vector2, rotation: float32, color: Color ):  void <cimport 'DrawRectanglePro', nodecl> end

-- Draw a vertical gradient filled rectangle 
function Raylib.DrawRectangleGradientV( posX: cint, posY: cint, width: cint, height: cint, color1: Color, color2: Color ):  void <cimport 'DrawRectangleGradientV', nodecl> end

-- Draw a horizontal gradient filled rectangle 
function Raylib.DrawRectangleGradientH( posX: cint, posY: cint, width: cint, height: cint, color1: Color, color2: Color ):  void <cimport 'DrawRectangleGradientH', nodecl> end

-- Draw a gradient filled rectangle with custom vertex colors 
function Raylib.DrawRectangleGradientEx( rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color ):  void <cimport 'DrawRectangleGradientEx', nodecl> end

-- Draw rectangle outline 
function Raylib.DrawRectangleLines( posX: cint, posY: cint, width: cint, height: cint, color: Color ):  void <cimport 'DrawRectangleLines', nodecl> end

-- Draw rectangle outline with extended parameters 
function Raylib.DrawRectangleLinesEx( rec: Rectangle, lineThick: cint, color: Color ):  void <cimport 'DrawRectangleLinesEx', nodecl> end

-- Draw rectangle with rounded edges 
function Raylib.DrawRectangleRounded( rec: Rectangle, roundness: float32, segments: cint, color: Color ):  void <cimport 'DrawRectangleRounded', nodecl> end

-- Draw rectangle with rounded edges outline 
function Raylib.DrawRectangleRoundedLines( rec: Rectangle, roundness: float32, segments: cint, lineThick: cint, color: Color ):  void <cimport 'DrawRectangleRoundedLines', nodecl> end

-- Draw a color filled triangle vertex in counter clockwise order 
function Raylib.DrawTriangle( v1: Vector2, v2: Vector2, v3: Vector2, color: Color ):  void <cimport 'DrawTriangle', nodecl> end

-- Draw triangle outline vertex in counter clockwise order 
function Raylib.DrawTriangleLines( v1: Vector2, v2: Vector2, v3: Vector2, color: Color ):  void <cimport 'DrawTriangleLines', nodecl> end

-- Draw a triangle fan defined by points first vertex is the center 
function Raylib.DrawTriangleFan( points: pointer(Vector2), numPoints: cint, color: Color ):  void <cimport 'DrawTriangleFan', nodecl> end

-- Draw a triangle strip defined by points 
function Raylib.DrawTriangleStrip( points: pointer(Vector2), pointsCount: cint, color: Color ):  void <cimport 'DrawTriangleStrip', nodecl> end

-- Draw a regular polygon Vector version 
function Raylib.DrawPoly( center: Vector2, sides: cint, radius: float32, rotation: float32, color: Color ):  void <cimport 'DrawPoly', nodecl> end

-- Draw a polygon outline of n sides 
function Raylib.DrawPolyLines( center: Vector2, sides: cint, radius: float32, rotation: float32, color: Color ):  void <cimport 'DrawPolyLines', nodecl> end

-- Check collision between two rectangles 
function Raylib.CheckCollisionRecs( rec1: Rectangle, rec2: Rectangle ):  boolean <cimport 'CheckCollisionRecs', nodecl> end

-- Check collision between two circles 
function Raylib.CheckCollisionCircles( center1: Vector2, radius1: float32, center2: Vector2, radius2: float32 ):  boolean <cimport 'CheckCollisionCircles', nodecl> end

-- Check collision between circle and rectangle 
function Raylib.CheckCollisionCircleRec( center: Vector2, radius: float32, rec: Rectangle ):  boolean <cimport 'CheckCollisionCircleRec', nodecl> end

-- Get collision rectangle for two rectangles collision 
function Raylib.GetCollisionRec( rec1: Rectangle, rec2: Rectangle ):  Rectangle <cimport 'GetCollisionRec', nodecl> end

-- Check if point is inside rectangle 
function Raylib.CheckCollisionPointRec( point: Vector2, rec: Rectangle ):  boolean <cimport 'CheckCollisionPointRec', nodecl> end

-- Check if point is inside circle 
function Raylib.CheckCollisionPointCircle( point: Vector2, center: Vector2, radius: float32 ):  boolean <cimport 'CheckCollisionPointCircle', nodecl> end

-- Check if point is inside a triangle 
function Raylib.CheckCollisionPointTriangle( point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2 ):  boolean <cimport 'CheckCollisionPointTriangle', nodecl> end

-- Load image from file into CPU memory RAM 
function Raylib.LoadImage( fileName: cstring ):  Image <cimport 'LoadImage', nodecl> end

-- Load image from Color array data RGBA 32bit 
function Raylib.LoadImageEx( pixels: pointer(Color), width: cint, height: cint ):  Image <cimport 'LoadImageEx', nodecl> end

-- Load image from raw data with parameters 
function Raylib.LoadImagePro( data: pointer, width: cint, height: cint, format: cint ):  Image <cimport 'LoadImagePro', nodecl> end

-- Load image from RAW file data 
function Raylib.LoadImageRaw( fileName: cstring, width: cint, height: cint, format: cint, headerSize: cint ):  Image <cimport 'LoadImageRaw', nodecl> end

-- Unload image from CPU memory RAM 
function Raylib.UnloadImage( image: Image ):  void <cimport 'UnloadImage', nodecl> end

-- Export image data to file 
function Raylib.ExportImage( image: Image, fileName: cstring ):  void <cimport 'ExportImage', nodecl> end

-- Export image as code file defining an array of bytes 
function Raylib.ExportImageAsCode( image: Image, fileName: cstring ):  void <cimport 'ExportImageAsCode', nodecl> end

-- Get pixel data from image as a Color struct array 
function Raylib.GetImageData( image: Image ):  pointer(Color) <cimport 'GetImageData', nodecl> end

-- Get pixel data from image as Vector4 array float normalized 
function Raylib.GetImageDataNormalized( image: Image ):  pointer(Vector4) <cimport 'GetImageDataNormalized', nodecl> end

-- Generate image plain color 
function Raylib.GenImageColor( width: cint, height: cint, color: Color ):  Image <cimport 'GenImageColor', nodecl> end

-- Generate image vertical gradient 
function Raylib.GenImageGradientV( width: cint, height: cint, top: Color, bottom: Color ):  Image <cimport 'GenImageGradientV', nodecl> end

-- Generate image horizontal gradient 
function Raylib.GenImageGradientH( width: cint, height: cint, left: Color, right: Color ):  Image <cimport 'GenImageGradientH', nodecl> end

-- Generate image radial gradient 
function Raylib.GenImageGradientRadial( width: cint, height: cint, density: float32, inner: Color, outer: Color ):  Image <cimport 'GenImageGradientRadial', nodecl> end

-- Generate image checked 
function Raylib.GenImageChecked( width: cint, height: cint, checksX: cint, checksY: cint, col1: Color, col2: Color ):  Image <cimport 'GenImageChecked', nodecl> end

-- Generate image white noise 
function Raylib.GenImageWhiteNoise( width: cint, height: cint, factor: float32 ):  Image <cimport 'GenImageWhiteNoise', nodecl> end

-- Generate image perlin noise 
function Raylib.GenImagePerlinNoise( width: cint, height: cint, offsetX: cint, offsetY: cint, scale: float32 ):  Image <cimport 'GenImagePerlinNoise', nodecl> end

-- Generate image cellular algorithm Bigger tileSize means bigger cells 
function Raylib.GenImageCellular( width: cint, height: cint, tileSize: cint ):  Image <cimport 'GenImageCellular', nodecl> end

-- Create an image duplicate useful for transformations 
function Raylib.ImageCopy( image: Image ):  Image <cimport 'ImageCopy', nodecl> end

-- Create an image from another image piece 
function Raylib.ImageFromImage( image: Image, rec: Rectangle ):  Image <cimport 'ImageFromImage', nodecl> end

-- Create an image from text default font 
function Raylib.ImageText( text: cstring, fontSize: cint, color: Color ):  Image <cimport 'ImageText', nodecl> end

-- Create an image from text custom sprite font 
function Raylib.ImageTextEx( font: Font, text: cstring, fontSize: float32, spacing: float32, tint: Color ):  Image <cimport 'ImageTextEx', nodecl> end

-- Convert image to POT power of two 
function Raylib.ImageToPOT( image: pointer(Image), fillColor: Color ):  void <cimport 'ImageToPOT', nodecl> end

-- Convert image data to desired format 
function Raylib.ImageFormat( image: pointer(Image), newFormat: cint ):  void <cimport 'ImageFormat', nodecl> end

-- Apply alpha mask to image 
function Raylib.ImageAlphaMask( image: pointer(Image), alphaMask: Image ):  void <cimport 'ImageAlphaMask', nodecl> end

-- Clear alpha channel to desired color 
function Raylib.ImageAlphaClear( image: pointer(Image), color: Color, threshold: float32 ):  void <cimport 'ImageAlphaClear', nodecl> end

-- Crop image depending on alpha value 
function Raylib.ImageAlphaCrop( image: pointer(Image), threshold: float32 ):  void <cimport 'ImageAlphaCrop', nodecl> end

-- Premultiply alpha channel 
function Raylib.ImageAlphaPremultiply( image: pointer(Image) ):  void <cimport 'ImageAlphaPremultiply', nodecl> end

-- Crop an image to a defined rectangle 
function Raylib.ImageCrop( image: pointer(Image), crop: Rectangle ):  void <cimport 'ImageCrop', nodecl> end

-- Resize image Bicubic scaling algorithm 
function Raylib.ImageResize( image: pointer(Image), newWidth: cint, newHeight: cint ):  void <cimport 'ImageResize', nodecl> end

-- Resize image Nearest Neighbor scaling algorithm 
function Raylib.ImageResizeNN( image: pointer(Image), newWidth: cint, newHeight: cint ):  void <cimport 'ImageResizeNN', nodecl> end

-- Resize canvas and fill with color 
function Raylib.ImageResizeCanvas( image: pointer(Image), newWidth: cint, newHeight: cint, offsetX: cint, offsetY: cint, color: Color ):  void <cimport 'ImageResizeCanvas', nodecl> end

-- Generate all mipmap levels for a provided image 
function Raylib.ImageMipmaps( image: pointer(Image) ):  void <cimport 'ImageMipmaps', nodecl> end

-- Dither image data to 16bpp or lower Floyd Steinberg dithering 
function Raylib.ImageDither( image: pointer(Image), rBpp: cint, gBpp: cint, bBpp: cint, aBpp: cint ):  void <cimport 'ImageDither', nodecl> end

-- Flip image vertically 
function Raylib.ImageFlipVertical( image: pointer(Image) ):  void <cimport 'ImageFlipVertical', nodecl> end

-- Flip image horizontally 
function Raylib.ImageFlipHorizontal( image: pointer(Image) ):  void <cimport 'ImageFlipHorizontal', nodecl> end

-- Rotate image clockwise 90deg 
function Raylib.ImageRotateCW( image: pointer(Image) ):  void <cimport 'ImageRotateCW', nodecl> end

-- Rotate image counter clockwise 90deg 
function Raylib.ImageRotateCCW( image: pointer(Image) ):  void <cimport 'ImageRotateCCW', nodecl> end

-- Modify image color tint 
function Raylib.ImageColorTint( image: pointer(Image), color: Color ):  void <cimport 'ImageColorTint', nodecl> end

-- Modify image color invert 
function Raylib.ImageColorInvert( image: pointer(Image) ):  void <cimport 'ImageColorInvert', nodecl> end

-- Modify image color grayscale 
function Raylib.ImageColorGrayscale( image: pointer(Image) ):  void <cimport 'ImageColorGrayscale', nodecl> end

-- Modify image color contrast 100 to 100 
function Raylib.ImageColorContrast( image: pointer(Image), contrast: float32 ):  void <cimport 'ImageColorContrast', nodecl> end

-- Modify image color brightness 255 to 255 
function Raylib.ImageColorBrightness( image: pointer(Image), brightness: cint ):  void <cimport 'ImageColorBrightness', nodecl> end

-- Modify image color replace color 
function Raylib.ImageColorReplace( image: pointer(Image), color: Color, replace: Color ):  void <cimport 'ImageColorReplace', nodecl> end

-- Extract color palette from image to maximum size memory should be freed 
function Raylib.ImageExtractPalette( image: Image, maxPaletteSize: cint, extractCount: pointer(cint) ):  pointer(Color) <cimport 'ImageExtractPalette', nodecl> end

-- Get image alpha border rectangle 
function Raylib.GetImageAlphaBorder( image: Image, threshold: float32 ):  Rectangle <cimport 'GetImageAlphaBorder', nodecl> end

-- Clear image background with given color 
function Raylib.ImageClearBackground( dst: pointer(Image), color: Color ):  void <cimport 'ImageClearBackground', nodecl> end

-- Draw pixel within an image 
function Raylib.ImageDrawPixel( dst: pointer(Image), posX: cint, posY: cint, color: Color ):  void <cimport 'ImageDrawPixel', nodecl> end

-- Draw pixel within an image Vector version 
function Raylib.ImageDrawPixelV( dst: pointer(Image), position: Vector2, color: Color ):  void <cimport 'ImageDrawPixelV', nodecl> end

-- Draw line within an image 
function Raylib.ImageDrawLine( dst: pointer(Image), startPosX: cint, startPosY: cint, endPosX: cint, endPosY: cint, color: Color ):  void <cimport 'ImageDrawLine', nodecl> end

-- Draw line within an image Vector version 
function Raylib.ImageDrawLineV( dst: pointer(Image), start: Vector2, _end: Vector2, color: Color ):  void <cimport 'ImageDrawLineV', nodecl> end

-- Draw circle within an image 
function Raylib.ImageDrawCircle( dst: pointer(Image), centerX: cint, centerY: cint, radius: cint, color: Color ):  void <cimport 'ImageDrawCircle', nodecl> end

-- Draw circle within an image Vector version 
function Raylib.ImageDrawCircleV( dst: pointer(Image), center: Vector2, radius: cint, color: Color ):  void <cimport 'ImageDrawCircleV', nodecl> end

-- Draw rectangle within an image 
function Raylib.ImageDrawRectangle( dst: pointer(Image), posX: cint, posY: cint, width: cint, height: cint, color: Color ):  void <cimport 'ImageDrawRectangle', nodecl> end

-- Draw rectangle within an image Vector version 
function Raylib.ImageDrawRectangleV( dst: pointer(Image), position: Vector2, size: Vector2, color: Color ):  void <cimport 'ImageDrawRectangleV', nodecl> end

-- Draw rectangle within an image 
function Raylib.ImageDrawRectangleRec( dst: pointer(Image), rec: Rectangle, color: Color ):  void <cimport 'ImageDrawRectangleRec', nodecl> end

-- Draw rectangle lines within an image 
function Raylib.ImageDrawRectangleLines( dst: pointer(Image), rec: Rectangle, thick: cint, color: Color ):  void <cimport 'ImageDrawRectangleLines', nodecl> end

-- Draw a source image within a destination image tint applied to source 
function Raylib.ImageDraw( dst: pointer(Image), src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color ):  void <cimport 'ImageDraw', nodecl> end

-- Draw text default font within an image destination 
function Raylib.ImageDrawText( dst: pointer(Image), position: Vector2, text: cstring, fontSize: cint, color: Color ):  void <cimport 'ImageDrawText', nodecl> end

-- Draw text custom sprite font within an image destination 
function Raylib.ImageDrawTextEx( dst: pointer(Image), position: Vector2, font: Font, text: cstring, fontSize: float32, spacing: float32, color: Color ):  void <cimport 'ImageDrawTextEx', nodecl> end

-- Load texture from file into GPU memory VRAM 
function Raylib.LoadTexture( fileName: cstring ):  Texture2D <cimport 'LoadTexture', nodecl> end

-- Load texture from image data 
function Raylib.LoadTextureFromImage( image: Image ):  Texture2D <cimport 'LoadTextureFromImage', nodecl> end

-- Load cubemap from image multiple image cubemap layouts supported 
function Raylib.LoadTextureCubemap( image: Image, layoutType: cint ):  TextureCubemap <cimport 'LoadTextureCubemap', nodecl> end

-- Load texture for rendering framebuffer 
function Raylib.LoadRenderTexture( width: cint, height: cint ):  RenderTexture2D <cimport 'LoadRenderTexture', nodecl> end

-- Unload texture from GPU memory VRAM 
function Raylib.UnloadTexture( texture: Texture2D ):  void <cimport 'UnloadTexture', nodecl> end

-- Unload render texture from GPU memory VRAM 
function Raylib.UnloadRenderTexture( target: RenderTexture2D ):  void <cimport 'UnloadRenderTexture', nodecl> end

-- Update GPU texture with new data 
function Raylib.UpdateTexture( texture: Texture2D, pixels: pointer ):  void <cimport 'UpdateTexture', nodecl> end

-- Get pixel data from GPU texture and return an Image 
function Raylib.GetTextureData( texture: Texture2D ):  Image <cimport 'GetTextureData', nodecl> end

-- Get pixel data from screen buffer and return an Image screenshot 
function Raylib.GetScreenData( ):  Image <cimport 'GetScreenData', nodecl> end

-- Generate GPU mipmaps for a texture 
function Raylib.GenTextureMipmaps( texture: pointer(Texture2D) ):  void <cimport 'GenTextureMipmaps', nodecl> end

-- Set texture scaling filter mode 
function Raylib.SetTextureFilter( texture: Texture2D, filterMode: cint ):  void <cimport 'SetTextureFilter', nodecl> end

-- Set texture wrapping mode 
function Raylib.SetTextureWrap( texture: Texture2D, wrapMode: cint ):  void <cimport 'SetTextureWrap', nodecl> end

-- Draw a Texture2D 
function Raylib.DrawTexture( texture: Texture2D, posX: cint, posY: cint, tint: Color ):  void <cimport 'DrawTexture', nodecl> end

-- Draw a Texture2D with position defined as Vector2 
function Raylib.DrawTextureV( texture: Texture2D, position: Vector2, tint: Color ):  void <cimport 'DrawTextureV', nodecl> end

-- Draw a Texture2D with extended parameters 
function Raylib.DrawTextureEx( texture: Texture2D, position: Vector2, rotation: float32, scale: float32, tint: Color ):  void <cimport 'DrawTextureEx', nodecl> end

-- Draw a part of a texture defined by a rectangle 
function Raylib.DrawTextureRec( texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color ):  void <cimport 'DrawTextureRec', nodecl> end

-- Draw texture quad with tiling and offset parameters 
function Raylib.DrawTextureQuad( texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color ):  void <cimport 'DrawTextureQuad', nodecl> end

-- Draw a part of a texture defined by a rectangle with pro parameters 
function Raylib.DrawTexturePro( texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float32, tint: Color ):  void <cimport 'DrawTexturePro', nodecl> end

-- Draws a texture or part of it that stretches or shrinks nicely 
function Raylib.DrawTextureNPatch( texture: Texture2D, nPatchInfo: NPatchInfo, destRec: Rectangle, origin: Vector2, rotation: float32, tint: Color ):  void <cimport 'DrawTextureNPatch', nodecl> end

-- Get pixel data size in bytes image or texture 
function Raylib.GetPixelDataSize( width: cint, height: cint, format: cint ):  cint <cimport 'GetPixelDataSize', nodecl> end

-- Get the default Font 
function Raylib.GetFontDefault( ):  Font <cimport 'GetFontDefault', nodecl> end

-- Load font from file into GPU memory VRAM 
function Raylib.LoadFont( fileName: cstring ):  Font <cimport 'LoadFont', nodecl> end

-- Load font from file with extended parameters 
function Raylib.LoadFontEx( fileName: cstring, fontSize: cint, fontChars: pointer(cint), charsCount: cint ):  Font <cimport 'LoadFontEx', nodecl> end

-- Load font from Image XNA style 
function Raylib.LoadFontFromImage( image: Image, key: Color, firstChar: cint ):  Font <cimport 'LoadFontFromImage', nodecl> end

-- Load font data for further use 
function Raylib.LoadFontData( fileName: cstring, fontSize: cint, fontChars: pointer(cint), charsCount: cint, type: cint ):  pointer(CharInfo) <cimport 'LoadFontData', nodecl> end

-- Generate image font atlas using chars info 
function Raylib.GenImageFontAtlas( chars: pointer(CharInfo), recs: pointer(pointer(Rectangle)), charsCount: cint, fontSize: cint, padding: cint, packMethod: cint ):  Image <cimport 'GenImageFontAtlas', nodecl> end

-- Unload Font from GPU memory VRAM 
function Raylib.UnloadFont( font: Font ):  void <cimport 'UnloadFont', nodecl> end

-- Shows current FPS 
function Raylib.DrawFPS( posX: cint, posY: cint ):  void <cimport 'DrawFPS', nodecl> end

-- Draw text using default font 
function Raylib.DrawText( text: cstring, posX: cint, posY: cint, fontSize: cint, color: Color ):  void <cimport 'DrawText', nodecl> end

-- Draw text using font and additional parameters 
function Raylib.DrawTextEx( font: Font, text: cstring, position: Vector2, fontSize: float32, spacing: float32, tint: Color ):  void <cimport 'DrawTextEx', nodecl> end

-- Draw text using font inside rectangle limits 
function Raylib.DrawTextRec( font: Font, text: cstring, rec: Rectangle, fontSize: float32, spacing: float32, wordWrap: boolean, tint: Color ):  void <cimport 'DrawTextRec', nodecl> end

-- Draw text using font inside rectangle limits with support for text selection 
function Raylib.DrawTextRecEx( font: Font, text: cstring, rec: Rectangle, fontSize: float32, spacing: float32, wordWrap: boolean, tint: Color, selectStart: cint, selectLength: cint, selectTint: Color, selectBackTint: Color ):  void <cimport 'DrawTextRecEx', nodecl> end

-- Draw one character codepoint 
function Raylib.DrawTextCodepoint( font: Font, codepoint: cint, position: Vector2, scale: float32, tint: Color ):  void <cimport 'DrawTextCodepoint', nodecl> end

-- Measure string width for default font 
function Raylib.MeasureText( text: cstring, fontSize: cint ):  cint <cimport 'MeasureText', nodecl> end

-- Measure string size for Font 
function Raylib.MeasureTextEx( font: Font, text: cstring, fontSize: float32, spacing: float32 ):  Vector2 <cimport 'MeasureTextEx', nodecl> end

-- Get index position for a unicode character on font 
function Raylib.GetGlyphIndex( font: Font, codepoint: cint ):  cint <cimport 'GetGlyphIndex', nodecl> end

-- Copy one string to another returns bytes copied 
function Raylib.TextCopy( dst: cstring, src: cstring ):  cint <cimport 'TextCopy', nodecl> end

-- Check if two text string are equal 
function Raylib.TextIsEqual( text1: cstring, text2: cstring ):  boolean <cimport 'TextIsEqual', nodecl> end

-- Get text length checks for 0 ending 
function Raylib.TextLength( text: cstring ):  cint <cimport 'TextLength', nodecl> end

-- Text formatting with variables sprintf style 
function Raylib.TextFormat( text: cstring, ... ):  cstring <cimport 'TextFormat', nodecl> end

-- Get a piece of a text string 
function Raylib.TextSubtext( text: cstring, position: cint, length: cint ):  cstring <cimport 'TextSubtext', nodecl> end

-- Replace text string memory must be freed 
function Raylib.TextReplace( text: cstring, replace: cstring, by: cstring ):  cstring <cimport 'TextReplace', nodecl> end

-- Insert text in a position memory must be freed 
function Raylib.TextInsert( text: cstring, insert: cstring, position: cint ):  cstring <cimport 'TextInsert', nodecl> end

-- Join text strings with delimiter 
function Raylib.TextJoin( textList: pointer(pointer(cchar)), count: cint, delimiter: cstring ):  cstring <cimport 'TextJoin', nodecl> end

-- Split text into multiple strings 
function Raylib.TextSplit( text: cstring, delimiter: cchar, count: pointer(cint) ):  pointer(pointer(cchar)) <cimport 'TextSplit', nodecl> end

-- Append text at specific position and move cursor 
function Raylib.TextAppend( text: cstring, append: cstring, position: pointer(cint) ):  void <cimport 'TextAppend', nodecl> end

-- Find first text occurrence within a string 
function Raylib.TextFindIndex( text: cstring, find: cstring ):  cint <cimport 'TextFindIndex', nodecl> end

-- Get upper case version of provided string 
function Raylib.TextToUpper( text: cstring ):  cstring <cimport 'TextToUpper', nodecl> end

-- Get lower case version of provided string 
function Raylib.TextToLower( text: cstring ):  cstring <cimport 'TextToLower', nodecl> end

-- Get Pascal case notation version of provided string 
function Raylib.TextToPascal( text: cstring ):  cstring <cimport 'TextToPascal', nodecl> end

-- Get integer value from text negative values not supported 
function Raylib.TextToInteger( text: cstring ):  cint <cimport 'TextToInteger', nodecl> end

-- Encode text codepoint into utf8 text memory must be freed 
function Raylib.TextToUtf8( codepoints: pointer(cint), length: cint ):  cstring <cimport 'TextToUtf8', nodecl> end

-- Get all codepoints in a string codepoints count returned by parameters 
function Raylib.GetCodepoints( text: cstring, count: pointer(cint) ):  pointer(cint) <cimport 'GetCodepoints', nodecl> end

-- Get total number of characters codepoints in a UTF8 encoded string 
function Raylib.GetCodepointsCount( text: cstring ):  cint <cimport 'GetCodepointsCount', nodecl> end

-- Returns next codepoint in a UTF8 encoded string 0x3f is returned on failure 
function Raylib.GetNextCodepoint( text: cstring, bytesProcessed: pointer(cint) ):  cint <cimport 'GetNextCodepoint', nodecl> end

-- Encode codepoint into utf8 text char array length returned as parameter 
function Raylib.CodepointToUtf8( codepoint: cint, byteLength: pointer(cint) ):  cstring <cimport 'CodepointToUtf8', nodecl> end

-- Draw a line in 3D world space 
function Raylib.DrawLine3D( startPos: Vector3, endPos: Vector3, color: Color ):  void <cimport 'DrawLine3D', nodecl> end

-- Draw a point in 3D space actually a small line 
function Raylib.DrawPoint3D( position: Vector3, color: Color ):  void <cimport 'DrawPoint3D', nodecl> end

-- Draw a circle in 3D world space 
function Raylib.DrawCircle3D( center: Vector3, radius: float32, rotationAxis: Vector3, rotationAngle: float32, color: Color ):  void <cimport 'DrawCircle3D', nodecl> end

-- Draw cube 
function Raylib.DrawCube( position: Vector3, width: float32, height: float32, length: float32, color: Color ):  void <cimport 'DrawCube', nodecl> end

-- Draw cube Vector version 
function Raylib.DrawCubeV( position: Vector3, size: Vector3, color: Color ):  void <cimport 'DrawCubeV', nodecl> end

-- Draw cube wires 
function Raylib.DrawCubeWires( position: Vector3, width: float32, height: float32, length: float32, color: Color ):  void <cimport 'DrawCubeWires', nodecl> end

-- Draw cube wires Vector version 
function Raylib.DrawCubeWiresV( position: Vector3, size: Vector3, color: Color ):  void <cimport 'DrawCubeWiresV', nodecl> end

-- Draw cube textured 
function Raylib.DrawCubeTexture( texture: Texture2D, position: Vector3, width: float32, height: float32, length: float32, color: Color ):  void <cimport 'DrawCubeTexture', nodecl> end

-- Draw sphere 
function Raylib.DrawSphere( centerPos: Vector3, radius: float32, color: Color ):  void <cimport 'DrawSphere', nodecl> end

-- Draw sphere with extended parameters 
function Raylib.DrawSphereEx( centerPos: Vector3, radius: float32, rings: cint, slices: cint, color: Color ):  void <cimport 'DrawSphereEx', nodecl> end

-- Draw sphere wires 
function Raylib.DrawSphereWires( centerPos: Vector3, radius: float32, rings: cint, slices: cint, color: Color ):  void <cimport 'DrawSphereWires', nodecl> end

-- Draw a cylinder/cone 
function Raylib.DrawCylinder( position: Vector3, radiusTop: float32, radiusBottom: float32, height: float32, slices: cint, color: Color ):  void <cimport 'DrawCylinder', nodecl> end

-- Draw a cylinder/cone wires 
function Raylib.DrawCylinderWires( position: Vector3, radiusTop: float32, radiusBottom: float32, height: float32, slices: cint, color: Color ):  void <cimport 'DrawCylinderWires', nodecl> end

-- Draw a plane XZ 
function Raylib.DrawPlane( centerPos: Vector3, size: Vector2, color: Color ):  void <cimport 'DrawPlane', nodecl> end

-- Draw a ray line 
function Raylib.DrawRay( ray: Ray, color: Color ):  void <cimport 'DrawRay', nodecl> end

-- Draw a grid centered at 0 0 0 
function Raylib.DrawGrid( slices: cint, spacing: float32 ):  void <cimport 'DrawGrid', nodecl> end

-- Draw simple gizmo 
function Raylib.DrawGizmo( position: Vector3 ):  void <cimport 'DrawGizmo', nodecl> end

-- Load model from files meshes and materials 
function Raylib.LoadModel( fileName: cstring ):  Model <cimport 'LoadModel', nodecl> end

-- Load model from generated mesh default material 
function Raylib.LoadModelFromMesh( mesh: Mesh ):  Model <cimport 'LoadModelFromMesh', nodecl> end

-- Unload model from memory RAM and/or VRAM 
function Raylib.UnloadModel( model: Model ):  void <cimport 'UnloadModel', nodecl> end

-- Load meshes from model file 
function Raylib.LoadMeshes( fileName: cstring, meshCount: pointer(cint) ):  pointer(Mesh) <cimport 'LoadMeshes', nodecl> end

-- Export mesh data to file 
function Raylib.ExportMesh( mesh: Mesh, fileName: cstring ):  void <cimport 'ExportMesh', nodecl> end

-- Unload mesh from memory RAM and/or VRAM 
function Raylib.UnloadMesh( mesh: Mesh ):  void <cimport 'UnloadMesh', nodecl> end

-- Load materials from model file 
function Raylib.LoadMaterials( fileName: cstring, materialCount: pointer(cint) ):  pointer(Material) <cimport 'LoadMaterials', nodecl> end

-- Load default material Supports DIFFUSE SPECULAR NORMAL maps 
function Raylib.LoadMaterialDefault( ):  Material <cimport 'LoadMaterialDefault', nodecl> end

-- Unload material from GPU memory VRAM 
function Raylib.UnloadMaterial( material: Material ):  void <cimport 'UnloadMaterial', nodecl> end

-- Set texture for a material map type MAP_DIFFUSE MAP_SPECULARDOTDOTDOT 
function Raylib.SetMaterialTexture( material: pointer(Material), mapType: cint, texture: Texture2D ):  void <cimport 'SetMaterialTexture', nodecl> end

-- Set material for a mesh 
function Raylib.SetModelMeshMaterial( model: pointer(Model), meshId: cint, materialId: cint ):  void <cimport 'SetModelMeshMaterial', nodecl> end

-- Load model animations from file 
function Raylib.LoadModelAnimations( fileName: cstring, animsCount: pointer(cint) ):  pointer(ModelAnimation) <cimport 'LoadModelAnimations', nodecl> end

-- Update model animation pose 
function Raylib.UpdateModelAnimation( model: Model, anim: ModelAnimation, frame: cint ):  void <cimport 'UpdateModelAnimation', nodecl> end

-- Unload animation data 
function Raylib.UnloadModelAnimation( anim: ModelAnimation ):  void <cimport 'UnloadModelAnimation', nodecl> end

-- Check model animation skeleton match 
function Raylib.IsModelAnimationValid( model: Model, anim: ModelAnimation ):  boolean <cimport 'IsModelAnimationValid', nodecl> end

-- Generate polygonal mesh 
function Raylib.GenMeshPoly( sides: cint, radius: float32 ):  Mesh <cimport 'GenMeshPoly', nodecl> end

-- Generate plane mesh with subdivisions 
function Raylib.GenMeshPlane( width: float32, length: float32, resX: cint, resZ: cint ):  Mesh <cimport 'GenMeshPlane', nodecl> end

-- Generate cuboid mesh 
function Raylib.GenMeshCube( width: float32, height: float32, length: float32 ):  Mesh <cimport 'GenMeshCube', nodecl> end

-- Generate sphere mesh standard sphere 
function Raylib.GenMeshSphere( radius: float32, rings: cint, slices: cint ):  Mesh <cimport 'GenMeshSphere', nodecl> end

-- Generate half sphere mesh no bottom cap 
function Raylib.GenMeshHemiSphere( radius: float32, rings: cint, slices: cint ):  Mesh <cimport 'GenMeshHemiSphere', nodecl> end

-- Generate cylinder mesh 
function Raylib.GenMeshCylinder( radius: float32, height: float32, slices: cint ):  Mesh <cimport 'GenMeshCylinder', nodecl> end

-- Generate torus mesh 
function Raylib.GenMeshTorus( radius: float32, size: float32, radSeg: cint, sides: cint ):  Mesh <cimport 'GenMeshTorus', nodecl> end

-- Generate trefoil knot mesh 
function Raylib.GenMeshKnot( radius: float32, size: float32, radSeg: cint, sides: cint ):  Mesh <cimport 'GenMeshKnot', nodecl> end

-- Generate heightmap mesh from image data 
function Raylib.GenMeshHeightmap( heightmap: Image, size: Vector3 ):  Mesh <cimport 'GenMeshHeightmap', nodecl> end

-- Generate cubes based map mesh from image data 
function Raylib.GenMeshCubicmap( cubicmap: Image, cubeSize: Vector3 ):  Mesh <cimport 'GenMeshCubicmap', nodecl> end

-- Compute mesh bounding box limits 
function Raylib.MeshBoundingBox( mesh: Mesh ):  BoundingBox <cimport 'MeshBoundingBox', nodecl> end

-- Compute mesh tangents 
function Raylib.MeshTangents( mesh: pointer(Mesh) ):  void <cimport 'MeshTangents', nodecl> end

-- Compute mesh binormals 
function Raylib.MeshBinormals( mesh: pointer(Mesh) ):  void <cimport 'MeshBinormals', nodecl> end

-- Draw a model with texture if set 
function Raylib.DrawModel( model: Model, position: Vector3, scale: float32, tint: Color ):  void <cimport 'DrawModel', nodecl> end

-- Draw a model with extended parameters 
function Raylib.DrawModelEx( model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float32, scale: Vector3, tint: Color ):  void <cimport 'DrawModelEx', nodecl> end

-- Draw a model wires with texture if set 
function Raylib.DrawModelWires( model: Model, position: Vector3, scale: float32, tint: Color ):  void <cimport 'DrawModelWires', nodecl> end

-- Draw a model wires with texture if set with extended parameters 
function Raylib.DrawModelWiresEx( model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float32, scale: Vector3, tint: Color ):  void <cimport 'DrawModelWiresEx', nodecl> end

-- Draw bounding box wires 
function Raylib.DrawBoundingBox( box: BoundingBox, color: Color ):  void <cimport 'DrawBoundingBox', nodecl> end

-- Draw a billboard texture 
function Raylib.DrawBillboard( camera: Camera, texture: Texture2D, center: Vector3, size: float32, tint: Color ):  void <cimport 'DrawBillboard', nodecl> end

-- Draw a billboard texture defined by sourceRec 
function Raylib.DrawBillboardRec( camera: Camera, texture: Texture2D, sourceRec: Rectangle, center: Vector3, size: float32, tint: Color ):  void <cimport 'DrawBillboardRec', nodecl> end

-- Detect collision between two spheres 
function Raylib.CheckCollisionSpheres( centerA: Vector3, radiusA: float32, centerB: Vector3, radiusB: float32 ):  boolean <cimport 'CheckCollisionSpheres', nodecl> end

-- Detect collision between two bounding boxes 
function Raylib.CheckCollisionBoxes( box1: BoundingBox, box2: BoundingBox ):  boolean <cimport 'CheckCollisionBoxes', nodecl> end

-- Detect collision between box and sphere 
function Raylib.CheckCollisionBoxSphere( box: BoundingBox, center: Vector3, radius: float32 ):  boolean <cimport 'CheckCollisionBoxSphere', nodecl> end

-- Detect collision between ray and sphere 
function Raylib.CheckCollisionRaySphere( ray: Ray, center: Vector3, radius: float32 ):  boolean <cimport 'CheckCollisionRaySphere', nodecl> end

-- Detect collision between ray and sphere returns collision point 
function Raylib.CheckCollisionRaySphereEx( ray: Ray, center: Vector3, radius: float32, collisionPoint: pointer(Vector3) ):  boolean <cimport 'CheckCollisionRaySphereEx', nodecl> end

-- Detect collision between ray and box 
function Raylib.CheckCollisionRayBox( ray: Ray, box: BoundingBox ):  boolean <cimport 'CheckCollisionRayBox', nodecl> end

-- Get collision info between ray and model 
function Raylib.GetCollisionRayModel( ray: Ray, model: Model ):  RayHitInfo <cimport 'GetCollisionRayModel', nodecl> end

-- Get collision info between ray and triangle 
function Raylib.GetCollisionRayTriangle( ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3 ):  RayHitInfo <cimport 'GetCollisionRayTriangle', nodecl> end

-- Get collision info between ray and ground plane Y normal plane 
function Raylib.GetCollisionRayGround( ray: Ray, groundHeight: float32 ):  RayHitInfo <cimport 'GetCollisionRayGround', nodecl> end

-- Load shader from files and bind default locations 
function Raylib.LoadShader( vsFileName: cstring, fsFileName: cstring ):  Shader <cimport 'LoadShader', nodecl> end

-- Load shader from code strings and bind default locations 
function Raylib.LoadShaderCode( vsCode: cstring, fsCode: cstring ):  Shader <cimport 'LoadShaderCode', nodecl> end

-- Unload shader from GPU memory VRAM 
function Raylib.UnloadShader( shader: Shader ):  void <cimport 'UnloadShader', nodecl> end

-- Get default shader 
function Raylib.GetShaderDefault( ):  Shader <cimport 'GetShaderDefault', nodecl> end

-- Get default texture 
function Raylib.GetTextureDefault( ):  Texture2D <cimport 'GetTextureDefault', nodecl> end

-- Get texture to draw shapes 
function Raylib.GetShapesTexture( ):  Texture2D <cimport 'GetShapesTexture', nodecl> end

-- Get texture rectangle to draw shapes 
function Raylib.GetShapesTextureRec( ):  Rectangle <cimport 'GetShapesTextureRec', nodecl> end

-- Define default texture used to draw shapes 
function Raylib.SetShapesTexture( texture: Texture2D, source: Rectangle ):  void <cimport 'SetShapesTexture', nodecl> end

-- Get shader uniform location 
function Raylib.GetShaderLocation( shader: Shader, uniformName: cstring ):  cint <cimport 'GetShaderLocation', nodecl> end

-- Set shader uniform value 
function Raylib.SetShaderValue( shader: Shader, uniformLoc: cint, value: pointer, uniformType: cint ):  void <cimport 'SetShaderValue', nodecl> end

-- Set shader uniform value vector 
function Raylib.SetShaderValueV( shader: Shader, uniformLoc: cint, value: pointer, uniformType: cint, count: cint ):  void <cimport 'SetShaderValueV', nodecl> end

-- Set shader uniform value matrix 4x4 
function Raylib.SetShaderValueMatrix( shader: Shader, uniformLoc: cint, mat: Matrix ):  void <cimport 'SetShaderValueMatrix', nodecl> end

-- Set shader uniform value for texture 
function Raylib.SetShaderValueTexture( shader: Shader, uniformLoc: cint, texture: Texture2D ):  void <cimport 'SetShaderValueTexture', nodecl> end

-- Set a custom projection matrix replaces internal projection matrix 
function Raylib.SetMatrixProjection( proj: Matrix ):  void <cimport 'SetMatrixProjection', nodecl> end

-- Set a custom modelview matrix replaces internal modelview matrix 
function Raylib.SetMatrixModelview( view: Matrix ):  void <cimport 'SetMatrixModelview', nodecl> end

-- Get internal modelview matrix 
function Raylib.GetMatrixModelview( ):  Matrix <cimport 'GetMatrixModelview', nodecl> end

-- Get internal projection matrix 
function Raylib.GetMatrixProjection( ):  Matrix <cimport 'GetMatrixProjection', nodecl> end

-- Generate cubemap texture from 2D texture 
function Raylib.GenTextureCubemap( shader: Shader, map: Texture2D, size: cint ):  Texture2D <cimport 'GenTextureCubemap', nodecl> end

-- Generate irradiance texture using cubemap data 
function Raylib.GenTextureIrradiance( shader: Shader, cubemap: Texture2D, size: cint ):  Texture2D <cimport 'GenTextureIrradiance', nodecl> end

-- Generate prefilter texture using cubemap data 
function Raylib.GenTexturePrefilter( shader: Shader, cubemap: Texture2D, size: cint ):  Texture2D <cimport 'GenTexturePrefilter', nodecl> end

-- Generate BRDF texture 
function Raylib.GenTextureBRDF( shader: Shader, size: cint ):  Texture2D <cimport 'GenTextureBRDF', nodecl> end

-- Begin custom shader drawing 
function Raylib.BeginShaderMode( shader: Shader ):  void <cimport 'BeginShaderMode', nodecl> end

-- End custom shader drawing use default shader 
function Raylib.EndShaderMode( ):  void <cimport 'EndShaderMode', nodecl> end

-- Begin blending mode alpha additive multiplied 
function Raylib.BeginBlendMode( mode: cint ):  void <cimport 'BeginBlendMode', nodecl> end

-- End blending mode reset to default alpha blending 
function Raylib.EndBlendMode( ):  void <cimport 'EndBlendMode', nodecl> end

-- Init VR simulator for selected device parameters 
function Raylib.InitVrSimulator( ):  void <cimport 'InitVrSimulator', nodecl> end

-- Close VR simulator for current device 
function Raylib.CloseVrSimulator( ):  void <cimport 'CloseVrSimulator', nodecl> end

-- Update VR tracking position and orientation and camera 
function Raylib.UpdateVrTracking( camera: pointer(Camera) ):  void <cimport 'UpdateVrTracking', nodecl> end

-- Set stereo rendering configuration parameters 
function Raylib.SetVrConfiguration( info: VrDeviceInfo, distortion: Shader ):  void <cimport 'SetVrConfiguration', nodecl> end

-- Detect if VR simulator is ready 
function Raylib.IsVrSimulatorReady( ):  boolean <cimport 'IsVrSimulatorReady', nodecl> end

-- Enable/Disable VR experience 
function Raylib.ToggleVrMode( ):  void <cimport 'ToggleVrMode', nodecl> end

-- Begin VR simulator stereo rendering 
function Raylib.BeginVrDrawing( ):  void <cimport 'BeginVrDrawing', nodecl> end

-- End VR simulator stereo rendering 
function Raylib.EndVrDrawing( ):  void <cimport 'EndVrDrawing', nodecl> end

-- Initialize audio device and context 
function Raylib.InitAudioDevice( ):  void <cimport 'InitAudioDevice', nodecl> end

-- Close the audio device and context 
function Raylib.CloseAudioDevice( ):  void <cimport 'CloseAudioDevice', nodecl> end

-- Check if audio device has been initialized successfully 
function Raylib.IsAudioDeviceReady( ):  boolean <cimport 'IsAudioDeviceReady', nodecl> end

-- Set master volume listener 
function Raylib.SetMasterVolume( volume: float32 ):  void <cimport 'SetMasterVolume', nodecl> end

-- Load wave data from file 
function Raylib.LoadWave( fileName: cstring ):  Wave <cimport 'LoadWave', nodecl> end

-- Load sound from file 
function Raylib.LoadSound( fileName: cstring ):  Sound <cimport 'LoadSound', nodecl> end

-- Load sound from wave data 
function Raylib.LoadSoundFromWave( wave: Wave ):  Sound <cimport 'LoadSoundFromWave', nodecl> end

-- Update sound buffer with new data 
function Raylib.UpdateSound( sound: Sound, data: pointer, samplesCount: cint ):  void <cimport 'UpdateSound', nodecl> end

-- Unload wave data 
function Raylib.UnloadWave( wave: Wave ):  void <cimport 'UnloadWave', nodecl> end

-- Unload sound 
function Raylib.UnloadSound( sound: Sound ):  void <cimport 'UnloadSound', nodecl> end

-- Export wave data to file 
function Raylib.ExportWave( wave: Wave, fileName: cstring ):  void <cimport 'ExportWave', nodecl> end

-- Export wave sample data to code h 
function Raylib.ExportWaveAsCode( wave: Wave, fileName: cstring ):  void <cimport 'ExportWaveAsCode', nodecl> end

-- Play a sound 
function Raylib.PlaySound( sound: Sound ):  void <cimport 'PlaySound', nodecl> end

-- Stop playing a sound 
function Raylib.StopSound( sound: Sound ):  void <cimport 'StopSound', nodecl> end

-- Pause a sound 
function Raylib.PauseSound( sound: Sound ):  void <cimport 'PauseSound', nodecl> end

-- Resume a paused sound 
function Raylib.ResumeSound( sound: Sound ):  void <cimport 'ResumeSound', nodecl> end

-- Play a sound using multichannel buffer pool 
function Raylib.PlaySoundMulti( sound: Sound ):  void <cimport 'PlaySoundMulti', nodecl> end

-- Stop any sound playing using multichannel buffer pool 
function Raylib.StopSoundMulti( ):  void <cimport 'StopSoundMulti', nodecl> end

-- Get number of sounds playing in the multichannel 
function Raylib.GetSoundsPlaying( ):  cint <cimport 'GetSoundsPlaying', nodecl> end

-- Check if a sound is currently playing 
function Raylib.IsSoundPlaying( sound: Sound ):  boolean <cimport 'IsSoundPlaying', nodecl> end

-- Set volume for a sound 1 0 is max level 
function Raylib.SetSoundVolume( sound: Sound, volume: float32 ):  void <cimport 'SetSoundVolume', nodecl> end

-- Set pitch for a sound 1 0 is base level 
function Raylib.SetSoundPitch( sound: Sound, pitch: float32 ):  void <cimport 'SetSoundPitch', nodecl> end

-- Convert wave data to desired format 
function Raylib.WaveFormat( wave: pointer(Wave), sampleRate: cint, sampleSize: cint, channels: cint ):  void <cimport 'WaveFormat', nodecl> end

-- Copy a wave to a new wave 
function Raylib.WaveCopy( wave: Wave ):  Wave <cimport 'WaveCopy', nodecl> end

-- Crop a wave to defined samples range 
function Raylib.WaveCrop( wave: pointer(Wave), initSample: cint, finalSample: cint ):  void <cimport 'WaveCrop', nodecl> end

-- Get samples data from wave as a floats array 
function Raylib.GetWaveData( wave: Wave ):  pointer(float32) <cimport 'GetWaveData', nodecl> end

-- Load music stream from file 
function Raylib.LoadMusicStream( fileName: cstring ):  Music <cimport 'LoadMusicStream', nodecl> end

-- Unload music stream 
function Raylib.UnloadMusicStream( music: Music ):  void <cimport 'UnloadMusicStream', nodecl> end

-- Start music playing 
function Raylib.PlayMusicStream( music: Music ):  void <cimport 'PlayMusicStream', nodecl> end

-- Updates buffers for music streaming 
function Raylib.UpdateMusicStream( music: Music ):  void <cimport 'UpdateMusicStream', nodecl> end

-- Stop music playing 
function Raylib.StopMusicStream( music: Music ):  void <cimport 'StopMusicStream', nodecl> end

-- Pause music playing 
function Raylib.PauseMusicStream( music: Music ):  void <cimport 'PauseMusicStream', nodecl> end

-- Resume playing paused music 
function Raylib.ResumeMusicStream( music: Music ):  void <cimport 'ResumeMusicStream', nodecl> end

-- Check if music is playing 
function Raylib.IsMusicPlaying( music: Music ):  boolean <cimport 'IsMusicPlaying', nodecl> end

-- Set volume for music 1 0 is max level 
function Raylib.SetMusicVolume( music: Music, volume: float32 ):  void <cimport 'SetMusicVolume', nodecl> end

-- Set pitch for a music 1 0 is base level 
function Raylib.SetMusicPitch( music: Music, pitch: float32 ):  void <cimport 'SetMusicPitch', nodecl> end

-- Set music loop count loop repeats 
function Raylib.SetMusicLoopCount( music: Music, count: cint ):  void <cimport 'SetMusicLoopCount', nodecl> end

-- Get music time length in seconds 
function Raylib.GetMusicTimeLength( music: Music ):  float32 <cimport 'GetMusicTimeLength', nodecl> end

-- Get current music time played in seconds 
function Raylib.GetMusicTimePlayed( music: Music ):  float32 <cimport 'GetMusicTimePlayed', nodecl> end

-- Init audio stream to stream raw audio pcm data 
function Raylib.InitAudioStream( sampleRate: cint, sampleSize: cint, channels: cint ):  AudioStream <cimport 'InitAudioStream', nodecl> end

-- Update audio stream buffers with data 
function Raylib.UpdateAudioStream( stream: AudioStream, data: pointer, samplesCount: cint ):  void <cimport 'UpdateAudioStream', nodecl> end

-- Close audio stream and free memory 
function Raylib.CloseAudioStream( stream: AudioStream ):  void <cimport 'CloseAudioStream', nodecl> end

-- Check if any audio stream buffers requires refill 
function Raylib.IsAudioStreamProcessed( stream: AudioStream ):  boolean <cimport 'IsAudioStreamProcessed', nodecl> end

-- Play audio stream 
function Raylib.PlayAudioStream( stream: AudioStream ):  void <cimport 'PlayAudioStream', nodecl> end

-- Pause audio stream 
function Raylib.PauseAudioStream( stream: AudioStream ):  void <cimport 'PauseAudioStream', nodecl> end

-- Resume audio stream 
function Raylib.ResumeAudioStream( stream: AudioStream ):  void <cimport 'ResumeAudioStream', nodecl> end

-- Check if audio stream is playing 
function Raylib.IsAudioStreamPlaying( stream: AudioStream ):  boolean <cimport 'IsAudioStreamPlaying', nodecl> end

-- Stop audio stream 
function Raylib.StopAudioStream( stream: AudioStream ):  void <cimport 'StopAudioStream', nodecl> end

-- Set volume for audio stream 1 0 is max level 
function Raylib.SetAudioStreamVolume( stream: AudioStream, volume: float32 ):  void <cimport 'SetAudioStreamVolume', nodecl> end

-- Set pitch for audio stream 1 0 is base level 
function Raylib.SetAudioStreamPitch( stream: AudioStream, pitch: float32 ):  void <cimport 'SetAudioStreamPitch', nodecl> end

-- Default size for new audio streams 
function Raylib.SetAudioStreamBufferSizeDefault( size: cint ):  void <cimport 'SetAudioStreamBufferSizeDefault', nodecl> end

global LIGHTGRAY: Color <cimport, nodecl>
global GRAY: Color <cimport, nodecl>
global DARKGRAY: Color <cimport, nodecl>
global YELLOW: Color <cimport, nodecl>
global GOLD: Color <cimport, nodecl>
global ORANGE: Color <cimport, nodecl>
global PINK: Color <cimport, nodecl>
global RED: Color <cimport, nodecl>
global MAROON: Color <cimport, nodecl>
global GREEN: Color <cimport, nodecl>
global LIME: Color <cimport, nodecl>
global DARKGREEN: Color <cimport, nodecl>
global SKYBLUE: Color <cimport, nodecl>
global BLUE: Color <cimport, nodecl>
global DARKBLUE: Color <cimport, nodecl>
global PURPLE: Color <cimport, nodecl>
global VIOLET: Color <cimport, nodecl>
global DARKPURPLE: Color <cimport, nodecl>
global BEIGE: Color <cimport, nodecl>
global BROWN: Color <cimport, nodecl>
global DARKBROWN: Color <cimport, nodecl>
global WHITE: Color <cimport, nodecl>
global BLACK: Color <cimport, nodecl>
global BLANK: Color <cimport, nodecl>
global MAGENTA: Color <cimport, nodecl>
global RAYWHITE: Color <cimport, nodecl>
 