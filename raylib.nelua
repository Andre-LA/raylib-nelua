--[[ This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. ]]

-- Raylib 2.5 wrapper, based on raylib.h (https://github.com/raysan5/raylib/blob/master/src/raylib.h)

## strict = true
## modname = 'raylib'

## linklib 'raylib'
## linklib 'GL'
## linklib 'glfw'
## linklib 'openal'
## linklib 'm'
## linklib 'pthread'
## linklib 'dl'
## linklib 'X11'
## linklib 'Xrandr'
## linklib 'Xinerama'
## linklib 'Xi'
## linklib 'Xxf86vm'
## linklib 'Xcursor'

## cinclude '<raylib.h>'

global Raylib = @record{}

------------------------------------------------------------------------------------------------------------------------
-- === RECORDS === [
------------------------------------------------------------------------------------------------------------------------

-----------------------------------
-- import structs [              --
-----------------------------------

global Vector2    <cimport, nodecl> = @record{x: float32, y: float32}                                  -- Vector2 type
global Vector3    <cimport, nodecl> = @record{x: float32, y: float32, z: float32}                      -- Vector3 type
global Vector4    <cimport, nodecl> = @record{x: float32, y: float32, z: float32, w: float32}          -- Vector4 type
global Quaternion <cimport, nodecl> = @record{x: float32, y: float32, z: float32, w: float32}          -- Quaternion type
global Matrix     <cimport, nodecl> = @record{                                                         -- Matrix type (OpenGL style 4x4)
   m0: float32, m4: float32, m8 : float32, m12: float32,
   m1: float32, m5: float32, m9 : float32, m13: float32,
   m2: float32, m6: float32, m10: float32, m14: float32,
   m3: float32, m7: float32, m11: float32, m15: float32
}
global Color     <cimport, nodecl> = @record{r: cuchar, g: cuchar, b: cuchar, a: cuchar}              -- Color type, RGBA (32bit)
global Rectangle <cimport, nodecl> = @record{x: float32, y: float32, width: float32, height: float32} -- Rectangle type

-- Image type, bpp always RGBA (32bit)
-- NOTE: Data stored in CPU memory (RAM)
global Image <cimport, nodecl> = @record{
   data: pointer, -- Image raw data
   width:   cint, -- Image base width
   height:  cint, -- Image base height
   mipmaps: cint, -- Mipmap levels, 1 by default
   format:  cint  -- Data format (PixelFormat type)
}

-- Texture2D type
-- NOTE: Data stored in GPU memory
global Texture2D <cimport, nodecl> = @record{
   id:     cuint, -- OpenGL texture id
   width:   cint, -- Texture base width
   height:  cint, -- Texture base height
   mipmaps: cint, -- Mipmap levels, 1 by default
   format:  cint  -- Data format (PixelFormat type)
}

-- Texture type, same as Texture2D
global Texture: type = @Texture2D

-- TextureCubemap type, actually, same as Texture2D
global TextureCubemap: type = @Texture2D

-- RenderTexture2D type, for texture rendering
global RenderTexture2D <cimport, nodecl> = @record{
   id:             cuint, -- OpenGL Framebuffer Object (FBO) id
   texture:    Texture2D, -- Color buffer attachment texture
   depth:      Texture2D, -- Depth buffer attachment texture
   depthTexture: boolean  -- Track if depth attachment is a texture or renderbuffer
}

-- RenderTexture type, same as RenderTexture2D
global RenderTexture: type = @RenderTexture2D

-- N-Patch layout info
global NPatchInfo <cimport, nodecl> = @record{
   sourceRec: Rectangle, -- Region in the texture
   left:           cint, -- left border offset
   top:            cint, -- top border offset
   right:          cint, -- right border offset
   bottom:         cint, -- bottom border offset
   type:           cint  -- layout of the n-patch: 3x3, 1x3 or 3x1
}

-- Font character info
global CharInfo <cimport, nodecl> = @record{
   value:     cint, -- Character value (Unicode)
   offsetX:   cint, -- Character offset X when drawing
   offsetY:   cint, -- Character offset Y when drawing
   advanceX:  cint, -- Character advance position X
   image:    Image, -- Character image data
}

-- Font type, includes texture and charSet array data
global Font <cimport, nodecl> = @record{
   baseSize:         cint, -- Base size (default chars height)
   charsCount:       cint, -- Number of characters
   texture:     Texture2D, -- Characters texture atlas
   recs:       Rectangle*, -- Characters rectangles in texture
   chars:       CharInfo*  -- Characters info data
}

-- Camera type, defines a camera position/orientation in 3d space
global Camera3D <cimport, nodecl> = @record{
   position: Vector3, -- Camera position
   target:   Vector3, -- Camera target it looks-at
   up:       Vector3, -- Camera up vector (rotation over its axis)
   fovy:     float32, -- Camera field-of-view apperture in Y (degrees) in perspective, used as near plane width in orthographic
   type:        cint  -- Camera type, defines projection type: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

global Camera: type = @Camera3D -- Camera type fallback, defaults to Camera3D


-- Camera2D type, defines a 2d camera
global Camera2D <cimport, nodecl> = @record{
   offset:   Vector2, -- Camera offset (displacement from target)
   target:   Vector2, -- Camera target (rotation and zoom origin)
   rotation: float32, -- Camera rotation in degrees
   zoom:     float32  -- Camera zoom (scaling), should be 1.0f by default
}

-- Vertex data definning a mesh
-- NOTE: Data stored in CPU memory (and GPU)
global Mesh <cimport, nodecl> = @record{
   vertexCount:      cint, -- Number of vertices stored in arrays
   triangleCount:    cint, -- Number of triangles stored (indexed or not)

   -- Default vertex data
   vertices:     float32*, -- Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
   texcoords:    float32*, -- Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
   texcoords2:   float32*, -- Vertex second texture coordinates (useful for lightmaps) (shader-location = 5)
   normals:      float32*, -- Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
   tangents:     float32*, -- Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
   colors:        cuchar*, -- Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
   indices:      cushort*, -- Vertex indices (in case vertex data comes indexed)

   -- Animation vertex data
   animVertices: float32*, -- Animated vertex positions (after bones transformations)
   animNormals:  float32*, -- Animated normals (after bones transformations)
   boneIds:         cint*, -- Vertex bone ids, up to 4 bones influence by vertex (skinning)
   boneWeights:  float32*, -- Vertex bone weight, up to 4 bones influence by vertex (skinning)

   -- OpenGL identifiers
   vaoId:           cuint, -- OpenGL Vertex Array Object id
   vboId:          cuint*  -- OpenGL Vertex Buffer Objects id (default vertex data)
}


-- Shader type (generic)
global Shader <cimport, nodecl> = @record{
   id:   cuint, -- Shader program id
   locs: cint*  -- Shader locations array (MAX_SHADER_LOCATIONS)
}

-- Material texture map
global MaterialMap <cimport, nodecl> = @record{
   texture: Texture2D, -- Material map texture
   color:       Color, -- Material map color
   value:     float32  -- Material map value
}

-- Material type (generic)
global Material <cimport, nodecl> = @record{
   shader:       Shader, -- Material shader
   maps:   MaterialMap*, -- Material maps array (MAX_MATERIAL_MAPS)
   params:     float32*  -- Material generic parameters (if required)
}

-- Transformation properties
global Transform <cimport, nodecl> = @record{
   translation:    Vector3, -- Translation
   rotation:    Quaternion, -- Rotation
   scale:          Vector3  -- Scale
}

-- Bone information
global BoneInfo <cimport, nodecl> = @record{
   name:   cchar[32], -- Bone name
   parent:      cint  -- Bone parent
}

-- Model type
global Model <cimport, nodecl> = @record{
   transform:        Matrix, -- Local transform matrix

   meshCount:          cint, -- Number of meshes
   meshes:            Mesh*, -- Meshes array

   materialCount:      cint, -- Number of materials
   materials:     Material*, -- Materials array
   meshMaterial:      cint*, -- Mesh material number

   -- Animation data
   boneCount:          cint, -- Number of bones
   bones:         BoneInfo*, -- Bones information (skeleton)
   bindPose:     Transform*  -- Bones base transformation (pose)
}

-- Model animation
global ModelAnimation <cimport, nodecl> = @record{
   boneCount:         cint, -- Number of bones
   bones:        BoneInfo*, -- Bones information (skeleton)

   frameCount:        cint, -- Number of animation frames
   framePoses: Transform**  -- Poses array by frame
}

-- Ray type (useful for raycast)
global Ray <cimport, nodecl> = @record{
   position:  Vector3, -- Ray position (origin)
   direction: Vector3  -- Ray direction
}

-- Raycast hit information
global RayHitInfo <cimport, nodecl> = @record{
   hit:      boolean, -- Did the ray hit something?
   distance: float32, -- Distance to nearest hit
   position: Vector3, -- Position of nearest hit
   normal:   Vector3  -- Surface normal of hit
}

-- Bounding box type
global BoundingBox <cimport, nodecl> = @record{
   min: Vector3, -- Minimum vertex box-corner
   max: Vector3  -- Maximum vertex box-corner
}

-- Wave type, defines audio wave data
global Wave <cimport, nodecl> = @record{
   sampleCount:   cuint, -- Total number of samples
   sampleRate:    cuint, -- Frequency (samples per second)
   sampleSize:    cuint, -- Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels:      cuint, -- Number of channels (1-mono, 2-stereo)
   data:        pointer  -- Buffer data pointer
}

global rAudioBuffer <cimport, nodecl> = @record{}

-- Audio stream type
-- NOTE: Useful to create custom audio streams not bound to a specific file
global AudioStream <cimport, nodecl> = @record{
   sampleRate:         cuint, -- Frequency (samples per second)
   sampleSize:         cuint, -- Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels:           cuint, -- Number of channels (1-mono, 2-stereo)

   buffer:     rAudioBuffer*  -- Pointer to internal data used by the audio system
}

-- Sound source type
global Sound <cimport, nodecl> = @record{
   sampleCount:       cuint, -- Total number of samples
   stream:      AudioStream  -- Audio stream
}

-- Music stream type (audio file streaming from memory)
-- NOTE: Anything longer than ~10 seconds should be streamed
global Music <cimport, nodecl> = @record{
   ctxType:            cint, -- Type of music context (audio filetype)
   ctxData:         pointer, -- Audio context data, depends on type

   sampleCount:       cuint, -- Total number of samples
   loopCount:         cuint, -- Loops count (times music will play), 0 means infinite loop

   stream:      AudioStream  -- Audio stream
}

-- Head-Mounted-Display device parameters
global VrDeviceInfo <cimport, nodecl> = @record{
   hResolution:                  cint, -- HMD horizontal resolution in pixels
   vResolution:                  cint, -- HMD vertical resolution in pixels
   hScreenSize:               float32, -- HMD horizontal size in meters
   vScreenSize:               float32, -- HMD vertical size in meters
   vScreenCenter:             float32, -- HMD screen center in meters
   eyeToScreenDistance:       float32, -- HMD distance between eye and display in meters
   lensSeparationDistance:    float32, -- HMD lens separation distance in meters
   interpupillaryDistance:    float32, -- HMD IPD (distance between pupils) in meters
   lensDistortionValues:   float32[4], -- HMD lens distortion constant parameters
   chromaAbCorrection:     float32[4]  -- HMD chromatic aberration correction parameters
}

-----------------------------------
-- import structs ]              --
-----------------------------------


-----------------------------------
-- import enums [                --
-----------------------------------

------------------------------------------------------------------------------------
-- Enumerators Definition
------------------------------------------------------------------------------------
-- System config flags
-- NOTE: Used for bit masks
global ConfigFlag <cimport, nodecl> = @enum {
   FLAG_RESERVED           = 1,    -- Reserved
   FLAG_FULLSCREEN_MODE    = 2,    -- Set to run program in fullscreen
   FLAG_WINDOW_RESIZABLE   = 4,    -- Set to allow resizable window
   FLAG_WINDOW_UNDECORATED = 8,    -- Set to disable window decoration (frame and buttons)
   FLAG_WINDOW_TRANSPARENT = 16,   -- Set to allow transparent window
   FLAG_WINDOW_HIDDEN      = 128,  -- Set to create the window initially hidden
   FLAG_WINDOW_ALWAYS_RUN  = 256,  -- Set to allow windows running while minimized
   FLAG_MSAA_4X_HINT       = 32,   -- Set to try enabling MSAA 4X
   FLAG_VSYNC_HINT         = 64    -- Set to try enabling V-Sync on GPU
}

-- Trace log type
global TraceLogType <cimport, nodecl> = @enum {
   LOG_ALL = 0,        -- Display all logs
   LOG_TRACE,
   LOG_DEBUG,
   LOG_INFO,
   LOG_WARNING,
   LOG_ERROR,
   LOG_FATAL,
   LOG_NONE            -- Disable logging
}

-- Keyboard keys
global KeyboardKey <cimport, nodecl> = @enum {
   -- Alphanumeric keys
   KEY_APOSTROPHE      = 39,
   KEY_COMMA           = 44,
   KEY_MINUS           = 45,
   KEY_PERIOD          = 46,
   KEY_SLASH           = 47,
   KEY_ZERO            = 48,
   KEY_ONE             = 49,
   KEY_TWO             = 50,
   KEY_THREE           = 51,
   KEY_FOUR            = 52,
   KEY_FIVE            = 53,
   KEY_SIX             = 54,
   KEY_SEVEN           = 55,
   KEY_EIGHT           = 56,
   KEY_NINE            = 57,
   KEY_SEMICOLON       = 59,
   KEY_EQUAL           = 61,
   KEY_A               = 65,
   KEY_B               = 66,
   KEY_C               = 67,
   KEY_D               = 68,
   KEY_E               = 69,
   KEY_F               = 70,
   KEY_G               = 71,
   KEY_H               = 72,
   KEY_I               = 73,
   KEY_J               = 74,
   KEY_K               = 75,
   KEY_L               = 76,
   KEY_M               = 77,
   KEY_N               = 78,
   KEY_O               = 79,
   KEY_P               = 80,
   KEY_Q               = 81,
   KEY_R               = 82,
   KEY_S               = 83,
   KEY_T               = 84,
   KEY_U               = 85,
   KEY_V               = 86,
   KEY_W               = 87,
   KEY_X               = 88,
   KEY_Y               = 89,
   KEY_Z               = 90,

   -- Function keys
   KEY_SPACE           = 32,
   KEY_ESCAPE          = 256,
   KEY_ENTER           = 257,
   KEY_TAB             = 258,
   KEY_BACKSPACE       = 259,
   KEY_INSERT          = 260,
   KEY_DELETE          = 261,
   KEY_RIGHT           = 262,
   KEY_LEFT            = 263,
   KEY_DOWN            = 264,
   KEY_UP              = 265,
   KEY_PAGE_UP         = 266,
   KEY_PAGE_DOWN       = 267,
   KEY_HOME            = 268,
   KEY_END             = 269,
   KEY_CAPS_LOCK       = 280,
   KEY_SCROLL_LOCK     = 281,
   KEY_NUM_LOCK        = 282,
   KEY_PRINT_SCREEN    = 283,
   KEY_PAUSE           = 284,
   KEY_F1              = 290,
   KEY_F2              = 291,
   KEY_F3              = 292,
   KEY_F4              = 293,
   KEY_F5              = 294,
   KEY_F6              = 295,
   KEY_F7              = 296,
   KEY_F8              = 297,
   KEY_F9              = 298,
   KEY_F10             = 299,
   KEY_F11             = 300,
   KEY_F12             = 301,
   KEY_LEFT_SHIFT      = 340,
   KEY_LEFT_CONTROL    = 341,
   KEY_LEFT_ALT        = 342,
   KEY_LEFT_SUPER      = 343,
   KEY_RIGHT_SHIFT     = 344,
   KEY_RIGHT_CONTROL   = 345,
   KEY_RIGHT_ALT       = 346,
   KEY_RIGHT_SUPER     = 347,
   KEY_KB_MENU         = 348,
   KEY_LEFT_BRACKET    = 91,
   KEY_BACKSLASH       = 92,
   KEY_RIGHT_BRACKET   = 93,
   KEY_GRAVE           = 96,

   -- Keypad keys
   KEY_KP_0            = 320,
   KEY_KP_1            = 321,
   KEY_KP_2            = 322,
   KEY_KP_3            = 323,
   KEY_KP_4            = 324,
   KEY_KP_5            = 325,
   KEY_KP_6            = 326,
   KEY_KP_7            = 327,
   KEY_KP_8            = 328,
   KEY_KP_9            = 329,
   KEY_KP_DECIMAL      = 330,
   KEY_KP_DIVIDE       = 331,
   KEY_KP_MULTIPLY     = 332,
   KEY_KP_SUBTRACT     = 333,
   KEY_KP_ADD          = 334,
   KEY_KP_ENTER        = 335,
   KEY_KP_EQUAL        = 336
}

-- Android buttons
global AndroidButton <cimport, nodecl> = @enum {
   KEY_BACK            = 4,
   KEY_MENU            = 82,
   KEY_VOLUME_UP       = 24,
   KEY_VOLUME_DOWN     = 25
}

-- Mouse buttons
global MouseButton <cimport, nodecl> = @enum {
   MOUSE_LEFT_BUTTON   = 0,
   MOUSE_RIGHT_BUTTON  = 1,
   MOUSE_MIDDLE_BUTTON = 2
}

-- Gamepad number
global GamepadNumber <cimport, nodecl> = @enum {
   GAMEPAD_PLAYER1     = 0,
   GAMEPAD_PLAYER2     = 1,
   GAMEPAD_PLAYER3     = 2,
   GAMEPAD_PLAYER4     = 3
}

-- Gamepad Buttons
global GamepadButton <cimport, nodecl> = @enum {
   -- This is here just for error checking
   GAMEPAD_BUTTON_UNKNOWN = 0,

   -- This is normally a DPAD
   GAMEPAD_BUTTON_LEFT_FACE_UP,
   GAMEPAD_BUTTON_LEFT_FACE_RIGHT,
   GAMEPAD_BUTTON_LEFT_FACE_DOWN,
   GAMEPAD_BUTTON_LEFT_FACE_LEFT,

   -- This normally corresponds with PlayStation and Xbox controllers
   -- XBOX: [Y,X,A,B]
   -- PS3: [Triangle,Square,Cross,Circle]
   -- No support for 6 button controllers though..
   GAMEPAD_BUTTON_RIGHT_FACE_UP,
   GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,
   GAMEPAD_BUTTON_RIGHT_FACE_DOWN,
   GAMEPAD_BUTTON_RIGHT_FACE_LEFT,

   -- Triggers
   GAMEPAD_BUTTON_LEFT_TRIGGER_1,
   GAMEPAD_BUTTON_LEFT_TRIGGER_2,
   GAMEPAD_BUTTON_RIGHT_TRIGGER_1,
   GAMEPAD_BUTTON_RIGHT_TRIGGER_2,

   -- These are buttons in the center of the gamepad
   GAMEPAD_BUTTON_MIDDLE_LEFT,     --PS3 Select
   GAMEPAD_BUTTON_MIDDLE,          --PS Button/XBOX Button
   GAMEPAD_BUTTON_MIDDLE_RIGHT,    --PS3 Start

   -- These are the joystick press in buttons
   GAMEPAD_BUTTON_LEFT_THUMB,
   GAMEPAD_BUTTON_RIGHT_THUMB
}

global GamepadAxis <cimport, nodecl> = @enum {
   -- This is here just for error checking
   GAMEPAD_AXIS_UNKNOWN = 0,

   -- Left stick
   GAMEPAD_AXIS_LEFT_X,
   GAMEPAD_AXIS_LEFT_Y,

   -- Right stick
   GAMEPAD_AXIS_RIGHT_X,
   GAMEPAD_AXIS_RIGHT_Y,

   -- Pressure levels for the back triggers
   GAMEPAD_AXIS_LEFT_TRIGGER,      -- [1..-1] (pressure-level)
   GAMEPAD_AXIS_RIGHT_TRIGGER      -- [1..-1] (pressure-level)
}

-- Shader location point type
global ShaderLocationIndex <cimport, nodecl> = @enum {
   LOC_VERTEX_POSITION = 0,
   LOC_VERTEX_TEXCOORD01,
   LOC_VERTEX_TEXCOORD02,
   LOC_VERTEX_NORMAL,
   LOC_VERTEX_TANGENT,
   LOC_VERTEX_COLOR,
   LOC_MATRIX_MVP,
   LOC_MATRIX_MODEL,
   LOC_MATRIX_VIEW,
   LOC_MATRIX_PROJECTION,
   LOC_VECTOR_VIEW,
   LOC_COLOR_DIFFUSE,
   LOC_COLOR_SPECULAR,
   LOC_COLOR_AMBIENT,
   LOC_MAP_ALBEDO,          -- LOC_MAP_DIFFUSE
   LOC_MAP_METALNESS,       -- LOC_MAP_SPECULAR
   LOC_MAP_NORMAL,
   LOC_MAP_ROUGHNESS,
   LOC_MAP_OCCLUSION,
   LOC_MAP_EMISSION,
   LOC_MAP_HEIGHT,
   LOC_MAP_CUBEMAP,
   LOC_MAP_IRRADIANCE,
   LOC_MAP_PREFILTER,
   LOC_MAP_BRDF
}

-- TODO: define these
-- #define LOC_MAP_DIFFUSE      LOC_MAP_ALBEDO
-- #define LOC_MAP_SPECULAR     LOC_MAP_METALNESS

-- Shader uniform data types
global ShaderUniformDataType <cimport, nodecl> = @enum {
   UNIFORM_FLOAT = 0,
   UNIFORM_VEC2,
   UNIFORM_VEC3,
   UNIFORM_VEC4,
   UNIFORM_INT,
   UNIFORM_IVEC2,
   UNIFORM_IVEC3,
   UNIFORM_IVEC4,
   UNIFORM_SAMPLER2D
}

-- Material map type
global MaterialMapType <cimport, nodecl> = @enum {
   MAP_ALBEDO    = 0,       -- MAP_DIFFUSE
   MAP_METALNESS = 1,       -- MAP_SPECULAR
   MAP_NORMAL    = 2,
   MAP_ROUGHNESS = 3,
   MAP_OCCLUSION,
   MAP_EMISSION,
   MAP_HEIGHT,
   MAP_CUBEMAP,             -- NOTE: Uses GL_TEXTURE_CUBE_MAP
   MAP_IRRADIANCE,          -- NOTE: Uses GL_TEXTURE_CUBE_MAP
   MAP_PREFILTER,           -- NOTE: Uses GL_TEXTURE_CUBE_MAP
   MAP_BRDF
}

-- TODO: define these
-- #define MAP_DIFFUSE      MAP_ALBEDO
-- #define MAP_SPECULAR     MAP_METALNESS

-- Pixel formats
-- NOTE: Support depends on OpenGL version and platform
global PixelFormat <cimport, nodecl> = @enum {
   UNCOMPRESSED_GRAYSCALE = 1,     -- 8 bit per pixel (no alpha)
   UNCOMPRESSED_GRAY_ALPHA,        -- 8*2 bpp (2 channels)
   UNCOMPRESSED_R5G6B5,            -- 16 bpp
   UNCOMPRESSED_R8G8B8,            -- 24 bpp
   UNCOMPRESSED_R5G5B5A1,          -- 16 bpp (1 bit alpha)
   UNCOMPRESSED_R4G4B4A4,          -- 16 bpp (4 bit alpha)
   UNCOMPRESSED_R8G8B8A8,          -- 32 bpp
   UNCOMPRESSED_R32,               -- 32 bpp (1 channel - float)
   UNCOMPRESSED_R32G32B32,         -- 32*3 bpp (3 channels - float)
   UNCOMPRESSED_R32G32B32A32,      -- 32*4 bpp (4 channels - float)
   COMPRESSED_DXT1_RGB,            -- 4 bpp (no alpha)
   COMPRESSED_DXT1_RGBA,           -- 4 bpp (1 bit alpha)
   COMPRESSED_DXT3_RGBA,           -- 8 bpp
   COMPRESSED_DXT5_RGBA,           -- 8 bpp
   COMPRESSED_ETC1_RGB,            -- 4 bpp
   COMPRESSED_ETC2_RGB,            -- 4 bpp
   COMPRESSED_ETC2_EAC_RGBA,       -- 8 bpp
   COMPRESSED_PVRT_RGB,            -- 4 bpp
   COMPRESSED_PVRT_RGBA,           -- 4 bpp
   COMPRESSED_ASTC_4x4_RGBA,       -- 8 bpp
   COMPRESSED_ASTC_8x8_RGBA        -- 2 bpp
}

-- Texture parameters: filter mode
-- NOTE 1: Filtering considers mipmaps if available in the texture
-- NOTE 2: Filter is accordingly set for minification and magnification
global TextureFilterMode <cimport, nodecl> = @enum {
   FILTER_POINT = 0,               -- No filter, just pixel aproximation
   FILTER_BILINEAR,                -- Linear filtering
   FILTER_TRILINEAR,               -- Trilinear filtering (linear with mipmaps)
   FILTER_ANISOTROPIC_4X,          -- Anisotropic filtering 4x
   FILTER_ANISOTROPIC_8X,          -- Anisotropic filtering 8x
   FILTER_ANISOTROPIC_16X,         -- Anisotropic filtering 16x
}

-- Cubemap layout type
global CubemapLayoutType <cimport, nodecl> = @enum {
   CUBEMAP_AUTO_DETECT = 0,        -- Automatically detect layout type
   CUBEMAP_LINE_VERTICAL,          -- Layout is defined by a vertical line with faces
   CUBEMAP_LINE_HORIZONTAL,        -- Layout is defined by an horizontal line with faces
   CUBEMAP_CROSS_THREE_BY_FOUR,    -- Layout is defined by a 3x4 cross with cubemap faces
   CUBEMAP_CROSS_FOUR_BY_THREE,    -- Layout is defined by a 4x3 cross with cubemap faces
   CUBEMAP_PANORAMA                -- Layout is defined by a panorama image (equirectangular map)
}

-- Texture parameters: wrap mode
global TextureWrapMode <cimport, nodecl> = @enum {
   WRAP_REPEAT = 0,        -- Repeats texture in tiled mode
   WRAP_CLAMP,             -- Clamps texture to edge pixel in tiled mode
   WRAP_MIRROR_REPEAT,     -- Mirrors and repeats the texture in tiled mode
   WRAP_MIRROR_CLAMP       -- Mirrors and clamps to border the texture in tiled mode
}

-- Font type, defines generation method
global FontType <cimport, nodecl> = @enum {
   FONT_DEFAULT = 0,       -- Default font generation, anti-aliased
   FONT_BITMAP,            -- Bitmap font generation, no anti-aliasing
   FONT_SDF                -- SDF font generation, requires external shader
}

-- Color blending modes (pre-defined)
global BlendMode <cimport, nodecl> = @enum {
   BLEND_ALPHA = 0,        -- Blend textures considering alpha (default)
   BLEND_ADDITIVE,         -- Blend textures adding colors
   BLEND_MULTIPLIED        -- Blend textures multiplying colors
}

-- Gestures type
-- NOTE: It could be used as flags to enable only some gestures
global GestureType <cimport, nodecl> = @enum {
   GESTURE_NONE        = 0,
   GESTURE_TAP         = 1,
   GESTURE_DOUBLETAP   = 2,
   GESTURE_HOLD        = 4,
   GESTURE_DRAG        = 8,
   GESTURE_SWIPE_RIGHT = 16,
   GESTURE_SWIPE_LEFT  = 32,
   GESTURE_SWIPE_UP    = 64,
   GESTURE_SWIPE_DOWN  = 128,
   GESTURE_PINCH_IN    = 256,
   GESTURE_PINCH_OUT   = 512
}

-- Camera system modes
global CameraMode <cimport, nodecl> = @enum {
   CAMERA_CUSTOM = 0,
   CAMERA_FREE,
   CAMERA_ORBITAL,
   CAMERA_FIRST_PERSON,
   CAMERA_THIRD_PERSON
}

-- Camera projection modes
global CameraType <cimport, nodecl> = @enum {
   CAMERA_PERSPECTIVE = 0,
   CAMERA_ORTHOGRAPHIC
}

-- Type of n-patch
global NPatchType <cimport, nodecl> = @enum {
   NPT_9PATCH = 0,         -- Npatch defined by 3x3 tiles
   NPT_3PATCH_VERTICAL,    -- Npatch defined by 1x3 tiles
   NPT_3PATCH_HORIZONTAL   -- Npatch defined by 3x1 tiles
}

-----------------------------------
-- import enums ]                --
-----------------------------------

-- This is a callback, is used as parameter by "SetTraceLogCallback" (in core module)
-- since is used as parameter type, I decided to declare it as record
global TraceLogCallback <cimport, nodecl> = @record{}

-- import colors --[
local LIGHTGRAY:  Color <cimport, nodecl>; local GRAY:       Color <cimport, nodecl>
local DARKGRAY:   Color <cimport, nodecl>; local YELLOW:     Color <cimport, nodecl>
local GOLD:       Color <cimport, nodecl>; local ORANGE:     Color <cimport, nodecl>
local PINK:       Color <cimport, nodecl>; local RED:        Color <cimport, nodecl>
local MAROON:     Color <cimport, nodecl>; local GREEN:      Color <cimport, nodecl>
local LIME:       Color <cimport, nodecl>; local DARKGREEN:  Color <cimport, nodecl>
local SKYBLUE:    Color <cimport, nodecl>; local BLUE:       Color <cimport, nodecl>
local DARKBLUE:   Color <cimport, nodecl>; local PURPLE:     Color <cimport, nodecl>
local VIOLET:     Color <cimport, nodecl>; local DARKPURPLE: Color <cimport, nodecl>
local BEIGE:      Color <cimport, nodecl>; local BROWN:      Color <cimport, nodecl>
local DARKBROWN:  Color <cimport, nodecl>; local WHITE:      Color <cimport, nodecl>
local BLACK:      Color <cimport, nodecl>; local BLANK:      Color <cimport, nodecl>
local MAGENTA:    Color <cimport, nodecl>; local RAYWHITE:   Color <cimport, nodecl>

global RaylibColors: record {
   Lightgray: Color, Gray:     Color, Darkgray:  Color, Yellow: Color, Gold:   Color, Orange:     Color,
   Pink:      Color, Red:      Color, Maroon:    Color, Green:  Color, Lime:   Color, Darkgreen:  Color,
   Skyblue:   Color, Blue:     Color, Darkblue:  Color, Purple: Color, Violet: Color, Darkpurple: Color,
   Beige:     Color, Brown:    Color, Darkbrown: Color, White:  Color, Black:  Color, Blank:      Color,
   Magenta:   Color, Raywhite: Color
} = {
   LIGHTGRAY       , GRAY           , DARKGRAY        , YELLOW       , GOLD         , ORANGE           ,
   PINK            , RED            , MAROON          , GREEN        , LIME         , DARKGREEN        ,
   SKYBLUE         , BLUE           , DARKBLUE        , PURPLE       , VIOLET       , DARKPURPLE       ,
   BEIGE           , BROWN          , DARKBROWN       , WHITE        , BLACK        , BLANK            ,
   MAGENTA         , RAYWHITE
}
-- ]


------------------------------------------------------------------------------------------------------------------------
-- === RECORDS === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === CORE MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Window-related functions
local function InitWindow(width: cint, height: cint, title: cstring)              <cimport, nodecl> end -- Initialize window and OpenGL context
local function WindowShouldClose(): boolean                                       <cimport, nodecl> end -- Check if KEY_ESCAPE pressed or Close icon pressed
local function CloseWindow()                                                      <cimport, nodecl> end -- Close window and unload OpenGL context
local function IsWindowReady(): boolean                                           <cimport, nodecl> end -- Check if window has been initialized successfully
local function IsWindowMinimized(): boolean                                       <cimport, nodecl> end -- Check if window has been minimized (or lost focus)
local function IsWindowResized(): boolean                                         <cimport, nodecl> end -- Check if window has been resized
local function IsWindowHidden(): boolean                                          <cimport, nodecl> end -- Check if window is currently hidden
local function ToggleFullscreen()                                                 <cimport, nodecl> end -- Toggle fullscreen mode (only PLATFORM_DESKTOP)
local function UnhideWindow()                                                     <cimport, nodecl> end -- Show the window
local function HideWindow()                                                       <cimport, nodecl> end -- Hide the window
local function SetWindowIcon(image: Image)                                        <cimport, nodecl> end -- Set icon for window (only PLATFORM_DESKTOP)
local function SetWindowTitle(title: cstring)                                     <cimport, nodecl> end -- Set title for window (only PLATFORM_DESKTOP)
local function SetWindowPosition(x: cint, y: cint)                                <cimport, nodecl> end -- Set window position on screen (only PLATFORM_DESKTOP)
local function SetWindowMonitor(monitor: cint)                                    <cimport, nodecl> end -- Set monitor for the current window (fullscreen mode)
local function SetWindowMinSize(width: cint, height: cint)                        <cimport, nodecl> end -- Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
local function SetWindowSize(width: cint, height: cint)                           <cimport, nodecl> end -- Set window dimensions
local function GetWindowHandle(): pointer                                         <cimport, nodecl> end -- Get native window handle
local function GetScreenWidth(): cint                                             <cimport, nodecl> end -- Get current screen width
local function GetScreenHeight(): cint                                            <cimport, nodecl> end -- Get current screen height
local function GetMonitorCount(): cint                                            <cimport, nodecl> end -- Get number of connected monitors
local function GetMonitorWidth(monitor: cint): cint                               <cimport, nodecl> end -- Get primary monitor width
local function GetMonitorHeight(monitor: cint): cint                              <cimport, nodecl> end -- Get primary monitor height
local function GetMonitorPhysicalWidth(monitor: cint): cint                       <cimport, nodecl> end -- Get primary monitor physical width in millimetres
local function GetMonitorPhysicalHeight(monitor: cint): cint                      <cimport, nodecl> end -- Get primary monitor physical height in millimetres
local function GetMonitorName(monitor: cint): cstring                             <cimport, nodecl> end -- Get the human-readable, UTF-8 encoded name of the primary monitor
local function GetClipboardText(): cstring                                        <cimport, nodecl> end -- Get clipboard text content
local function SetClipboardText(text: cstring)                                    <cimport, nodecl> end -- Set clipboard text content

-- Cursor-related functions
local function ShowCursor()              <cimport, nodecl> end -- Shows cursor
local function HideCursor()              <cimport, nodecl> end -- Hides cursor
local function IsCursorHidden(): boolean <cimport, nodecl> end -- Check if cursor is not visible
local function EnableCursor()            <cimport, nodecl> end -- Enables cursor (unlock cursor)
local function DisableCursor()           <cimport, nodecl> end -- Disables cursor (lock cursor)

-- Drawing-related functions
local function ClearBackground(color: Color)             <cimport, nodecl> end -- Set background color (framebuffer clear color)
local function BeginDrawing()                            <cimport, nodecl> end -- Setup canvas (framebuffer) to start drawing
local function EndDrawing()                              <cimport, nodecl> end -- End canvas drawing and swap buffers (double buffering)
local function BeginMode2D(camera: Camera2D)             <cimport, nodecl> end -- Initialize 2D mode with custom camera (2D)
local function EndMode2D()                               <cimport, nodecl> end -- Ends 2D mode with custom camera
local function BeginMode3D(camera: Camera3D)             <cimport, nodecl> end -- Initializes 3D mode with custom camera (3D)
local function EndMode3D()                               <cimport, nodecl> end -- Ends 3D mode and returns to default 2D orthographic mode
local function BeginTextureMode(target: RenderTexture2D) <cimport, nodecl> end -- Initializes render texture for drawing
local function EndTextureMode()                          <cimport, nodecl> end -- Ends drawing to render texture

-- Screen-space-related functions
local function GetMouseRay(mousePosition: Vector2, camera: Camera): Ray     <cimport, nodecl> end -- Returns a ray trace from mouse position
local function GetWorldToScreen(position: Vector3, camera: Camera): Vector2 <cimport, nodecl> end -- Returns the screen space position for a 3d world space position
local function GetCameraMatrix(camera: Camera): Matrix                      <cimport, nodecl> end -- Returns camera transform matrix (view matrix)

-- Timing-related functions
local function SetTargetFPS(fps: cint) <cimport, nodecl> end -- Set target FPS (maximum)
local function GetFPS(): cint          <cimport, nodecl> end -- Returns current FPS
local function GetFrameTime(): float32 <cimport, nodecl> end -- Returns time in seconds for last frame drawn
local function GetTime(): float64      <cimport, nodecl> end -- Returns elapsed time in seconds since InitWindow()

-- Color-related functions
local function ColorToInt(color: Color): cint            <cimport, nodecl> end -- Returns hexadecimal value for a Color
local function ColorNormalize(color: Color): Vector4     <cimport, nodecl> end -- Returns color normalized as float [0..1]
local function ColorToHSV(color: Color): Vector3         <cimport, nodecl> end -- Returns HSV values for a Color
local function ColorFromHSV(hsv: Vector3): Color         <cimport, nodecl> end -- Returns a Color from HSV values
local function GetColor(hexValue: cint): Color           <cimport, nodecl> end -- Returns a Color struct from hexadecimal value
local function Fade(color: Color, alpha: float32): Color <cimport, nodecl> end -- Color fade-in or fade-out, alpha goes from 0.0f to 1.0f

-- Misc. functions
local function SetConfigFlags(flags: cuchar)                       <cimport, nodecl> end -- Setup window configuration flags (view FLAGS)
local function SetTraceLogLevel(logType: cint)                     <cimport, nodecl> end -- Set the current threshold (minimum) log level
local function SetTraceLogExit(logType: cint)                      <cimport, nodecl> end -- Set the exit threshold (minimum) log level
local function SetTraceLogCallback(callback: TraceLogCallback)    <cimport, nodecl> end -- Set a trace log callback to enable custom logging
global function TraceLog(logType: cint, text: cstring, ...)         <cimport, nodecl> end -- Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR)
local function TakeScreenshot(fileName: cstring)                   <cimport, nodecl> end -- Takes a screenshot of current screen (saved a .png)
local function GetRandomValue(min: cint, max: cint): cint          <cimport, nodecl> end -- Returns a random value between min and max (both included)

-- Files management functions
local function FileExists(fileName: cstring): boolean                                              <cimport, nodecl> end -- Check if file exists
local function IsFileExtension(fileName: cstring, ext: cstring): boolean                           <cimport, nodecl> end -- Check file extension
local function GetExtension(fileName: cstring): cstring                                            <cimport, nodecl> end -- Get pointer to extension for a filename string
local function GetFileName(filePath: cstring): cstring                                             <cimport, nodecl> end -- Get pointer to filename for a path string
local function GetFileNameWithoutExt(filePath: cstring): cstring                                   <cimport, nodecl> end -- Get filename string without extension (memory should be freed)
local function GetDirectoryPath(fileName: cstring): cstring                                        <cimport, nodecl> end -- Get full path for a given fileName (uses static string)
local function GetWorkingDirectory(): cstring                                                      <cimport, nodecl> end -- Get current working directory (uses static string)
local function GetDirectoryFiles(dirPath: cstring, count: cint*): cstring[0]*                      <cimport, nodecl> end -- Get filenames in a directory path (memory should be freed)
local function ClearDirectoryFiles()                                                               <cimport, nodecl> end -- Clear directory files paths buffers (free memory)
local function ChangeDirectory(dir: cstring): boolean                                              <cimport, nodecl> end -- Change working directory, returns true if success
local function IsFileDropped(): boolean                                                            <cimport, nodecl> end -- Check if a file has been dropped into window
local function GetDroppedFiles(count: cint*): cstring[0]*                                          <cimport, nodecl> end -- Get dropped files names (memory should be freed)
local function ClearDroppedFiles()                                                                 <cimport, nodecl> end -- Clear dropped files paths buffer (free memory)
local function GetFileModTime(fileName: cstring): clong                                            <cimport, nodecl> end -- Get file modification time (last write time)

-- Persistent storage management
local function StorageSaveValue(position: cint, value: cint)                                       <cimport, nodecl> end -- Save integer value to storage file (to defined position)
local function StorageLoadValue(position: cint): cint                                              <cimport, nodecl> end -- Load integer value from storage file (from defined position)

local function OpenURL(url: cstring)                                                               <cimport, nodecl> end -- Open URL with default system browser (if available)

--------------------------------------------------------------------------------------
-- Input Handling Functions
--------------------------------------------------------------------------------------

-- Input-related functions: keyb
local function IsKeyPressed(key: cint): boolean  <cimport, nodecl> end -- Detect if a key has been pressed once
local function IsKeyDown(key: cint): boolean     <cimport, nodecl> end -- Detect if a key is being pressed
local function IsKeyReleased(key: cint): boolean <cimport, nodecl> end -- Detect if a key has been released once
local function IsKeyUp(key: cint): boolean       <cimport, nodecl> end -- Detect if a key is NOT being pressed
local function GetKeyPressed(): cint             <cimport, nodecl> end -- Get latest key pressed
local function SetExitKey(key: cint)             <cimport, nodecl> end -- Set a custom key to exit program (default is ESC)

-- Input-related functions: gamepads
local function IsGamepadAvailable(gamepad: cint): boolean                    <cimport, nodecl> end -- Detect if a gamepad is available
local function IsGamepadName(gamepad: cint, name: cstring): boolean          <cimport, nodecl> end -- Check gamepad name (if available)
local function GetGamepadName(gamepad: cint): cstring                        <cimport, nodecl> end -- Return gamepad internal name id
local function IsGamepadButtonPressed(gamepad: cint, button: cint): boolean  <cimport, nodecl> end -- Detect if a gamepad button has been pressed once
local function IsGamepadButtonDown(gamepad: cint, button: cint): boolean     <cimport, nodecl> end -- Detect if a gamepad button is being pressed
local function IsGamepadButtonReleased(gamepad: cint, button: cint): boolean <cimport, nodecl> end -- Detect if a gamepad button has been released once
local function IsGamepadButtonUp(gamepad: cint, button: cint): boolean       <cimport, nodecl> end -- Detect if a gamepad button is NOT being pressed
local function GetGamepadButtonPressed(): cint                               <cimport, nodecl> end -- Get the last gamepad button pressed
local function GetGamepadAxisCount(gamepad: cint): cint                      <cimport, nodecl> end -- Return gamepad axis count for a gamepad
local function GetGamepadAxisMovement(gamepad: cint, axis: cint): float32    <cimport, nodecl> end -- Return axis movement value for a gamepad axis

-- Input-related functions: mouse
local function IsMouseButtonPressed(button: cint): boolean     <cimport, nodecl> end -- Detect if a mouse button has been pressed once
local function IsMouseButtonDown(button: cint): boolean        <cimport, nodecl> end -- Detect if a mouse button is being pressed
local function IsMouseButtonReleased(button: cint): boolean    <cimport, nodecl> end -- Detect if a mouse button has been released once
local function IsMouseButtonUp(button: cint): boolean          <cimport, nodecl> end -- Detect if a mouse button is NOT being pressed
local function GetMouseX(): cint                               <cimport, nodecl> end -- Returns mouse position X
local function GetMouseY(): cint                               <cimport, nodecl> end -- Returns mouse position Y
local function GetMousePosition(): Vector2                     <cimport, nodecl> end -- Returns mouse position XY
local function SetMousePosition(x: cint, y: cint)              <cimport, nodecl> end -- Set mouse position XY
local function SetMouseOffset(offsetX: cint, offsetY: cint)    <cimport, nodecl> end -- Set mouse offset
local function SetMouseScale(scaleX: float32, scaleY: float32) <cimport, nodecl> end -- Set mouse scaling
local function GetMouseWheelMove(): cint                       <cimport, nodecl> end -- Returns mouse wheel movement Y

-- Input-related functions: touch
local function GetTouchX(): cint                      <cimport, nodecl> end -- Returns touch position X for touch point 0 (relative to screen size)
local function GetTouchY(): cint                      <cimport, nodecl> end -- Returns touch position Y for touch point 0 (relative to screen size)
local function GetTouchPosition(index: cint): Vector2 <cimport, nodecl> end -- Returns touch position XY for a touch point index (relative to screen size)

--------------------------------------------------------------------------------------
-- Gestures and Touch Handling Functions (Module: gestures)
--------------------------------------------------------------------------------------
local function SetGesturesEnabled(gestureFlags: cuint)   <cimport, nodecl> end -- Enable a set of gestures using flags
local function IsGestureDetected(gesture: cint): boolean <cimport, nodecl> end -- Check if a gesture have been detected
local function GetGestureDetected(): cint                <cimport, nodecl> end -- Get latest detected gesture
local function GetTouchPointsCount(): cint               <cimport, nodecl> end -- Get touch points count
local function GetGestureHoldDuration(): float32         <cimport, nodecl> end -- Get gesture hold time in milliseconds
local function GetGestureDragVector(): Vector2           <cimport, nodecl> end -- Get gesture drag vector
local function GetGestureDragAngle(): float32            <cimport, nodecl> end -- Get gesture drag angle
local function GetGesturePinchVector(): Vector2          <cimport, nodecl> end -- Get gesture pinch delta
local function GetGesturePinchAngle(): float32           <cimport, nodecl> end -- Get gesture pinch angle

--------------------------------------------------------------------------------------
-- Camera System Functions (Module: camera)
--------------------------------------------------------------------------------------
local function SetCameraMode(camera: Camera, mode: cint) <cimport, nodecl> end -- Set camera mode (multiple camera modes available)
local function UpdateCamera(camera: Camera*)             <cimport, nodecl> end -- Update camera position for selected mode

local function SetCameraPanControl(panKey: cint)         <cimport, nodecl> end -- Set camera pan key to combine with mouse movement (free camera)
local function SetCameraAltControl(altKey: cint)         <cimport, nodecl> end -- Set camera alt key to combine with mouse movement (free camera)
local function SetCameraSmoothZoomControl(szKey: cint)   <cimport, nodecl> end -- Set camera smooth zoom key to combine with mouse (free camera)
local function SetCameraMoveControls(frontKey: cint, backKey: cint, rightKey: cint, leftKey: cint, upKey: cint, downKey: cint) <cimport, nodecl> end -- Set camera move controls (1st person and 3rd person cameras)

-----------------------------------
-- Raylib function definitions [ --
-----------------------------------

-- Window-related functions
function Raylib.InitWindow(width: cint, height: cint, title: cstring) <inline>        InitWindow(width, height, title)  end
function Raylib.WindowShouldClose(): boolean                          <inline> return WindowShouldClose()               end
function Raylib.CloseWindow()                                         <inline>        CloseWindow()                     end
function Raylib.IsWindowReady(): boolean                              <inline> return IsWindowReady()                   end
function Raylib.IsWindowMinimized(): boolean                          <inline> return IsWindowMinimized()               end
function Raylib.IsWindowResized(): boolean                            <inline> return IsWindowResized()                 end
function Raylib.IsWindowHidden(): boolean                             <inline> return IsWindowHidden()                  end
function Raylib.ToggleFullscreen()                                    <inline>        ToggleFullscreen()                end
function Raylib.UnhideWindow()                                        <inline>        UnhideWindow()                    end
function Raylib.HideWindow()                                          <inline>        HideWindow()                      end
function Raylib.SetWindowIcon(image: Image)                           <inline>        SetWindowIcon(image)              end
function Raylib.SetWindowTitle(title: cstring)                        <inline>        SetWindowTitle(title)             end
function Raylib.SetWindowPosition(x: cint, y: cint)                   <inline>        SetWindowPosition(x, y)           end
function Raylib.SetWindowMonitor(monitor: cint)                       <inline>        SetWindowMonitor(monitor)         end
function Raylib.SetWindowMinSize(width: cint, height: cint)           <inline>        SetWindowMinSize(width, height)   end
function Raylib.SetWindowSize(width: cint, height: cint)              <inline>        SetWindowSize(width, height)      end
function Raylib.GetWindowHandle(): pointer                            <inline> return GetWindowHandle()                 end
function Raylib.GetScreenWidth(): cint                                <inline> return GetScreenWidth()                  end
function Raylib.GetScreenHeight(): cint                               <inline> return GetScreenHeight()                 end
function Raylib.GetMonitorCount(): cint                               <inline> return GetMonitorCount()                 end
function Raylib.GetMonitorWidth(monitor: cint): cint                  <inline> return GetMonitorWidth(monitor)          end
function Raylib.GetMonitorHeight(monitor: cint): cint                 <inline> return GetMonitorHeight(monitor)         end
function Raylib.GetMonitorPhysicalWidth(monitor: cint): cint          <inline> return GetMonitorPhysicalWidth(monitor)  end
function Raylib.GetMonitorPhysicalHeight(monitor: cint): cint         <inline> return GetMonitorPhysicalHeight(monitor) end
function Raylib.GetMonitorName(monitor: cint): cstring                <inline> return GetMonitorName(monitor)           end
function Raylib.GetClipboardText(): cstring                           <inline> return GetClipboardText()                end
function Raylib.SetClipboardText(text: cstring)                       <inline>        SetClipboardText(text)            end

-- Cursor-related functions
function Raylib.ShowCursor()              <inline>        ShowCursor()     end
function Raylib.HideCursor()              <inline>        HideCursor()     end
function Raylib.IsCursorHidden(): boolean <inline> return IsCursorHidden() end
function Raylib.EnableCursor()            <inline>        EnableCursor()   end
function Raylib.DisableCursor()           <inline>        DisableCursor()  end

-- Drawing-related functions
function Raylib.ClearBackground(color: Color)             <inline> ClearBackground(color)   end
function Raylib.BeginDrawing()                            <inline> BeginDrawing()           end
function Raylib.EndDrawing()                              <inline> EndDrawing()             end
function Raylib.BeginMode2D(camera: Camera2D)             <inline> BeginMode2D(camera)      end
function Raylib.EndMode2D()                               <inline> EndMode2D()              end
function Raylib.BeginMode3D(camera: Camera3D)             <inline> BeginMode3D(camera)      end
function Raylib.EndMode3D()                               <inline> EndMode3D()              end
function Raylib.BeginTextureMode(target: RenderTexture2D) <inline> BeginTextureMode(target) end
function Raylib.EndTextureMode()                          <inline> EndTextureMode()         end

-- Screen-space-related functions
function Raylib.GetMouseRay(mousePosition: Vector2, camera: Camera): Ray     <inline> return GetMouseRay(mousePosition, camera) end
function Raylib.GetWorldToScreen(position: Vector3, camera: Camera): Vector2 <inline> return GetWorldToScreen(position, camera) end
function Raylib.GetCameraMatrix(camera: Camera): Matrix                      <inline> return GetCameraMatrix(camera)            end


-- Timing-related functions
function Raylib.SetTargetFPS(fps: cint) <inline>        SetTargetFPS(fps) end
function Raylib.GetFPS(): cint          <inline> return GetFPS()          end
function Raylib.GetFrameTime(): float32 <inline> return GetFrameTime()    end
function Raylib.GetTime(): float64      <inline> return GetTime()         end

-- Color-related functions
function Raylib.ColorToInt(color: Color): cint            <inline> return ColorToInt(color)     end
function Raylib.ColorNormalize(color: Color): Vector4     <inline> return ColorNormalize(color) end
function Raylib.ColorToHSV(color: Color): Vector3         <inline> return ColorToHSV(color)     end
function Raylib.ColorFromHSV(hsv: Vector3): Color         <inline> return ColorFromHSV(hsv)     end
function Raylib.GetColor(hexValue: cint): Color           <inline> return GetColor(hexValue)    end
function Raylib.Fade(color: Color, alpha: float32): Color <inline> return Fade(color, alpha)    end

-- Misc. functions
function Raylib.SetConfigFlags(flags: cuchar)                   <inline>        SetConfigFlags(flags)         end
function Raylib.SetTraceLogLevel(logType: cint)                 <inline>        SetTraceLogLevel(logType)     end
function Raylib.SetTraceLogExit(logType: cint)                  <inline>        SetTraceLogExit(logType)      end
function Raylib.SetTraceLogCallback(callback: TraceLogCallback) <inline>        SetTraceLogCallback(callback) end
--function Raylib.TraceLog(logType: cint, text: cstring, ...)     <inline>        TraceLog(logType, text, ...)  end
function Raylib.TakeScreenshot(fileName: cstring)               <inline>        TakeScreenshot(fileName)      end
function Raylib.GetRandomValue(min: cint, max: cint): cint      <inline> return GetRandomValue(min, max)      end

-- Files management functions
function Raylib.FileExists(fileName: cstring): boolean                         <inline> return FileExists(fileName)              end
function Raylib.IsFileExtension(fileName: cstring, ext: cstring): boolean      <inline> return IsFileExtension(fileName, ext)    end
function Raylib.GetExtension(fileName: cstring): cstring                       <inline> return GetExtension(fileName)            end
function Raylib.GetFileName(filePath: cstring): cstring                        <inline> return GetFileName(filePath)             end
function Raylib.GetFileNameWithoutExt(filePath: cstring): cstring              <inline> return GetFileNameWithoutExt(filePath)   end
function Raylib.GetDirectoryPath(fileName: cstring): cstring                   <inline> return GetDirectoryPath(fileName)        end
function Raylib.GetWorkingDirectory(): cstring                                 <inline> return GetWorkingDirectory()             end
function Raylib.GetDirectoryFiles(dirPath: cstring, count: cint*): cstring[0]* <inline> return GetDirectoryFiles(dirPath, count) end
function Raylib.ClearDirectoryFiles()                                          <inline>        ClearDirectoryFiles()             end
function Raylib.ChangeDirectory(dir: cstring): boolean                         <inline> return ChangeDirectory(dir)              end
function Raylib.IsFileDropped(): boolean                                       <inline> return IsFileDropped()                   end
function Raylib.GetDroppedFiles(count: cint*): cstring[0]*                     <inline> return GetDroppedFiles(count)            end
function Raylib.ClearDroppedFiles()                                            <inline>        ClearDroppedFiles()               end
function Raylib.GetFileModTime(fileName: cstring): clong                       <inline> return GetFileModTime(fileName)          end

-- Persistent storage management
function Raylib.StorageSaveValue(position: cint, value: cint) <inline>        StorageSaveValue(position, value) end
function Raylib.StorageLoadValue(position: cint): cint        <inline> return StorageLoadValue(position)        end

function Raylib.OpenURL(url: cstring)                         <inline>        OpenURL(url)                      end

--------------------------------------------------------------------------------------
-- Input Handling Functions
--------------------------------------------------------------------------------------

-- Input-related functions: keyb
function Raylib.IsKeyPressed(key: cint): boolean  <inline> return IsKeyPressed(key)  end
function Raylib.IsKeyDown(key: cint): boolean     <inline> return IsKeyDown(key)     end
function Raylib.IsKeyReleased(key: cint): boolean <inline> return IsKeyReleased(key) end
function Raylib.IsKeyUp(key: cint): boolean       <inline> return IsKeyUp(key)       end
function Raylib.GetKeyPressed(): cint             <inline> return GetKeyPressed()    end
function Raylib.SetExitKey(key: cint)             <inline>        SetExitKey(key)    end

-- Input-related functions: gamepads
function Raylib.IsGamepadAvailable(gamepad: cint): boolean                    <inline> return IsGamepadAvailable(gamepad)              end
function Raylib.IsGamepadName(gamepad: cint, name: cstring): boolean          <inline> return IsGamepadName(gamepad, name)             end
function Raylib.GetGamepadName(gamepad: cint): cstring                        <inline> return GetGamepadName(gamepad)                  end
function Raylib.IsGamepadButtonPressed(gamepad: cint, button: cint): boolean  <inline> return IsGamepadButtonPressed(gamepad, button)  end
function Raylib.IsGamepadButtonDown(gamepad: cint, button: cint): boolean     <inline> return IsGamepadButtonDown(gamepad, button)     end
function Raylib.IsGamepadButtonReleased(gamepad: cint, button: cint): boolean <inline> return IsGamepadButtonReleased(gamepad, button) end
function Raylib.IsGamepadButtonUp(gamepad: cint, button: cint): boolean       <inline> return IsGamepadButtonUp(gamepad, button)       end
function Raylib.GetGamepadButtonPressed(): cint                               <inline> return GetGamepadButtonPressed()                end
function Raylib.GetGamepadAxisCount(gamepad: cint): cint                      <inline> return GetGamepadAxisCount(gamepad)             end
function Raylib.GetGamepadAxisMovement(gamepad: cint, axis: cint): float32    <inline> return GetGamepadAxisMovement(gamepad, axis)    end


-- Input-related functions: mouse
function Raylib.IsMouseButtonPressed(button: cint): boolean     <inline> return IsMouseButtonPressed(button)     end
function Raylib.IsMouseButtonDown(button: cint): boolean        <inline> return IsMouseButtonDown(button)        end
function Raylib.IsMouseButtonReleased(button: cint): boolean    <inline> return IsMouseButtonReleased(button)    end
function Raylib.IsMouseButtonUp(button: cint): boolean          <inline> return IsMouseButtonUp(button)          end
function Raylib.GetMouseX(): cint                               <inline> return GetMouseX()                      end
function Raylib.GetMouseY(): cint                               <inline> return GetMouseY()                      end
function Raylib.GetMousePosition(): Vector2                     <inline> return GetMousePosition()               end
function Raylib.SetMousePosition(x: cint, y: cint)              <inline> return SetMousePosition(x, y)           end
function Raylib.SetMouseOffset(offsetX: cint, offsetY: cint)    <inline> return SetMouseOffset(offsetX, offsetY) end
function Raylib.SetMouseScale(scaleX: float32, scaleY: float32) <inline> return SetMouseScale(scaleX, scaleY)    end
function Raylib.GetMouseWheelMove(): cint                       <inline> return GetMouseWheelMove()              end

-- Input-related functions: touch
function Raylib.GetTouchX(): cint                      <inline> return GetTouchX()             end
function Raylib.GetTouchY(): cint                      <inline> return GetTouchY()             end
function Raylib.GetTouchPosition(index: cint): Vector2 <inline> return GetTouchPosition(index) end

--------------------------------------------------------------------------------------
-- Gestures and Touch Handling Functions (Module: gestures)
--------------------------------------------------------------------------------------
function Raylib.SetGesturesEnabled(gestureFlags: cuint)   <inline> return SetGesturesEnabled(gestureFlags) end
function Raylib.IsGestureDetected(gesture: cint): boolean <inline> return IsGestureDetected(gesture)       end
function Raylib.GetGestureDetected(): cint                <inline> return GetGestureDetected()             end
function Raylib.GetTouchPointsCount(): cint               <inline> return GetTouchPointsCount()            end
function Raylib.GetGestureHoldDuration(): float32         <inline> return GetGestureHoldDuration()         end
function Raylib.GetGestureDragVector(): Vector2           <inline> return GetGestureDragVector()           end
function Raylib.GetGestureDragAngle(): float32            <inline> return GetGestureDragAngle()            end
function Raylib.GetGesturePinchVector(): Vector2          <inline> return GetGesturePinchVector()          end
function Raylib.GetGesturePinchAngle(): float32           <inline> return GetGesturePinchAngle()           end

--------------------------------------------------------------------------------------
-- Camera System Functions (Module: camera)
--------------------------------------------------------------------------------------
function Raylib.SetCameraMode(camera: Camera, mode: cint) <inline> return SetCameraMode(camera, mode)         end
function Raylib.UpdateCamera(camera: Camera*)             <inline> return UpdateCamera(camera)                end

function Raylib.SetCameraPanControl(panKey: cint)         <inline> return SetCameraPanControl(panKey)         end
function Raylib.SetCameraAltControl(altKey: cint)         <inline> return SetCameraAltControl(altKey)         end
function Raylib.SetCameraSmoothZoomControl(szKey: cint)   <inline> return SetCameraSmoothZoomControl(szKey)   end
function Raylib.SetCameraMoveControls(frontKey: cint, backKey: cint, rightKey: cint, leftKey: cint, upKey: cint, downKey: cint) <inline>
   SetCameraMoveControls(frontKey, backKey, rightKey, leftKey, upKey, downKey)
end

-----------------------------------
-- Raylib function definitions ] --
-----------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === CORE MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === SHAPES MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Basic shapes drawing functions
local function DrawPixel(posX: cint, posY: cint, color: Color)                                                                                            <cimport, nodecl> end -- Draw a pixel
local function DrawPixelV(position: Vector2, color: Color)                                                                                                <cimport, nodecl> end -- Draw a pixel (Vector version)
local function DrawLine(startPosX: cint, startPosY: cint, endPosX: cint, endPosY: cint, color: Color)                                                     <cimport, nodecl> end -- Draw a line
local function DrawLineV(startPos: Vector2, endPos: Vector2, color: Color)                                                                                <cimport, nodecl> end -- Draw a line (Vector version)
local function DrawLineEx(startPos: Vector2, endPos: Vector2, thick: float32, color: Color)                                                               <cimport, nodecl> end -- Draw a line defining thickness
local function DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: float32, color: Color)                                                           <cimport, nodecl> end -- Draw a line using cubic-bezier curves in-out
local function DrawLineStrip(points: Vector2*, numPoints: cint, color: Color)                                                                             <cimport, nodecl> end -- Draw lines sequence
local function DrawCircle(centerX: cint, centerY: cint, radius: float32, color: Color)                                                                    <cimport, nodecl> end -- Draw a color-filled circle
local function DrawCircleSector(center: Vector2, radius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color)                         <cimport, nodecl> end -- Draw a piece of a circle
local function DrawCircleSectorLines(center: Vector2, radius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color)                    <cimport, nodecl> end -- Draw circle sector outline
local function DrawCircleGradient(centerX: cint, centerY: cint, radius: float32, color1: Color, color2: Color)                                            <cimport, nodecl> end -- Draw a gradient-filled circle
local function DrawCircleV(center: Vector2, radius: float32, color: Color)                                                                                <cimport, nodecl> end -- Draw a color-filled circle (Vector version)
local function DrawCircleLines(centerX: cint, centerY: cint, radius: float32, color: Color)                                                               <cimport, nodecl> end -- Draw circle outline
local function DrawEllipse(centerX: cint, centerY: cint, radiusH: float32, radiusV: float32, color: Color)                                                <cimport, nodecl> end -- Draw ellipse
local function DrawEllipseLines(centerX: cint, centerY: cint, radiusH: float32, radiusV: float32, color: Color)                                           <cimport, nodecl> end -- Draw ellipse outline
local function DrawRing(center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color)      <cimport, nodecl> end -- Draw ring
local function DrawRingLines(center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color) <cimport, nodecl> end -- Draw ring outline
local function DrawRectangle(posX: cint, posY: cint, width: cint, height: cint, color: Color)                                                             <cimport, nodecl> end -- Draw a color-filled rectangle
local function DrawRectangleV(position: Vector2, size: Vector2, color: Color)                                                                             <cimport, nodecl> end -- Draw a color-filled rectangle (Vector version)
local function DrawRectangleRec(rec: Rectangle, color: Color)                                                                                             <cimport, nodecl> end -- Draw a color-filled rectangle
local function DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: float32, color: Color)                                                         <cimport, nodecl> end -- Draw a color-filled rectangle with pro parameters
local function DrawRectangleGradientV(posX: cint, posY: cint, width: cint, height: cint, color1: Color, color2: Color)                                    <cimport, nodecl> end -- Draw a vertical-gradient-filled rectangle
local function DrawRectangleGradientH(posX: cint, posY: cint, width: cint, height: cint, color1: Color, color2: Color)                                    <cimport, nodecl> end -- Draw a horizontal-gradient-filled rectangle
local function DrawRectangleGradientEx(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)                                                <cimport, nodecl> end -- Draw a gradient-filled rectangle with custom vertex colors
local function DrawRectangleLines(posX: cint, posY: cint, width: cint, height: cint, color: Color)                                                        <cimport, nodecl> end -- Draw rectangle outline
local function DrawRectangleLinesEx(rec: Rectangle, lineThick: cint, color: Color)                                                                        <cimport, nodecl> end -- Draw rectangle outline with extended parameters
local function DrawRectangleRounded(rec: Rectangle, roundness: float32, segments: cint, color: Color)                                                     <cimport, nodecl> end -- Draw rectangle with rounded edges
local function DrawRectangleRoundedLines(rec: Rectangle, roundness: float32, segments: cint, lineThick: cint, color: Color)                               <cimport, nodecl> end -- Draw rectangle with rounded edges outline
local function DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)                                                                          <cimport, nodecl> end -- Draw a color-filled triangle (vertex in counter-clockwise order!)
local function DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)                                                                     <cimport, nodecl> end -- Draw triangle outline (vertex in counter-clockwise order!)
local function DrawTriangleFan(points: Vector2*, numPoints: cint, color: Color)                                                                           <cimport, nodecl> end -- Draw a triangle fan defined by points (first vertex is the center)
local function DrawTriangleStrip(points: Vector2*, pointsCount: cint, color: Color)                                                                       <cimport, nodecl> end -- Draw a triangle strip defined by points
local function DrawPoly(center: Vector2, sides: cint, radius: float32, rotation: float32, color: Color)                                                   <cimport, nodecl> end -- Draw a regular polygon (Vector version)
local function DrawPolyLines(center: Vector2, sides: cint, radius: float32, rotation: float32, color: Color)                                              <cimport, nodecl> end -- Draw a polygon outline of n sides

local function SetShapesTexture(texture: Texture2D, source: Rectangle)                                                                                    <cimport, nodecl> end -- Define default texture used to draw shapes

-- Basic shapes collision detection functions
local function CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): boolean                                          <cimport, nodecl> end -- Check collision between two rectangles
local function CheckCollisionCircles(center1: Vector2, radius1: float32, center2: Vector2, radius2: float32): boolean <cimport, nodecl> end -- Check collision between two circles
local function CheckCollisionCircleRec(center: Vector2, radius: float32, rec: Rectangle): boolean                     <cimport, nodecl> end -- Check collision between circle and rectangle
local function GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle                                           <cimport, nodecl> end -- Get collision rectangle for two rectangles collision
local function CheckCollisionPointRec(point: Vector2, rec: Rectangle): boolean                                        <cimport, nodecl> end -- Check if point is inside rectangle
local function CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: float32): boolean                   <cimport, nodecl> end -- Check if point is inside circle
local function CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): boolean            <cimport, nodecl> end -- Check if point is inside a triangle

-----------------------------------
-- Raylib function definitions [ --
-----------------------------------

-- Basic shapes drawing functions
function Raylib.DrawPixel(posX: cint, posY: cint, color: Color)                                                                                            <inline> DrawPixel(posX, posY, color)                                                           end
function Raylib.DrawPixelV(position: Vector2, color: Color)                                                                                                <inline> DrawPixelV(position, color)                                                            end
function Raylib.DrawLine(startPosX: cint, startPosY: cint, endPosX: cint, endPosY: cint, color: Color)                                                     <inline> DrawLine(startPosX, startPosY, endPosX, endPosY, color)                                end
function Raylib.DrawLineV(startPos: Vector2, endPos: Vector2, color: Color)                                                                                <inline> DrawLineV(startPos, endPos, color)                                                     end
function Raylib.DrawLineEx(startPos: Vector2, endPos: Vector2, thick: float32, color: Color)                                                               <inline> DrawLineEx(startPos, endPos, thick, color)                                             end
function Raylib.DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: float32, color: Color)                                                           <inline> DrawLineBezier(startPos, endPos, thick, color)                                         end
function Raylib.DrawLineStrip(points: Vector2*, numPoints: cint, color: Color)                                                                             <inline> DrawLineStrip(points, numPoints, color)                                                end
function Raylib.DrawCircle(centerX: cint, centerY: cint, radius: float32, color: Color)                                                                    <inline> DrawCircle(centerX, centerY, radius, color)                                            end
function Raylib.DrawCircleSector(center: Vector2, radius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color)                         <inline> DrawCircleSector(center, radius, startAngle, endAngle, segments, color)                end
function Raylib.DrawCircleSectorLines(center: Vector2, radius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color)                    <inline> DrawCircleSectorLines(center, radius, startAngle, endAngle, segments, color)           end
function Raylib.DrawCircleGradient(centerX: cint, centerY: cint, radius: float32, color1: Color, color2: Color)                                            <inline> DrawCircleGradient(centerX, centerY, radius, color1, color2)                           end
function Raylib.DrawCircleV(center: Vector2, radius: float32, color: Color)                                                                                <inline> DrawCircleV(center, radius, color)                                                     end
function Raylib.DrawCircleLines(centerX: cint, centerY: cint, radius: float32, color: Color)                                                               <inline> DrawCircleLines(centerX, centerY, radius, color)                                       end
function Raylib.DrawEllipse(centerX: cint, centerY: cint, radiusH: float32, radiusV: float32, color: Color)                                                <inline> DrawEllipse(centerX, centerY, radiusH, radiusV, color)                                 end
function Raylib.DrawEllipseLines(centerX: cint, centerY: cint, radiusH: float32, radiusV: float32, color: Color)                                           <inline> DrawEllipseLines(centerX, centerY, radiusH, radiusV, color)                            end
function Raylib.DrawRing(center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color)      <inline> DrawRing(center, innerRadius, outerRadius, startAngle, endAngle, segments, color)      end
function Raylib.DrawRingLines(center: Vector2, innerRadius: float32, outerRadius: float32, startAngle: cint, endAngle: cint, segments: cint, color: Color) <inline> DrawRingLines(center, innerRadius, outerRadius, startAngle, endAngle, segments, color) end
function Raylib.DrawRectangle(posX: cint, posY: cint, width: cint, height: cint, color: Color)                                                             <inline> DrawRectangle(posX, posY, width, height, color)                                        end
function Raylib.DrawRectangleV(position: Vector2, size: Vector2, color: Color)                                                                             <inline> DrawRectangleV(position, size, color)                                                  end
function Raylib.DrawRectangleRec(rec: Rectangle, color: Color)                                                                                             <inline> DrawRectangleRec(rec, color)                                                           end
function Raylib.DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: float32, color: Color)                                                         <inline> DrawRectanglePro(rec, origin, rotation, color)                                         end
function Raylib.DrawRectangleGradientV(posX: cint, posY: cint, width: cint, height: cint, color1: Color, color2: Color)                                    <inline> DrawRectangleGradientV(posX, posY, width, height, color1, color2)                      end
function Raylib.DrawRectangleGradientH(posX: cint, posY: cint, width: cint, height: cint, color1: Color, color2: Color)                                    <inline> DrawRectangleGradientH(posX, posY, width, height, color1, color2)                      end
function Raylib.DrawRectangleGradientEx(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)                                                <inline> DrawRectangleGradientEx(rec, col1, col2, col3, col4)                                   end
function Raylib.DrawRectangleLines(posX: cint, posY: cint, width: cint, height: cint, color: Color)                                                        <inline> DrawRectangleLines(posX, posY, width, height, color)                                   end
function Raylib.DrawRectangleLinesEx(rec: Rectangle, lineThick: cint, color: Color)                                                                        <inline> DrawRectangleLinesEx(rec, lineThick, color)                                            end
function Raylib.DrawRectangleRounded(rec: Rectangle, roundness: float32, segments: cint, color: Color)                                                     <inline> DrawRectangleRounded(rec, roundness, segments, color)                                  end
function Raylib.DrawRectangleRoundedLines(rec: Rectangle, roundness: float32, segments: cint, lineThick: cint, color: Color)                               <inline> DrawRectangleRoundedLines(rec, roundness, segments, lineThick, color)                  end
function Raylib.DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)                                                                          <inline> DrawTriangle(v1, v2, v3, color)                                                        end
function Raylib.DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)                                                                     <inline> DrawTriangleLines(v1, v2, v3, color)                                                   end
function Raylib.DrawTriangleFan(points: Vector2*, numPoints: cint, color: Color)                                                                           <inline> DrawTriangleFan(points, numPoints, color)                                              end
function Raylib.DrawTriangleStrip(points: Vector2*, pointsCount: cint, color: Color)                                                                       <inline> DrawTriangleStrip(points, pointsCount, color)                                          end
function Raylib.DrawPoly(center: Vector2, sides: cint, radius: float32, rotation: float32, color: Color)                                                   <inline> DrawPoly(center, sides, radius, rotation, color)                                       end
function Raylib.DrawPolyLines(center: Vector2, sides: cint, radius: float32, rotation: float32, color: Color)                                              <inline> DrawPolyLines(center, sides, radius, rotation, color)                                  end

function Raylib.SetShapesTexture(texture: Texture2D, source: Rectangle)                                                                                    <inline> SetShapesTexture(texture, source)                                                      end

-- Basic shapes collision detection functions
function Raylib.CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): boolean                                          <inline> return CheckCollisionRecs(rec1, rec2)                            end
function Raylib.CheckCollisionCircles(center1: Vector2, radius1: float32, center2: Vector2, radius2: float32): boolean <inline> return CheckCollisionCircles(center1, radius1, center2, radius2) end
function Raylib.CheckCollisionCircleRec(center: Vector2, radius: float32, rec: Rectangle): boolean                     <inline> return CheckCollisionCircleRec(center, radius, rec)              end
function Raylib.GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle                                           <inline> return GetCollisionRec(rec1, rec2)                               end
function Raylib.CheckCollisionPointRec(point: Vector2, rec: Rectangle): boolean                                        <inline> return CheckCollisionPointRec(point, rec)                        end
function Raylib.CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: float32): boolean                   <inline> return CheckCollisionPointCircle(point, center, radius)          end
function Raylib.CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): boolean            <inline> return CheckCollisionPointTriangle(point, p1, p2, p3)            end

-----------------------------------
-- Raylib function definitions ] --
-----------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === SHAPES MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === TEXTURES MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Image/Texture2D data loading/unloading/saving functions
local function LoadImage(fileName: cstring): Image                                                                                                <cimport, nodecl> end -- Load image from file into CPU memory (RAM)
local function LoadImageEx(pixels: Color*, width: cint, height: cint): Image                                                                      <cimport, nodecl> end -- Load image from Color array data (RGBA - 32bit)
local function LoadImagePro(data: pointer, width: cint , height: cint , format: cint ): Image                                                     <cimport, nodecl> end -- Load image from raw data with parameters
local function LoadImageRaw(fileName: cstring, width: cint, height: cint, format: cint, headerSize: cint): Image                                  <cimport, nodecl> end -- Load image from RAW file data
local function ExportImage(image: Image , fileName: cstring)                                                                                      <cimport, nodecl> end -- Export image data to file
local function ExportImageAsCode(image: Image, fileName: cstring)                                                                                 <cimport, nodecl> end -- Export image as code file defining an array of bytes
local function LoadTexture(fileName: cstring): Texture2D                                                                                          <cimport, nodecl> end -- Load texture from file into GPU memory (VRAM)
local function LoadTextureFromImage(image: Image): Texture2D                                                                                      <cimport, nodecl> end -- Load texture from image data
local function LoadTextureCubemap(image: Image, layoutType: cint): TextureCubemap                                                                 <cimport, nodecl> end -- Load cubemap from image, multiple image cubemap layouts supported
local function LoadRenderTexture(width: cint, height: cint): RenderTexture2D                                                                      <cimport, nodecl> end -- Load texture for rendering (framebuffer)
local function UnloadImage(image: Image )                                                                                                         <cimport, nodecl> end -- Unload image from CPU memory (RAM)
local function UnloadTexture(texture: Texture2D)                                                                                                  <cimport, nodecl> end -- Unload texture from GPU memory (VRAM)
local function UnloadRenderTexture(target: RenderTexture2D)                                                                                       <cimport, nodecl> end -- Unload render texture from GPU memory (VRAM)
local function GetImageData(image: Image): Color*                                                                                                 <cimport, nodecl> end -- Get pixel data from image as a Color struct array
local function GetImageDataNormalized(image: Image): Vector4 *                                                                                    <cimport, nodecl> end -- Get pixel data from image as Vector4 array (float normalized)
local function GetImageAlphaBorder(image: Image, threshold: float32): Rectangle                                                                   <cimport, nodecl> end -- Get image alpha border rectangle
local function GetPixelDataSize(width: cint, height: cint, format: cint): cint                                                                    <cimport, nodecl> end -- Get pixel data size in bytes (image or texture)
local function GetTextureData(texture: Texture2D): Image                                                                                          <cimport, nodecl> end -- Get pixel data from GPU texture and return an Image
local function GetScreenData(): Image                                                                                                             <cimport, nodecl> end -- Get pixel data from screen buffer and return an Image (screenshot)
local function UpdateTexture(texture: Texture2D, pixels: pointer <const>)                                                                         <cimport, nodecl> end -- Update GPU texture with new data

-- Image manipulation functions
local function ImageCopy(image: Image): Image                                                                                                     <cimport, nodecl> end -- Create an image duplicate (useful for transformations)
local function ImageFromImage(image: Image, rec: Rectangle): Image                                                                                <cimport, nodecl> end -- Create an image from another image piece
local function ImageToPOT(image: Image*, fillColor: Color)                                                                                        <cimport, nodecl> end -- Convert image to POT (power-of-two)
local function ImageFormat(image: Image*, newFormat: cint)                                                                                        <cimport, nodecl> end -- Convert image data to desired format
local function ImageAlphaMask(image: Image*, alphaMask: Image)                                                                                    <cimport, nodecl> end -- Apply alpha mask to image
local function ImageAlphaClear(image: Image*, color: Color, threshold: float32)                                                                   <cimport, nodecl> end -- Clear alpha channel to desired color
local function ImageAlphaCrop(image: Image*, threshold: float32)                                                                                  <cimport, nodecl> end -- Crop image depending on alpha value
local function ImageAlphaPremultiply(image: Image*)                                                                                               <cimport, nodecl> end -- Premultiply alpha channel
local function ImageCrop(image: Image*, crop: Rectangle)                                                                                          <cimport, nodecl> end -- Crop an image to a defined rectangle
local function ImageResize(image: Image*, newWidth: cint, newHeight: cint)                                                                        <cimport, nodecl> end -- Resize image (Bicubic scaling algorithm)
local function ImageResizeNN(image: Image*, newWidth: cint, newHeight: cint)                                                                      <cimport, nodecl> end -- Resize image (Nearest-Neighbor scaling algorithm)
local function ImageResizeCanvas(image: Image*, newWidth: cint, newHeight: cint, offsetX: cint, offsetY: cint, color: Color)                      <cimport, nodecl> end -- Resize canvas and fill with color
local function ImageMipmaps(image: Image*)                                                                                                        <cimport, nodecl> end -- Generate all mipmap levels for a provided image
local function ImageDither(image: Image*, rBpp: cint, gBpp: cint, bBpp: cint, aBpp: cint)                                                         <cimport, nodecl> end -- Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
local function ImageExtractPalette(image: Image, maxPaletteSize: cint, extractCount: cint*): Color*                                               <cimport, nodecl> end -- Extract color palette from image to maximum size (memory should be freed)
local function ImageText(text: cstring, fontSize: cint, color: Color): Image                                                                      <cimport, nodecl> end -- Create an image from text (default font)
local function ImageTextEx(font: Font, text: cstring, fontSize: float32, spacing: float32, tint: Color): Image                                    <cimport, nodecl> end -- Create an image from text (custom sprite font)
local function ImageDraw(dst: Image*, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)                                              <cimport, nodecl> end -- Draw a source image within a destination image (tint applied to source)
local function ImageDrawRectangle(dst: Image*, rec: Rectangle, color: Color)                                                                      <cimport, nodecl> end -- Draw rectangle within an image
local function ImageDrawRectangleLines(dst: Image*, rec: Rectangle, thick: cint, color: Color)                                                    <cimport, nodecl> end -- Draw rectangle lines within an image
local function ImageDrawText(dst: Image*, position: Vector2, text: cstring, fontSize: cint, color: Color)                                         <cimport, nodecl> end -- Draw text (default font) within an image (destination)
local function ImageDrawTextEx(dst: Image*, position: Vector2, font: Font, text: cstring, fontSize: float32, spacing: float32, color: Color)      <cimport, nodecl> end -- Draw text (custom sprite font) within an image (destination)
local function ImageFlipVertical(image: Image*)                                                                                                   <cimport, nodecl> end -- Flip image vertically
local function ImageFlipHorizontal(image: Image*)                                                                                                 <cimport, nodecl> end -- Flip image horizontally
local function ImageRotateCW(image: Image*)                                                                                                       <cimport, nodecl> end -- Rotate image clockwise 90deg
local function ImageRotateCCW(image: Image*)                                                                                                      <cimport, nodecl> end -- Rotate image counter-clockwise 90deg
local function ImageColorTint(image: Image*, color: Color)                                                                                        <cimport, nodecl> end -- Modify image color: tint
local function ImageColorInvert(image: Image*)                                                                                                    <cimport, nodecl> end -- Modify image color: invert
local function ImageColorGrayscale(image: Image*)                                                                                                 <cimport, nodecl> end -- Modify image color: grayscale
local function ImageColorContrast(image: Image*, contrast: float32)                                                                               <cimport, nodecl> end -- Modify image color: contrast (-100 to 100)
local function ImageColorBrightness(image: Image*, brightness: cint)                                                                              <cimport, nodecl> end -- Modify image color: brightness (-255 to 255)
local function ImageColorReplace(image: Image*, color: Color, replace: Color)                                                                     <cimport, nodecl> end -- Modify image color: replace color

-- Image generation functions
local function GenImageColor(width: cint, height: cint, color: Color): Image                                                                      <cimport, nodecl> end -- Generate image: plain color
local function GenImageGradientV(width: cint, height: cint, top: Color, bottom: Color): Image                                                     <cimport, nodecl> end -- Generate image: vertical gradient
local function GenImageGradientH(width: cint, height: cint, left: Color, right: Color): Image                                                     <cimport, nodecl> end -- Generate image: horizontal gradient
local function GenImageGradientRadial(width: cint, height: cint, density: float32, inner: Color, outer: Color): Image                             <cimport, nodecl> end -- Generate image: radial gradient
local function GenImageChecked(width: cint, height: cint, checksX: cint, checksY: cint, col1: Color, col2: Color): Image                          <cimport, nodecl> end -- Generate image: checked
local function GenImageWhiteNoise(width: cint, height: cint, factor: float32): Image                                                              <cimport, nodecl> end -- Generate image: white noise
local function GenImagePerlinNoise(width: cint, height: cint, offsetX: cint, offsetY: cint, scale: float32): Image                                <cimport, nodecl> end -- Generate image: perlin noise
local function GenImageCellular(width: cint, height: cint, tileSize: cint): Image                                                                 <cimport, nodecl> end -- Generate image: cellular algorithm. Bigger tileSize means bigger cells

-- Texture2D configuration functions
local function GenTextureMipmaps(texture: Texture2D*)                                                                                             <cimport, nodecl> end -- Generate GPU mipmaps for a texture
local function SetTextureFilter(texture: Texture2D, filterMode: cint)                                                                             <cimport, nodecl> end -- Set texture scaling filter mode
local function SetTextureWrap(texture: Texture2D, wrapMode: cint)                                                                                 <cimport, nodecl> end -- Set texture wrapping mode

-- Texture2D drawing functions
local function DrawTexture(texture: Texture2D, posX: cint, posY: cint, tint: Color)                                                               <cimport, nodecl> end -- Draw a Texture2D
local function DrawTextureV(texture: Texture2D, position: Vector2, tint: Color)                                                                   <cimport, nodecl> end -- Draw a Texture2D with position defined as Vector2
local function DrawTextureEx(texture: Texture2D, position: Vector2, rotation: float32, scale: float32, tint: Color)                               <cimport, nodecl> end -- Draw a Texture2D with extended parameters
local function DrawTextureRec(texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color)                                           <cimport, nodecl> end -- Draw a part of a texture defined by a rectangle
local function DrawTextureQuad(texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color)                                <cimport, nodecl> end -- Draw texture quad with tiling and offset parameters
local function DrawTexturePro(texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float32, tint: Color)      <cimport, nodecl> end -- Draw a part of a texture defined by a rectangle with 'pro' parameters
local function DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, destRec: Rectangle, origin: Vector2, rotation: float32, tint: Color) <cimport, nodecl> end -- Draws a texture (or part of it) that stretches or shrinks nicely

-----------------------------------
-- Raylib function definitions [ --
-----------------------------------

-- Image/Texture2D data loading/unloading/saving functions
function Raylib.LoadImage(fileName: cstring): Image                                                                                                <inline> return LoadImage(fileName)                                                     end
function Raylib.LoadImageEx(pixels: Color*, width: cint, height: cint): Image                                                                      <inline> return LoadImageEx(pixels, width, height)                                      end
function Raylib.LoadImagePro(data: pointer, width: cint , height: cint , format: cint ): Image                                                     <inline> return LoadImagePro(data, width, height, format)                               end
function Raylib.LoadImageRaw(fileName: cstring, width: cint, height: cint, format: cint, headerSize: cint): Image                                  <inline> return LoadImageRaw(fileName, width, height, format, headerSize)               end
function Raylib.ExportImage(image: Image , fileName: cstring)                                                                                      <inline>        ExportImage(image, fileName)                                            end
function Raylib.ExportImageAsCode(image: Image, fileName: cstring)                                                                                 <inline>        ExportImageAsCode(image, fileName)                                      end
function Raylib.LoadTexture(fileName: cstring): Texture2D                                                                                          <inline> return LoadTexture(fileName)                                                   end
function Raylib.LoadTextureFromImage(image: Image): Texture2D                                                                                      <inline> return LoadTextureFromImage(image)                                             end
function Raylib.LoadTextureCubemap(image: Image, layoutType: cint): TextureCubemap                                                                 <inline> return LoadTextureCubemap(image, layoutType)                                   end
function Raylib.LoadRenderTexture(width: cint, height: cint): RenderTexture2D                                                                      <inline> return LoadRenderTexture(width, height)                                        end
function Raylib.UnloadImage(image: Image )                                                                                                         <inline>        UnloadImage(image)                                                      end
function Raylib.UnloadTexture(texture: Texture2D)                                                                                                  <inline>        UnloadTexture(texture)                                                  end
function Raylib.UnloadRenderTexture(target: RenderTexture2D)                                                                                       <inline>        UnloadRenderTexture(target)                                             end
function Raylib.GetImageData(image: Image): Color*                                                                                                 <inline> return GetImageData(image)                                                     end
function Raylib.GetImageDataNormalized(image: Image): Vector4*                                                                                     <inline> return GetImageDataNormalized(image)                                           end
function Raylib.GetImageAlphaBorder(image: Image, threshold: float32): Rectangle                                                                   <inline> return GetImageAlphaBorder(image, threshold)                                   end
function Raylib.GetPixelDataSize(width: cint, height: cint, format: cint): cint                                                                    <inline> return GetPixelDataSize(width, height, format)                                 end
function Raylib.GetTextureData(texture: Texture2D): Image                                                                                          <inline> return GetTextureData(texture)                                                 end
function Raylib.GetScreenData(): Image                                                                                                             <inline> return GetScreenData()                                                         end
function Raylib.UpdateTexture(texture: Texture2D, pixels: pointer <const>)                                                                         <inline>        UpdateTexture(texture, pixels)                                          end

-- Image manipulation functions
function Raylib.ImageCopy(image: Image): Image                                                                                                     <inline> return ImageCopy(image)                                                        end
function Raylib.ImageFromImage(image: Image, rec: Rectangle): Image                                                                                <inline> return ImageFromImage(image, rec)                                              end
function Raylib.ImageToPOT(image: Image*, fillColor: Color)                                                                                        <inline>        ImageToPOT(image, fillColor)                                            end
function Raylib.ImageFormat(image: Image*, newFormat: cint)                                                                                        <inline>        ImageFormat(image, newFormat)                                           end
function Raylib.ImageAlphaMask(image: Image*, alphaMask: Image)                                                                                    <inline>        ImageAlphaMask(image, alphaMask)                                        end
function Raylib.ImageAlphaClear(image: Image*, color: Color, threshold: float32)                                                                   <inline>        ImageAlphaClear(image, color, threshold)                                end
function Raylib.ImageAlphaCrop(image: Image*, threshold: float32)                                                                                  <inline>        ImageAlphaCrop(image, threshold)                                        end
function Raylib.ImageAlphaPremultiply(image: Image*)                                                                                               <inline>        ImageAlphaPremultiply(image)                                            end
function Raylib.ImageCrop(image: Image*, crop: Rectangle)                                                                                          <inline>        ImageCrop(image, crop)                                                  end
function Raylib.ImageResize(image: Image*, newWidth: cint, newHeight: cint)                                                                        <inline>        ImageResize(image, newWidth, newHeight)                                 end
function Raylib.ImageResizeNN(image: Image*, newWidth: cint, newHeight: cint)                                                                      <inline>        ImageResizeNN(image, newWidth, newHeight)                               end
function Raylib.ImageResizeCanvas(image: Image*, newWidth: cint, newHeight: cint, offsetX: cint, offsetY: cint, color: Color)                      <inline>        ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, color)  end
function Raylib.ImageMipmaps(image: Image*)                                                                                                        <inline>        ImageMipmaps(image)                                                     end
function Raylib.ImageDither(image: Image*, rBpp: cint, gBpp: cint, bBpp: cint, aBpp: cint)                                                         <inline>        ImageDither(image, rBpp, gBpp, bBpp, aBpp)                              end
function Raylib.ImageExtractPalette(image: Image, maxPaletteSize: cint, extractCount: cint*): Color*                                               <inline> return ImageExtractPalette(image, maxPaletteSize, extractCount)                end
function Raylib.ImageText(text: cstring, fontSize: cint, color: Color): Image                                                                      <inline> return ImageText(text, fontSize, color)                                        end
function Raylib.ImageTextEx(font: Font, text: cstring, fontSize: float32, spacing: float32, tint: Color): Image                                    <inline> return ImageTextEx(font, text, fontSize, spacing, tint)                        end
function Raylib.ImageDraw(dst: Image*, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)                                              <inline>        ImageDraw(dst, src, srcRec, dstRec, tint)                               end
function Raylib.ImageDrawRectangle(dst: Image*, rec: Rectangle, color: Color)                                                                      <inline>        ImageDrawRectangle(dst, rec, color)                                     end
function Raylib.ImageDrawRectangleLines(dst: Image*, rec: Rectangle, thick: cint, color: Color)                                                    <inline>        ImageDrawRectangleLines(dst, rec, thick, color)                         end
function Raylib.ImageDrawText(dst: Image*, position: Vector2, text: cstring, fontSize: cint, color: Color)                                         <inline>        ImageDrawText(dst, position, text, fontSize, color)                     end
function Raylib.ImageDrawTextEx(dst: Image*, position: Vector2, font: Font, text: cstring, fontSize: float32, spacing: float32, color: Color)      <inline>        ImageDrawTextEx(dst, position, font, text, fontSize, spacing, color)    end
function Raylib.ImageFlipVertical(image: Image*)                                                                                                   <inline>        ImageFlipVertical(image)                                                end
function Raylib.ImageFlipHorizontal(image: Image*)                                                                                                 <inline>        ImageFlipHorizontal(image)                                              end
function Raylib.ImageRotateCW(image: Image*)                                                                                                       <inline>        ImageRotateCW(image)                                                    end
function Raylib.ImageRotateCCW(image: Image*)                                                                                                      <inline>        ImageRotateCCW(image)                                                   end
function Raylib.ImageColorTint(image: Image*, color: Color)                                                                                        <inline>        ImageColorTint(image, color)                                            end
function Raylib.ImageColorInvert(image: Image*)                                                                                                    <inline>        ImageColorInvert(image)                                                 end
function Raylib.ImageColorGrayscale(image: Image*)                                                                                                 <inline>        ImageColorGrayscale(image)                                              end
function Raylib.ImageColorContrast(image: Image*, contrast: float32)                                                                               <inline>        ImageColorContrast(image, contrast)                                     end
function Raylib.ImageColorBrightness(image: Image*, brightness: cint)                                                                              <inline>        ImageColorBrightness(image, brightness)                                 end
function Raylib.ImageColorReplace(image: Image*, color: Color, replace: Color)                                                                     <inline>        ImageColorReplace(image, color, replace)                                end

-- Image generation functions
function Raylib.GenImageColor(width: cint, height: cint, color: Color): Image                                                                      <inline> return GenImageColor(width, height, color)                                     end
function Raylib.GenImageGradientV(width: cint, height: cint, top: Color, bottom: Color): Image                                                     <inline> return GenImageGradientV(width, height, top, bottom)                           end
function Raylib.GenImageGradientH(width: cint, height: cint, left: Color, right: Color): Image                                                     <inline> return GenImageGradientH(width, height, left, right)                           end
function Raylib.GenImageGradientRadial(width: cint, height: cint, density: float32, inner: Color, outer: Color): Image                             <inline> return GenImageGradientRadial(width, height, density, inner, outer)            end
function Raylib.GenImageChecked(width: cint, height: cint, checksX: cint, checksY: cint, col1: Color, col2: Color): Image                          <inline> return GenImageChecked(width, height, checksX, checksY, col1, col2)            end
function Raylib.GenImageWhiteNoise(width: cint, height: cint, factor: float32): Image                                                              <inline> return GenImageWhiteNoise(width, height, factor)                               end
function Raylib.GenImagePerlinNoise(width: cint, height: cint, offsetX: cint, offsetY: cint, scale: float32): Image                                <inline> return GenImagePerlinNoise(width, height, offsetX, offsetY, scale)             end
function Raylib.GenImageCellular(width: cint, height: cint, tileSize: cint): Image                                                                 <inline> return GenImageCellular(width, height, tileSize)                               end

-- Texture2D configuration functions
function Raylib.GenTextureMipmaps(texture: Texture2D*)                                                                                             <inline>        GenTextureMipmaps(texture)                                              end
function Raylib.SetTextureFilter(texture: Texture2D, filterMode: cint)                                                                             <inline>        SetTextureFilter(texture, filterMode)                                   end
function Raylib.SetTextureWrap(texture: Texture2D, wrapMode: cint)                                                                                 <inline>        SetTextureWrap(texture, wrapMode)                                       end

-- Texture2D drawing functions
function Raylib.DrawTexture(texture: Texture2D, posX: cint, posY: cint, tint: Color)                                                               <inline>        DrawTexture(texture, posX, posY, tint)                                  end
function Raylib.DrawTextureV(texture: Texture2D, position: Vector2, tint: Color)                                                                   <inline>        DrawTextureV(texture, position, tint)                                   end
function Raylib.DrawTextureEx(texture: Texture2D, position: Vector2, rotation: float32, scale: float32, tint: Color)                               <inline>        DrawTextureEx(texture, position, rotation, scale, tint)                 end
function Raylib.DrawTextureRec(texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color)                                           <inline>        DrawTextureRec(texture, sourceRec, position, tint)                      end
function Raylib.DrawTextureQuad(texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color)                                <inline>        DrawTextureQuad(texture, tiling, offset, quad, tint)                    end
function Raylib.DrawTexturePro(texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float32, tint: Color)      <inline>        DrawTexturePro(texture, sourceRec, destRec, origin, rotation, tint)     end
function Raylib.DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, destRec: Rectangle, origin: Vector2, rotation: float32, tint: Color) <inline>        DrawTextureNPatch(texture, nPatchInfo, destRec, origin, rotation, tint) end

-----------------------------------
-- Raylib function definitions ] --
-----------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === TEXTURES MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === TEXT MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Font loading/unloading functions
local function GetFontDefault(): Font                                                                                                                     <cimport, nodecl> end -- Get the default Font
local function LoadFont(fileName: cstring): Font                                                                                                          <cimport, nodecl> end -- Load font from file into GPU memory (VRAM)
local function LoadFontEx(fileName: cstring, fontSize: cint, fontChars: cint*, charsCount: cint): Font                                                    <cimport, nodecl> end -- Load font from file with extended parameters
local function LoadFontFromImage(image: Image, key: Color, firstChar: cint): Font                                                                         <cimport, nodecl> end -- Load font from Image (XNA style)
local function LoadFontData(fileName: cstring, fontSize: cint, fontChars: cint*, charsCount: cint, type: cint): CharInfo*                                 <cimport, nodecl> end -- Load font data for further use
local function GenImageFontAtlas(chars: CharInfo* <const>, recs: Rectangle[0]*, charsCount: cint, fontSize: cint, padding: cint, packMethod: cint): Image <cimport, nodecl> end -- Generate image font atlas using chars info
local function UnloadFont(font: Font)                                                                                                                     <cimport, nodecl> end -- Unload Font from GPU memory (VRAM)

-- Text drawing functions
local function DrawFPS(posX: cint, posY: cint)                                                                                                    <cimport, nodecl> end -- Shows current FPS
local function DrawText(text: cstring, posX: cint, posY: cint, fontSize: cint, color: Color)                                                      <cimport, nodecl> end -- Draw text (using default font)
local function DrawTextEx(font: Font, text: cstring, position: Vector2, fontSize: float32, spacing: float32, tint: Color)                         <cimport, nodecl> end -- Draw text using font and additional parameters
local function DrawTextRec(font: Font, text: cstring, rec: Rectangle, fontSize: float32, spacing: float32, wordWrap: boolean, tint: Color)        <cimport, nodecl> end -- Draw text using font inside rectangle limits
local function DrawTextRecEx(font: Font, text: cstring, rec: Rectangle, fontSize: float32, spacing: float32, wordWrap: boolean, tint: Color, selectStart: cint, selectLength: cint, selectText: Color, selectBack: Color) <cimport, nodecl> end -- Draw text using font inside rectangle limits with support for text selection

-- Text misc. functions
local function MeasureText(text: cstring, fontSize: cint): cint                                       <cimport, nodecl> end -- Measure string width for default font
local function MeasureTextEx(font: Font, text: cstring, fontSize: float32, spacing: float32): Vector2 <cimport, nodecl> end -- Measure string size for Font
local function GetGlyphIndex(font: Font, character: cint): cint                                       <cimport, nodecl> end -- Get index position for a unicode character on font

-- Text strings management functions
-- NOTE: Some strings allocate memory internally for returned strings, just be careful!
local function TextIsEqual(text1: cstring, text2: cstring): boolean                      <cimport, nodecl> end -- Check if two text string are equal
local function TextLength(text: cstring): cuint                                          <cimport, nodecl> end -- Get text length, checks for '\0' ending
global function TextFormat(text: cstring, ...): cstring                                   <cimport, nodecl> end -- Text formatting with variables (sprintf style)
local function TextSubtext(text: cstring, position: cint, length: cint): cstring         <cimport, nodecl> end -- Get a piece of a text string
local function TextReplace(text: cstring, replace: cstring, by: cstring): cstring        <cimport, nodecl> end -- Replace text string (memory should be freed!)
local function TextInsert(text: cstring, insert: cstring, position: cint): cstring       <cimport, nodecl> end -- Insert text in a position (memory should be freed!)
local function TextJoin(textList: cstring[0]*, count: cint, delimiter: cstring): cstring <cimport, nodecl> end -- Join text strings with delimiter
local function TextSplit(text: cstring, delimiter: cchar, count: cint*): cstring[0]*     <cimport, nodecl> end -- Split text into multiple strings
local function TextAppend(text: cstring, append: cstring, position: cint*)               <cimport, nodecl> end -- Append text at specific position and move cursor!
local function TextFindIndex(text: cstring, find: cstring): cint                         <cimport, nodecl> end -- Find first text occurrence within a string
local function TextToUpper(text: cstring): cstring                                       <cimport, nodecl> end -- Get upper case version of provided string
local function TextToLower(text: cstring): cstring                                       <cimport, nodecl> end -- Get lower case version of provided string
local function TextToPascal(text: cstring): cstring                                      <cimport, nodecl> end -- Get Pascal case notation version of provided string
local function TextToInteger(text: cstring): cint                                        <cimport, nodecl> end -- Get integer value from text (negative values not supported)


-----------------------------------
-- Raylib function definitions [ --
-----------------------------------

-- Font loading/unloading functions
function Raylib.GetFontDefault(): Font                                                                                                                     <inline> return GetFontDefault()                                                          end
function Raylib.LoadFont(fileName: cstring): Font                                                                                                          <inline> return LoadFont(fileName)                                                        end
function Raylib.LoadFontEx(fileName: cstring, fontSize: cint, fontChars: cint*, charsCount: cint): Font                                                    <inline> return LoadFontEx(fileName, fontSize, fontChars, charsCount)                     end
function Raylib.LoadFontFromImage(image: Image, key: Color, firstChar: cint): Font                                                                         <inline> return LoadFontFromImage(image, key, firstChar)                                  end
function Raylib.LoadFontData(fileName: cstring, fontSize: cint, fontChars: cint*, charsCount: cint, type: cint): CharInfo*                                 <inline> return LoadFontData(fileName, fontSize, fontChars, charsCount, type)             end
function Raylib.GenImageFontAtlas(chars: CharInfo* <const>, recs: Rectangle[0]*, charsCount: cint, fontSize: cint, padding: cint, packMethod: cint): Image <inline> return GenImageFontAtlas(chars, recs, charsCount, fontSize, padding, packMethod) end
function Raylib.UnloadFont(font: Font)                                                                                                                     <inline>        UnloadFont(font)                                                          end

-- Text drawing functions
function Raylib.DrawFPS(posX: cint, posY: cint)                                                                                             <inline> DrawFPS(posX, posY)                                             end
function Raylib.DrawText(text: cstring, posX: cint, posY: cint, fontSize: cint, color: Color)                                               <inline> DrawText(text, posX, posY, fontSize, color)                     end
function Raylib.DrawTextEx(font: Font, text: cstring, position: Vector2, fontSize: float32, spacing: float32, tint: Color)                  <inline> DrawTextEx(font, text, position, fontSize, spacing, tint)       end
function Raylib.DrawTextRec(font: Font, text: cstring, rec: Rectangle, fontSize: float32, spacing: float32, wordWrap: boolean, tint: Color) <inline> DrawTextRec(font, text, rec, fontSize, spacing, wordWrap, tint) end
function Raylib.DrawTextRecEx(font: Font, text: cstring, rec: Rectangle, fontSize: float32, spacing: float32, wordWrap: boolean, tint: Color, selectStart: cint, selectLength: cint, selectText: Color, selectBack: Color) <inline>
   DrawTextRecEx(font, text, rec, fontSize, spacing, wordWrap, tint, selectStart, selectLength, selectText, selectBack)
end

-- Text misc. functions
function Raylib.MeasureText(text: cstring, fontSize: cint): cint                                       <inline> return MeasureText(text, fontSize)                  end
function Raylib.MeasureTextEx(font: Font, text: cstring, fontSize: float32, spacing: float32): Vector2 <inline> return MeasureTextEx(font, text, fontSize, spacing) end
function Raylib.GetGlyphIndex(font: Font, character: cint): cint                                       <inline> return GetGlyphIndex(font, character)               end

-- Text strings management functions
-- NOTE: Some strings allocate memory internally for returned strings, just be careful!
function Raylib.TextIsEqual(text1: cstring, text2: cstring): boolean                      <inline> return TextIsEqual(text1, text2)               end
function Raylib.TextLength(text: cstring): cuint                                          <inline> return TextLength(text)                        end
--function Raylib.TextFormat(text: cstring, ...): cstring                                   <inline> return TextFormat(text, ...)                   end
function Raylib.TextSubtext(text: cstring, position: cint, length: cint): cstring         <inline> return TextSubtext(text, position, length)     end
function Raylib.TextReplace(text: cstring, replace: cstring, by: cstring): cstring        <inline> return TextReplace(text, replace, by)          end
function Raylib.TextInsert(text: cstring, insert: cstring, position: cint): cstring       <inline> return TextInsert(text, insert, position)      end
function Raylib.TextJoin(textList: cstring[0]*, count: cint, delimiter: cstring): cstring <inline> return TextJoin(textList, count, delimiter)    end
function Raylib.TextSplit(text: cstring, delimiter: cchar, count: cint*): cstring[0]*     <inline> return TextSplit(text, delimiter, count)       end
function Raylib.TextAppend(text: cstring, append: cstring, position: cint*)               <inline>        TextAppend(text, append, position)      end
function Raylib.TextFindIndex(text: cstring, find: cstring): cint                         <inline> return TextFindIndex(text, find)               end
function Raylib.TextToUpper(text: cstring): cstring                                       <inline> return TextToUpper(text)                       end
function Raylib.TextToLower(text: cstring): cstring                                       <inline> return TextToLower(text)                       end
function Raylib.TextToPascal(text: cstring): cstring                                      <inline> return TextToPascal(text)                      end
function Raylib.TextToInteger(text: cstring): cint                                        <inline> return TextToInteger(text)                     end

-----------------------------------
-- Raylib function definitions ] --
-----------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === TEXT MODULE === ]
------------------------------------------------------------------------------------------------------------------------
