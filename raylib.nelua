--[[ This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. ]]

-- Raylib 2.5 wrapper, based on raylib.h (https://github.com/raysan5/raylib/blob/master/src/raylib.h)

-- TODO: Include 'raymath', 'camera' and 'gestures' extra modules into raylib.nelua
-- in a nelua-ish way (for example, import the subrourines below, but also implement
-- Vector2 methods for them)

-- ('raymath', 'camera', 'gestures', 'raygui', 'easings', 'physac 'are extra modules with
-- additional features, however only 'raymath', 'camera 'and 'gestures' are compiled
-- by default with raylib)

## linklib 'raylib'
## linklib 'GL'
## linklib 'glfw'
## linklib 'openal'
## linklib 'm'
## linklib 'pthread'
## linklib 'dl'
## linklib 'X11'
## linklib 'Xrandr'
## linklib 'Xinerama'
## linklib 'Xi'
## linklib 'Xxf86vm'
## linklib 'Xcursor'

## cinclude '<raylib.h>'
## cinclude '<raymath.h>'

global Raymath = @record{}
global Raylib = @record{}

------------------------------------------------------------------------------------------------------------------------
-- === RAYLIB === [
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === RECORDS === [
------------------------------------------------------------------------------------------------------------------------

-----------------------------------
-- import structs [              --
-----------------------------------

global Vector2    <cimport, nodecl> = @record{x: float32, y: float32}                                  -- Vector2 type
## Vector2.value.is_vector2 = true

global Vector3    <cimport, nodecl> = @record{x: float32, y: float32, z: float32}                      -- Vector3 type
## Vector3.value.is_vector3 = true

global Vector4    <cimport, nodecl> = @record{x: float32, y: float32, z: float32, w: float32}          -- Vector4 type
## Vector4.value.is_vector4 = true

global Quaternion <cimport, nodecl> = @record{x: float32, y: float32, z: float32, w: float32}          -- Quaternion type
## Quaternion.value.is_quaternion = true

global Matrix     <cimport, nodecl> = @record{                                                         -- Matrix type (OpenGL style 4x4)
   m0: float32, m4: float32, m8 : float32, m12: float32,
   m1: float32, m5: float32, m9 : float32, m13: float32,
   m2: float32, m6: float32, m10: float32, m14: float32,
   m3: float32, m7: float32, m11: float32, m15: float32
}
## Matrix.value.is_matrix = true

global Color     <cimport, nodecl> = @record{r: uint8, g: uint8, b: uint8, a: uint8}                  -- Color type, RGBA (32bit)
## Color.value.is_color = true

global Rectangle <cimport, nodecl> = @record{x: float32, y: float32, width: float32, height: float32} -- Rectangle type
## Rectangle.value.is_rectangle = true

-- Image type, bpp always RGBA (32bit)
-- NOTE: Data stored in CPU memory (RAM)
global Image <cimport, nodecl> = @record{
   data: pointer, -- Image raw data
   width:   cint, -- Image base width
   height:  cint, -- Image base height
   mipmaps: cint, -- Mipmap levels, 1 by default
   format:  cint  -- Data format (PixelFormat type)
}
## Image.value.is_image = true

-- Texture2D type
-- NOTE: Data stored in GPU memory
global Texture2D <cimport, nodecl> = @record{
   id:     cuint, -- OpenGL texture id
   width:   cint, -- Texture base width
   height:  cint, -- Texture base height
   mipmaps: cint, -- Mipmap levels, 1 by default
   format:  cint  -- Data format (PixelFormat type)
}
## Texture2D.value.is_texture_2d = true

-- Texture type, same as Texture2D
global Texture: type = @Texture2D

-- TextureCubemap type, actually, same as Texture2D
global TextureCubemap: type = @Texture2D

-- RenderTexture2D type, for texture rendering
global RenderTexture2D <cimport, nodecl> = @record{
   id:             cuint, -- OpenGL Framebuffer Object (FBO) id
   texture:    Texture2D, -- Color buffer attachment texture
   depth:      Texture2D, -- Depth buffer attachment texture
   depthTexture: boolean  -- Track if depth attachment is a texture or renderbuffer
}
## RenderTexture2D.value.is_render_texture_2d = true

-- RenderTexture type, same as RenderTexture2D
global RenderTexture: type = @RenderTexture2D

-- N-Patch layout info
global NPatchInfo <cimport, nodecl> = @record{
   sourceRec: Rectangle, -- Region in the texture
   left:           cint, -- left border offset
   top:            cint, -- top border offset
   right:          cint, -- right border offset
   bottom:         cint, -- bottom border offset
   type:           cint  -- layout of the n-patch: 3x3, 1x3 or 3x1
}
## NPatchInfo.value.is_npatch_info = true

-- Font character info
global CharInfo <cimport, nodecl> = @record{
   value:     cint, -- Character value (Unicode)
   offsetX:   cint, -- Character offset X when drawing
   offsetY:   cint, -- Character offset Y when drawing
   advanceX:  cint, -- Character advance position X
   image:    Image, -- Character image data
}
## CharInfo.value.is_char_info = true

-- Font type, includes texture and charSet array data
global Font <cimport, nodecl> = @record{
   baseSize:         cint, -- Base size (default chars height)
   charsCount:       cint, -- Number of characters
   texture:     Texture2D, -- Characters texture atlas
   recs:       Rectangle*, -- Characters rectangles in texture
   chars:       CharInfo*  -- Characters info data
}
## Font.value.is_font = true

-- Camera type, defines a camera position/orientation in 3d space
global Camera3D <cimport, nodecl> = @record{
   position: Vector3, -- Camera position
   target:   Vector3, -- Camera target it looks-at
   up:       Vector3, -- Camera up vector (rotation over its axis)
   fovy:     float32, -- Camera field-of-view apperture in Y (degrees) in perspective, used as near plane width in orthographic
   type:        cint  -- Camera type, defines projection type: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}
## Camera3D.value.is_camera_3d = true

global Camera: type = @Camera3D -- Camera type fallback, defaults to Camera3D

-- Camera2D type, defines a 2d camera
global Camera2D <cimport, nodecl> = @record{
   offset:   Vector2, -- Camera offset (displacement from target)
   target:   Vector2, -- Camera target (rotation and zoom origin)
   rotation: float32, -- Camera rotation in degrees
   zoom:     float32  -- Camera zoom (scaling), should be 1.0f by default
}
## Camera2D.value.is_camera_2d = true

-- Vertex data definning a mesh
-- NOTE: Data stored in CPU memory (and GPU)
global Mesh <cimport, nodecl> = @record{
   vertexCount:      cint, -- Number of vertices stored in arrays
   triangleCount:    cint, -- Number of triangles stored (indexed or not)

   -- Default vertex data
   vertices:     float32*, -- Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
   texcoords:    float32*, -- Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
   texcoords2:   float32*, -- Vertex second texture coordinates (useful for lightmaps) (shader-location = 5)
   normals:      float32*, -- Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
   tangents:     float32*, -- Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
   colors:        cuchar*, -- Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
   indices:      cushort*, -- Vertex indices (in case vertex data comes indexed)

   -- Animation vertex data
   animVertices: float32*, -- Animated vertex positions (after bones transformations)
   animNormals:  float32*, -- Animated normals (after bones transformations)
   boneIds:         cint*, -- Vertex bone ids, up to 4 bones influence by vertex (skinning)
   boneWeights:  float32*, -- Vertex bone weight, up to 4 bones influence by vertex (skinning)

   -- OpenGL identifiers
   vaoId:           cuint, -- OpenGL Vertex Array Object id
   vboId:          cuint*  -- OpenGL Vertex Buffer Objects id (default vertex data)
}
## Mesh.value.is_mesh = true

-- Shader type (generic)
global Shader <cimport, nodecl> = @record{
   id:   cuint, -- Shader program id
   locs: cint*  -- Shader locations array (MAX_SHADER_LOCATIONS)
}
## Shader.value.is_shader = true

-- Material texture map
global MaterialMap <cimport, nodecl> = @record{
   texture: Texture2D, -- Material map texture
   color:       Color, -- Material map color
   value:     float32  -- Material map value
}
## MaterialMap.value.is_material_map = true

-- Material type (generic)
global Material <cimport, nodecl> = @record{
   shader:       Shader, -- Material shader
   maps:   MaterialMap*, -- Material maps array (MAX_MATERIAL_MAPS)
   params:     float32*  -- Material generic parameters (if required)
}
## Material.value.is_material = true

-- Transformation properties
global Transform <cimport, nodecl> = @record{
   translation:    Vector3, -- Translation
   rotation:    Quaternion, -- Rotation
   scale:          Vector3  -- Scale
}
## Transform.value.is_transform = true

-- Bone information
global BoneInfo <cimport, nodecl> = @record{
   name:   cchar[32], -- Bone name
   parent:      cint  -- Bone parent
}
## BoneInfo.value.is_bone_info = true

-- Model type
global Model <cimport, nodecl> = @record{
   transform:        Matrix, -- Local transform matrix

   meshCount:          cint, -- Number of meshes
   meshes:            Mesh*, -- Meshes array

   materialCount:      cint, -- Number of materials
   materials:     Material*, -- Materials array
   meshMaterial:      cint*, -- Mesh material number

   -- Animation data
   boneCount:          cint, -- Number of bones
   bones:         BoneInfo*, -- Bones information (skeleton)
   bindPose:     Transform*  -- Bones base transformation (pose)
}
## Model.value.is_model = true

-- Model animation
global ModelAnimation <cimport, nodecl> = @record{
   boneCount:         cint, -- Number of bones
   bones:        BoneInfo*, -- Bones information (skeleton)

   frameCount:        cint, -- Number of animation frames
   framePoses: Transform**  -- Poses array by frame
}
## ModelAnimation.value.is_model_animation = true

-- Ray type (useful for raycast)
global Ray <cimport, nodecl> = @record{
   position:  Vector3, -- Ray position (origin)
   direction: Vector3  -- Ray direction
}
## Ray.value.is_ray = true

-- Raycast hit information
global RayHitInfo <cimport, nodecl> = @record{
   hit:      boolean, -- Did the ray hit something?
   distance: float32, -- Distance to nearest hit
   position: Vector3, -- Position of nearest hit
   normal:   Vector3  -- Surface normal of hit
}
## RayHitInfo.value.is_ray_hit_info = true

-- Bounding box type
global BoundingBox <cimport, nodecl> = @record{
   min: Vector3, -- Minimum vertex box-corner
   max: Vector3  -- Maximum vertex box-corner
}
## BoundingBox.value.is_bounding_box = true

-- Wave type, defines audio wave data
global Wave <cimport, nodecl> = @record{
   sampleCount:   cuint, -- Total number of samples
   sampleRate:    cuint, -- Frequency (samples per second)
   sampleSize:    cuint, -- Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels:      cuint, -- Number of channels (1-mono, 2-stereo)
   data:        pointer  -- Buffer data pointer
}
## Wave.value.is_wave = true

global rAudioBuffer <cimport, nodecl> = @record{}

-- Audio stream type
-- NOTE: Useful to create custom audio streams not bound to a specific file
global AudioStream <cimport, nodecl> = @record{
   sampleRate:         cuint, -- Frequency (samples per second)
   sampleSize:         cuint, -- Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels:           cuint, -- Number of channels (1-mono, 2-stereo)

   buffer:     rAudioBuffer*  -- Pointer to internal data used by the audio system
}
## AudioStream.value.is_audio_stream = true

-- Sound source type
global Sound <cimport, nodecl> = @record{
   sampleCount:       cuint, -- Total number of samples
   stream:      AudioStream  -- Audio stream
}
## Sound.value.is_sound = true

-- Music stream type (audio file streaming from memory)
-- NOTE: Anything longer than ~10 seconds should be streamed
global Music <cimport, nodecl> = @record{
   ctxType:            cint, -- Type of music context (audio filetype)
   ctxData:         pointer, -- Audio context data, depends on type

   sampleCount:       cuint, -- Total number of samples
   loopCount:         cuint, -- Loops count (times music will play), 0 means infinite loop

   stream:      AudioStream  -- Audio stream
}
## Music.value.is_music = true

-- Head-Mounted-Display device parameters
global VrDeviceInfo <cimport, nodecl> = @record{
   hResolution:                  cint, -- HMD horizontal resolution in pixels
   vResolution:                  cint, -- HMD vertical resolution in pixels
   hScreenSize:               float32, -- HMD horizontal size in meters
   vScreenSize:               float32, -- HMD vertical size in meters
   vScreenCenter:             float32, -- HMD screen center in meters
   eyeToScreenDistance:       float32, -- HMD distance between eye and display in meters
   lensSeparationDistance:    float32, -- HMD lens separation distance in meters
   interpupillaryDistance:    float32, -- HMD IPD (distance between pupils) in meters
   lensDistortionValues:   float32[4], -- HMD lens distortion constant parameters
   chromaAbCorrection:     float32[4]  -- HMD chromatic aberration correction parameters
}
## VrDeviceInfo.value.is_vr_device_info = true

-----------------------------------
-- import structs ]              --
-----------------------------------

-----------------------------------
-- import enums [                --
-----------------------------------

------------------------------------------------------------------------------------
-- Enumerators Definition
------------------------------------------------------------------------------------
-- System config flags
-- NOTE: Used for bit masks
local _ConfigFlag <cimport, nodecl> = @enum {
   FLAG_RESERVED           = 1,    -- Reserved
   FLAG_FULLSCREEN_MODE    = 2,    -- Set to run program in fullscreen
   FLAG_WINDOW_RESIZABLE   = 4,    -- Set to allow resizable window
   FLAG_WINDOW_UNDECORATED = 8,    -- Set to disable window decoration (frame and buttons)
   FLAG_WINDOW_TRANSPARENT = 16,   -- Set to allow transparent window
   FLAG_WINDOW_HIDDEN      = 128,  -- Set to create the window initially hidden
   FLAG_WINDOW_ALWAYS_RUN  = 256,  -- Set to allow windows running while minimized
   FLAG_MSAA_4X_HINT       = 32,   -- Set to try enabling MSAA 4X
   FLAG_VSYNC_HINT         = 64    -- Set to try enabling V-Sync on GPU
}

global ConfigFlag = @enum {
   RESERVED           = _ConfigFlag.FLAG_RESERVED           ,
   FULLSCREEN_MODE    = _ConfigFlag.FLAG_FULLSCREEN_MODE    ,
   WINDOW_RESIZABLE   = _ConfigFlag.FLAG_WINDOW_RESIZABLE   ,
   WINDOW_UNDECORATED = _ConfigFlag.FLAG_WINDOW_UNDECORATED ,
   WINDOW_TRANSPARENT = _ConfigFlag.FLAG_WINDOW_TRANSPARENT ,
   WINDOW_HIDDEN      = _ConfigFlag.FLAG_WINDOW_HIDDEN      ,
   WINDOW_ALWAYS_RUN  = _ConfigFlag.FLAG_WINDOW_ALWAYS_RUN  ,
   MSAA_4X_HINT       = _ConfigFlag.FLAG_MSAA_4X_HINT       ,
   VSYNC_HINT         = _ConfigFlag.FLAG_VSYNC_HINT
}

-- Trace log type
local _TraceLogType <cimport, nodecl> = @enum {
   LOG_ALL = 0,        -- Display all logs
   LOG_TRACE,
   LOG_DEBUG,
   LOG_INFO,
   LOG_WARNING,
   LOG_ERROR,
   LOG_FATAL,
   LOG_NONE            -- Disable logging
}

global TraceLogType = @enum {
   ALL     = _TraceLogType.LOG_ALL,
   TRACE   = _TraceLogType.LOG_TRACE,
   DEBUG   = _TraceLogType.LOG_DEBUG,
   INFO    = _TraceLogType.LOG_INFO,
   WARNING = _TraceLogType.LOG_WARNING,
   ERROR   = _TraceLogType.LOG_ERROR,
   FATAL   = _TraceLogType.LOG_FATAL,
   NONE    = _TraceLogType.LOG_NONE
}

-- Keyboard keys
local _KeyboardKey <cimport, nodecl> = @enum {
   -- Alphanumeric keys
   KEY_APOSTROPHE      = 39,
   KEY_COMMA           = 44,
   KEY_MINUS           = 45,
   KEY_PERIOD          = 46,
   KEY_SLASH           = 47,
   KEY_ZERO            = 48,
   KEY_ONE             = 49,
   KEY_TWO             = 50,
   KEY_THREE           = 51,
   KEY_FOUR            = 52,
   KEY_FIVE            = 53,
   KEY_SIX             = 54,
   KEY_SEVEN           = 55,
   KEY_EIGHT           = 56,
   KEY_NINE            = 57,
   KEY_SEMICOLON       = 59,
   KEY_EQUAL           = 61,
   KEY_A               = 65,
   KEY_B               = 66,
   KEY_C               = 67,
   KEY_D               = 68,
   KEY_E               = 69,
   KEY_F               = 70,
   KEY_G               = 71,
   KEY_H               = 72,
   KEY_I               = 73,
   KEY_J               = 74,
   KEY_K               = 75,
   KEY_L               = 76,
   KEY_M               = 77,
   KEY_N               = 78,
   KEY_O               = 79,
   KEY_P               = 80,
   KEY_Q               = 81,
   KEY_R               = 82,
   KEY_S               = 83,
   KEY_T               = 84,
   KEY_U               = 85,
   KEY_V               = 86,
   KEY_W               = 87,
   KEY_X               = 88,
   KEY_Y               = 89,
   KEY_Z               = 90,

   -- Function keys
   KEY_SPACE           = 32,
   KEY_ESCAPE          = 256,
   KEY_ENTER           = 257,
   KEY_TAB             = 258,
   KEY_BACKSPACE       = 259,
   KEY_INSERT          = 260,
   KEY_DELETE          = 261,
   KEY_RIGHT           = 262,
   KEY_LEFT            = 263,
   KEY_DOWN            = 264,
   KEY_UP              = 265,
   KEY_PAGE_UP         = 266,
   KEY_PAGE_DOWN       = 267,
   KEY_HOME            = 268,
   KEY_END             = 269,
   KEY_CAPS_LOCK       = 280,
   KEY_SCROLL_LOCK     = 281,
   KEY_NUM_LOCK        = 282,
   KEY_PRINT_SCREEN    = 283,
   KEY_PAUSE           = 284,
   KEY_F1              = 290,
   KEY_F2              = 291,
   KEY_F3              = 292,
   KEY_F4              = 293,
   KEY_F5              = 294,
   KEY_F6              = 295,
   KEY_F7              = 296,
   KEY_F8              = 297,
   KEY_F9              = 298,
   KEY_F10             = 299,
   KEY_F11             = 300,
   KEY_F12             = 301,
   KEY_LEFT_SHIFT      = 340,
   KEY_LEFT_CONTROL    = 341,
   KEY_LEFT_ALT        = 342,
   KEY_LEFT_SUPER      = 343,
   KEY_RIGHT_SHIFT     = 344,
   KEY_RIGHT_CONTROL   = 345,
   KEY_RIGHT_ALT       = 346,
   KEY_RIGHT_SUPER     = 347,
   KEY_KB_MENU         = 348,
   KEY_LEFT_BRACKET    = 91,
   KEY_BACKSLASH       = 92,
   KEY_RIGHT_BRACKET   = 93,
   KEY_GRAVE           = 96,

   -- Keypad keys
   KEY_KP_0            = 320,
   KEY_KP_1            = 321,
   KEY_KP_2            = 322,
   KEY_KP_3            = 323,
   KEY_KP_4            = 324,
   KEY_KP_5            = 325,
   KEY_KP_6            = 326,
   KEY_KP_7            = 327,
   KEY_KP_8            = 328,
   KEY_KP_9            = 329,
   KEY_KP_DECIMAL      = 330,
   KEY_KP_DIVIDE       = 331,
   KEY_KP_MULTIPLY     = 332,
   KEY_KP_SUBTRACT     = 333,
   KEY_KP_ADD          = 334,
   KEY_KP_ENTER        = 335,
   KEY_KP_EQUAL        = 336
}

global KeyboardKey = @enum {
   -- Alphanumeric keys
   APOSTROPHE       = _KeyboardKey.KEY_APOSTROPHE,
   COMMA            = _KeyboardKey.KEY_COMMA,
   MINUS            = _KeyboardKey.KEY_MINUS,
   PERIOD           = _KeyboardKey.KEY_PERIOD,
   SLASH            = _KeyboardKey.KEY_SLASH,
   ZERO             = _KeyboardKey.KEY_ZERO,
   ONE              = _KeyboardKey.KEY_ONE,
   TWO              = _KeyboardKey.KEY_TWO,
   THREE            = _KeyboardKey.KEY_THREE,
   FOUR             = _KeyboardKey.KEY_FOUR,
   FIVE             = _KeyboardKey.KEY_FIVE,
   SIX              = _KeyboardKey.KEY_SIX,
   SEVEN            = _KeyboardKey.KEY_SEVEN,
   EIGHT            = _KeyboardKey.KEY_EIGHT,
   NINE             = _KeyboardKey.KEY_NINE,
   SEMICOLON        = _KeyboardKey.KEY_SEMICOLON,
   EQUAL            = _KeyboardKey.KEY_EQUAL,
   A                = _KeyboardKey.KEY_A,
   B                = _KeyboardKey.KEY_B,
   C                = _KeyboardKey.KEY_C,
   D                = _KeyboardKey.KEY_D,
   E                = _KeyboardKey.KEY_E,
   F                = _KeyboardKey.KEY_F,
   G                = _KeyboardKey.KEY_G,
   H                = _KeyboardKey.KEY_H,
   I                = _KeyboardKey.KEY_I,
   J                = _KeyboardKey.KEY_J,
   K                = _KeyboardKey.KEY_K,
   L                = _KeyboardKey.KEY_L,
   M                = _KeyboardKey.KEY_M,
   N                = _KeyboardKey.KEY_N,
   O                = _KeyboardKey.KEY_O,
   P                = _KeyboardKey.KEY_P,
   Q                = _KeyboardKey.KEY_Q,
   R                = _KeyboardKey.KEY_R,
   S                = _KeyboardKey.KEY_S,
   T                = _KeyboardKey.KEY_T,
   U                = _KeyboardKey.KEY_U,
   V                = _KeyboardKey.KEY_V,
   W                = _KeyboardKey.KEY_W,
   X                = _KeyboardKey.KEY_X,
   Y                = _KeyboardKey.KEY_Y,
   Z                = _KeyboardKey.KEY_Z,

   -- Function keys
   SPACE            = _KeyboardKey.KEY_SPACE,
   ESCAPE           = _KeyboardKey.KEY_ESCAPE,
   ENTER            = _KeyboardKey.KEY_ENTER,
   TAB              = _KeyboardKey.KEY_TAB,
   BACKSPACE        = _KeyboardKey.KEY_BACKSPACE,
   INSERT           = _KeyboardKey.KEY_INSERT,
   DELETE           = _KeyboardKey.KEY_DELETE,
   RIGHT            = _KeyboardKey.KEY_RIGHT,
   LEFT             = _KeyboardKey.KEY_LEFT,
   DOWN             = _KeyboardKey.KEY_DOWN,
   UP               = _KeyboardKey.KEY_UP,
   PAGE_UP          = _KeyboardKey.KEY_PAGE_UP,
   PAGE_DOWN        = _KeyboardKey.KEY_PAGE_DOWN,
   HOME             = _KeyboardKey.KEY_HOME,
   END              = _KeyboardKey.KEY_END,
   CAPS_LOCK        = _KeyboardKey.KEY_CAPS_LOCK,
   SCROLL_LOCK      = _KeyboardKey.KEY_SCROLL_LOCK,
   NUM_LOCK         = _KeyboardKey.KEY_NUM_LOCK,
   PRINT_SCREEN     = _KeyboardKey.KEY_PRINT_SCREEN,
   PAUSE            = _KeyboardKey.KEY_PAUSE,
   F1               = _KeyboardKey.KEY_F1,
   F2               = _KeyboardKey.KEY_F2,
   F3               = _KeyboardKey.KEY_F3,
   F4               = _KeyboardKey.KEY_F4,
   F5               = _KeyboardKey.KEY_F5,
   F6               = _KeyboardKey.KEY_F6,
   F7               = _KeyboardKey.KEY_F7,
   F8               = _KeyboardKey.KEY_F8,
   F9               = _KeyboardKey.KEY_F9,
   F10              = _KeyboardKey.KEY_F10,
   F11              = _KeyboardKey.KEY_F11,
   F12              = _KeyboardKey.KEY_F12,
   LEFT_SHIFT       = _KeyboardKey.KEY_LEFT_SHIFT,
   LEFT_CONTROL     = _KeyboardKey.KEY_LEFT_CONTROL,
   LEFT_ALT         = _KeyboardKey.KEY_LEFT_ALT,
   LEFT_SUPER       = _KeyboardKey.KEY_LEFT_SUPER,
   RIGHT_SHIFT      = _KeyboardKey.KEY_RIGHT_SHIFT,
   RIGHT_CONTROL    = _KeyboardKey.KEY_RIGHT_CONTROL,
   RIGHT_ALT        = _KeyboardKey.KEY_RIGHT_ALT,
   RIGHT_SUPER      = _KeyboardKey.KEY_RIGHT_SUPER,
   KB_MENU          = _KeyboardKey.KEY_KB_MENU,
   LEFT_BRACKET     = _KeyboardKey.KEY_LEFT_BRACKET,
   BACKSLASH        = _KeyboardKey.KEY_BACKSLASH,
   RIGHT_BRACKET    = _KeyboardKey.KEY_RIGHT_BRACKET,
   GRAVE            = _KeyboardKey.KEY_GRAVE,

   -- Keypad keys
   KP_0             = _KeyboardKey.KEY_KP_0,
   KP_1             = _KeyboardKey.KEY_KP_1,
   KP_2             = _KeyboardKey.KEY_KP_2,
   KP_3             = _KeyboardKey.KEY_KP_3,
   KP_4             = _KeyboardKey.KEY_KP_4,
   KP_5             = _KeyboardKey.KEY_KP_5,
   KP_6             = _KeyboardKey.KEY_KP_6,
   KP_7             = _KeyboardKey.KEY_KP_7,
   KP_8             = _KeyboardKey.KEY_KP_8,
   KP_9             = _KeyboardKey.KEY_KP_9,
   KP_DECIMAL       = _KeyboardKey.KEY_KP_DECIMAL,
   KP_DIVIDE        = _KeyboardKey.KEY_KP_DIVIDE,
   KP_MULTIPLY      = _KeyboardKey.KEY_KP_MULTIPLY,
   KP_SUBTRACT      = _KeyboardKey.KEY_KP_SUBTRACT,
   KP_ADD           = _KeyboardKey.KEY_KP_ADD,
   KP_ENTER         = _KeyboardKey.KEY_KP_ENTER,
   KP_EQUAL         = _KeyboardKey.KEY_KP_EQUAL
}

-- Android buttons
local _AndroidButton <cimport, nodecl> = @enum {
   KEY_BACK            = 4,
   KEY_MENU            = 82,
   KEY_VOLUME_UP       = 24,
   KEY_VOLUME_DOWN     = 25
}

global AndroidButton = @enum {
   BACK            = _AndroidButton.KEY_BACK,
   MENU            = _AndroidButton.KEY_MENU,
   VOLUME_UP       = _AndroidButton.KEY_VOLUME_UP,
   VOLUME_DOWN     = _AndroidButton.KEY_VOLUME_DOWN
}

-- Mouse buttons
local _MouseButton <cimport, nodecl> = @enum {
   MOUSE_LEFT_BUTTON   = 0,
   MOUSE_RIGHT_BUTTON  = 1,
   MOUSE_MIDDLE_BUTTON = 2
}

global MouseButton = @enum {
   LEFT_BUTTON   = _MouseButton.MOUSE_LEFT_BUTTON,
   RIGHT_BUTTON  = _MouseButton.MOUSE_RIGHT_BUTTON,
   MIDDLE_BUTTON = _MouseButton.MOUSE_MIDDLE_BUTTON
}

-- Gamepad number
local _GamepadNumber <cimport, nodecl> = @enum {
   GAMEPAD_PLAYER1     = 0,
   GAMEPAD_PLAYER2     = 1,
   GAMEPAD_PLAYER3     = 2,
   GAMEPAD_PLAYER4     = 3
}

global GamepadNumber = @enum {
   PLAYER1 = _GamepadNumber.GAMEPAD_PLAYER1,
   PLAYER2 = _GamepadNumber.GAMEPAD_PLAYER2,
   PLAYER3 = _GamepadNumber.GAMEPAD_PLAYER3,
   PLAYER4 = _GamepadNumber.GAMEPAD_PLAYER4
}

-- Gamepad Buttons
local _GamepadButton <cimport, nodecl> = @enum {
   -- This is here just for error checking
   GAMEPAD_BUTTON_UNKNOWN = 0,

   -- This is normally a DPAD
   GAMEPAD_BUTTON_LEFT_FACE_UP,
   GAMEPAD_BUTTON_LEFT_FACE_RIGHT,
   GAMEPAD_BUTTON_LEFT_FACE_DOWN,
   GAMEPAD_BUTTON_LEFT_FACE_LEFT,

   -- This normally corresponds with PlayStation and Xbox controllers
   -- XBOX: [Y,X,A,B]
   -- PS3: [Triangle,Square,Cross,Circle]
   -- No support for 6 button controllers though..
   GAMEPAD_BUTTON_RIGHT_FACE_UP,
   GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,
   GAMEPAD_BUTTON_RIGHT_FACE_DOWN,
   GAMEPAD_BUTTON_RIGHT_FACE_LEFT,

   -- Triggers
   GAMEPAD_BUTTON_LEFT_TRIGGER_1,
   GAMEPAD_BUTTON_LEFT_TRIGGER_2,
   GAMEPAD_BUTTON_RIGHT_TRIGGER_1,
   GAMEPAD_BUTTON_RIGHT_TRIGGER_2,

   -- These are buttons in the center of the gamepad
   GAMEPAD_BUTTON_MIDDLE_LEFT,     --PS3 Select
   GAMEPAD_BUTTON_MIDDLE,          --PS Button/XBOX Button
   GAMEPAD_BUTTON_MIDDLE_RIGHT,    --PS3 Start

   -- These are the joystick press in buttons
   GAMEPAD_BUTTON_LEFT_THUMB,
   GAMEPAD_BUTTON_RIGHT_THUMB
}

global GamepadButton = @enum {
   UNKNOWN = _GamepadButton.GAMEPAD_BUTTON_UNKNOWN,

   LEFT_FACE_UP    = _GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_UP,
   LEFT_FACE_RIGHT = _GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_RIGHT,
   LEFT_FACE_DOWN  = _GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_DOWN,
   LEFT_FACE_LEFT  = _GamepadButton.GAMEPAD_BUTTON_LEFT_FACE_LEFT,

   RIGHT_FACE_UP    = _GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_UP,
   RIGHT_FACE_RIGHT = _GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,
   RIGHT_FACE_DOWN  = _GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_DOWN,
   RIGHT_FACE_LEFT  = _GamepadButton.GAMEPAD_BUTTON_RIGHT_FACE_LEFT,

   LEFT_TRIGGER_1  = _GamepadButton.GAMEPAD_BUTTON_LEFT_TRIGGER_1,
   LEFT_TRIGGER_2  = _GamepadButton.GAMEPAD_BUTTON_LEFT_TRIGGER_2,
   RIGHT_TRIGGER_1 = _GamepadButton.GAMEPAD_BUTTON_RIGHT_TRIGGER_1,
   RIGHT_TRIGGER_2 = _GamepadButton.GAMEPAD_BUTTON_RIGHT_TRIGGER_2,

   MIDDLE_LEFT  = _GamepadButton.GAMEPAD_BUTTON_MIDDLE_LEFT,
   MIDDLE       = _GamepadButton.GAMEPAD_BUTTON_MIDDLE,
   MIDDLE_RIGHT = _GamepadButton.GAMEPAD_BUTTON_MIDDLE_RIGHT,

   LEFT_THUMB  = _GamepadButton.GAMEPAD_BUTTON_LEFT_THUMB,
   RIGHT_THUMB = _GamepadButton.GAMEPAD_BUTTON_RIGHT_THUMB
}

local _GamepadAxis <cimport, nodecl> = @enum {
   -- This is here just for error checking
   GAMEPAD_AXIS_UNKNOWN = 0,

   -- Left stick
   GAMEPAD_AXIS_LEFT_X,
   GAMEPAD_AXIS_LEFT_Y,

   -- Right stick
   GAMEPAD_AXIS_RIGHT_X,
   GAMEPAD_AXIS_RIGHT_Y,

   -- Pressure levels for the back triggers
   GAMEPAD_AXIS_LEFT_TRIGGER,      -- [1..-1] (pressure-level)
   GAMEPAD_AXIS_RIGHT_TRIGGER      -- [1..-1] (pressure-level)
}

global GamepadAxis = @enum {
   -- This is here just for error checking
   UNKNOWN = _GamepadAxis.GAMEPAD_AXIS_UNKNOWN,

   -- Left stick
   LEFT_X = _GamepadAxis.GAMEPAD_AXIS_LEFT_X,
   LEFT_Y = _GamepadAxis.GAMEPAD_AXIS_LEFT_Y,

   -- Right stick
   RIGHT_X = _GamepadAxis.GAMEPAD_AXIS_RIGHT_X,
   RIGHT_Y = _GamepadAxis.GAMEPAD_AXIS_RIGHT_Y,

   -- Pressure levels for the back triggers
   LEFT_TRIGGER  = _GamepadAxis.GAMEPAD_AXIS_LEFT_TRIGGER, -- [1..-1] (pressure-level)
   RIGHT_TRIGGER = _GamepadAxis.GAMEPAD_AXIS_RIGHT_TRIGGER -- [1..-1] (pressure-level)
}

-- Shader location point type
local _ShaderLocationIndex <cimport, nodecl> = @enum {
   LOC_VERTEX_POSITION = 0,
   LOC_VERTEX_TEXCOORD01,
   LOC_VERTEX_TEXCOORD02,
   LOC_VERTEX_NORMAL,
   LOC_VERTEX_TANGENT,
   LOC_VERTEX_COLOR,
   LOC_MATRIX_MVP,
   LOC_MATRIX_MODEL,
   LOC_MATRIX_VIEW,
   LOC_MATRIX_PROJECTION,
   LOC_VECTOR_VIEW,
   LOC_COLOR_DIFFUSE,
   LOC_COLOR_SPECULAR,
   LOC_COLOR_AMBIENT,
   LOC_MAP_ALBEDO,          -- LOC_MAP_DIFFUSE
   LOC_MAP_METALNESS,       -- LOC_MAP_SPECULAR
   LOC_MAP_NORMAL,
   LOC_MAP_ROUGHNESS,
   LOC_MAP_OCCLUSION,
   LOC_MAP_EMISSION,
   LOC_MAP_HEIGHT,
   LOC_MAP_CUBEMAP,
   LOC_MAP_IRRADIANCE,
   LOC_MAP_PREFILTER,
   LOC_MAP_BRDF
}

global ShaderLocationIndex = @enum {
   VERTEX_POSITION   = _ShaderLocationIndex.LOC_VERTEX_POSITION,
   VERTEX_TEXCOORD01 = _ShaderLocationIndex.LOC_VERTEX_TEXCOORD01,
   VERTEX_TEXCOORD02 = _ShaderLocationIndex.LOC_VERTEX_TEXCOORD02,
   VERTEX_NORMAL     = _ShaderLocationIndex.LOC_VERTEX_NORMAL,
   VERTEX_TANGENT    = _ShaderLocationIndex.LOC_VERTEX_TANGENT,
   VERTEX_COLOR      = _ShaderLocationIndex.LOC_VERTEX_COLOR,
   MATRIX_MVP        = _ShaderLocationIndex.LOC_MATRIX_MVP,
   MATRIX_MODEL      = _ShaderLocationIndex.LOC_MATRIX_MODEL,
   MATRIX_VIEW       = _ShaderLocationIndex.LOC_MATRIX_VIEW,
   MATRIX_PROJECTION = _ShaderLocationIndex.LOC_MATRIX_PROJECTION,
   VECTOR_VIEW       = _ShaderLocationIndex.LOC_VECTOR_VIEW,
   COLOR_DIFFUSE     = _ShaderLocationIndex.LOC_COLOR_DIFFUSE,
   COLOR_SPECULAR    = _ShaderLocationIndex.LOC_COLOR_SPECULAR,
   COLOR_AMBIENT     = _ShaderLocationIndex.LOC_COLOR_AMBIENT,
   MAP_ALBEDO        = _ShaderLocationIndex.LOC_MAP_ALBEDO,
   MAP_METALNESS     = _ShaderLocationIndex.LOC_MAP_METALNESS,
   MAP_NORMAL        = _ShaderLocationIndex.LOC_MAP_NORMAL,
   MAP_ROUGHNESS     = _ShaderLocationIndex.LOC_MAP_ROUGHNESS,
   MAP_OCCLUSION     = _ShaderLocationIndex.LOC_MAP_OCCLUSION,
   MAP_EMISSION      = _ShaderLocationIndex.LOC_MAP_EMISSION,
   MAP_HEIGHT        = _ShaderLocationIndex.LOC_MAP_HEIGHT,
   MAP_CUBEMAP       = _ShaderLocationIndex.LOC_MAP_CUBEMAP,
   MAP_IRRADIANCE    = _ShaderLocationIndex.LOC_MAP_IRRADIANCE,
   MAP_PREFILTER     = _ShaderLocationIndex.LOC_MAP_PREFILTER,
   MAP_BRDF          = _ShaderLocationIndex.LOC_MAP_BRDF
}

-- TODO: define these
-- #define LOC_MAP_DIFFUSE      LOC_MAP_ALBEDO
-- #define LOC_MAP_SPECULAR     LOC_MAP_METALNESS

-- Shader uniform data types
local _ShaderUniformDataType <cimport, nodecl> = @enum {
   UNIFORM_FLOAT = 0,
   UNIFORM_VEC2,
   UNIFORM_VEC3,
   UNIFORM_VEC4,
   UNIFORM_INT,
   UNIFORM_IVEC2,
   UNIFORM_IVEC3,
   UNIFORM_IVEC4,
   UNIFORM_SAMPLER2D
}

global ShaderUniformDataType = @enum {
   FLOAT     = _ShaderUniformDataType.UNIFORM_FLOAT,
   VEC2      = _ShaderUniformDataType.UNIFORM_VEC2,
   VEC3      = _ShaderUniformDataType.UNIFORM_VEC3,
   VEC4      = _ShaderUniformDataType.UNIFORM_VEC4,
   INT       = _ShaderUniformDataType.UNIFORM_INT,
   IVEC2     = _ShaderUniformDataType.UNIFORM_IVEC2,
   IVEC3     = _ShaderUniformDataType.UNIFORM_IVEC3,
   IVEC4     = _ShaderUniformDataType.UNIFORM_IVEC4,
   SAMPLER2D = _ShaderUniformDataType.UNIFORM_SAMPLER2D
}

-- Material map type
local _MaterialMapType <cimport, nodecl> = @enum {
   MAP_ALBEDO    = 0,       -- MAP_DIFFUSE
   MAP_METALNESS = 1,       -- MAP_SPECULAR
   MAP_NORMAL    = 2,
   MAP_ROUGHNESS = 3,
   MAP_OCCLUSION,
   MAP_EMISSION,
   MAP_HEIGHT,
   MAP_CUBEMAP,             -- NOTE: Uses GL_TEXTURE_CUBE_MAP
   MAP_IRRADIANCE,          -- NOTE: Uses GL_TEXTURE_CUBE_MAP
   MAP_PREFILTER,           -- NOTE: Uses GL_TEXTURE_CUBE_MAP
   MAP_BRDF
}

global MaterialMapType = @enum {
   ALBEDO     = _MaterialMapType.MAP_ALBEDO,
   METALNESS  = _MaterialMapType.MAP_METALNESS,
   NORMAL     = _MaterialMapType.MAP_NORMAL,
   ROUGHNESS  = _MaterialMapType.MAP_ROUGHNESS,
   OCCLUSION  = _MaterialMapType.MAP_OCCLUSION,
   EMISSION   = _MaterialMapType.MAP_EMISSION,
   HEIGHT     = _MaterialMapType.MAP_HEIGHT,
   CUBEMAP    = _MaterialMapType.MAP_CUBEMAP,
   IRRADIANCE = _MaterialMapType.MAP_IRRADIANCE,
   PREFILTER  = _MaterialMapType.MAP_PREFILTER,
   BRDF       = _MaterialMapType.MAP_BRDF
}

-- TODO: define these
-- #define MAP_DIFFUSE      MAP_ALBEDO
-- #define MAP_SPECULAR     MAP_METALNESS

-- Pixel formats
-- NOTE: Support depends on OpenGL version and platform
global PixelFormat <cimport, nodecl> = @enum {
   UNCOMPRESSED_GRAYSCALE = 1,     -- 8 bit per pixel (no alpha)
   UNCOMPRESSED_GRAY_ALPHA,        -- 8*2 bpp (2 channels)
   UNCOMPRESSED_R5G6B5,            -- 16 bpp
   UNCOMPRESSED_R8G8B8,            -- 24 bpp
   UNCOMPRESSED_R5G5B5A1,          -- 16 bpp (1 bit alpha)
   UNCOMPRESSED_R4G4B4A4,          -- 16 bpp (4 bit alpha)
   UNCOMPRESSED_R8G8B8A8,          -- 32 bpp
   UNCOMPRESSED_R32,               -- 32 bpp (1 channel - float)
   UNCOMPRESSED_R32G32B32,         -- 32*3 bpp (3 channels - float)
   UNCOMPRESSED_R32G32B32A32,      -- 32*4 bpp (4 channels - float)
   COMPRESSED_DXT1_RGB,            -- 4 bpp (no alpha)
   COMPRESSED_DXT1_RGBA,           -- 4 bpp (1 bit alpha)
   COMPRESSED_DXT3_RGBA,           -- 8 bpp
   COMPRESSED_DXT5_RGBA,           -- 8 bpp
   COMPRESSED_ETC1_RGB,            -- 4 bpp
   COMPRESSED_ETC2_RGB,            -- 4 bpp
   COMPRESSED_ETC2_EAC_RGBA,       -- 8 bpp
   COMPRESSED_PVRT_RGB,            -- 4 bpp
   COMPRESSED_PVRT_RGBA,           -- 4 bpp
   COMPRESSED_ASTC_4x4_RGBA,       -- 8 bpp
   COMPRESSED_ASTC_8x8_RGBA        -- 2 bpp
}

-- Texture parameters: filter mode
-- NOTE 1: Filtering considers mipmaps if available in the texture
-- NOTE 2: Filter is accordingly set for minification and magnification
local _TextureFilterMode <cimport, nodecl> = @enum {
   FILTER_POINT = 0,               -- No filter, just pixel aproximation
   FILTER_BILINEAR,                -- Linear filtering
   FILTER_TRILINEAR,               -- Trilinear filtering (linear with mipmaps)
   FILTER_ANISOTROPIC_4X,          -- Anisotropic filtering 4x
   FILTER_ANISOTROPIC_8X,          -- Anisotropic filtering 8x
   FILTER_ANISOTROPIC_16X,         -- Anisotropic filtering 16x
}

global TextureFilterMode = @enum {
   POINT           =  _TextureFilterMode.FILTER_POINT,
   BILINEAR        =  _TextureFilterMode.FILTER_BILINEAR,
   TRILINEAR       =  _TextureFilterMode.FILTER_TRILINEAR,
   ANISOTROPIC_4X  =  _TextureFilterMode.FILTER_ANISOTROPIC_4X,
   ANISOTROPIC_8X  =  _TextureFilterMode.FILTER_ANISOTROPIC_8X,
   ANISOTROPIC_16X =  _TextureFilterMode.FILTER_ANISOTROPIC_16X,
}

-- Cubemap layout type
local _CubemapLayoutType <cimport, nodecl> = @enum {
   CUBEMAP_AUTO_DETECT = 0,        -- Automatically detect layout type
   CUBEMAP_LINE_VERTICAL,          -- Layout is defined by a vertical line with faces
   CUBEMAP_LINE_HORIZONTAL,        -- Layout is defined by an horizontal line with faces
   CUBEMAP_CROSS_THREE_BY_FOUR,    -- Layout is defined by a 3x4 cross with cubemap faces
   CUBEMAP_CROSS_FOUR_BY_THREE,    -- Layout is defined by a 4x3 cross with cubemap faces
   CUBEMAP_PANORAMA                -- Layout is defined by a panorama image (equirectangular map)
}

global CubemapLayoutType = @enum {
   AUTO_DETECT          = _CubemapLayoutType.CUBEMAP_AUTO_DETECT,
   LINE_VERTICAL        = _CubemapLayoutType.CUBEMAP_LINE_VERTICAL,
   LINE_HORIZONTAL      = _CubemapLayoutType.CUBEMAP_LINE_HORIZONTAL,
   CROSS_THREE_BY_FOUR  = _CubemapLayoutType.CUBEMAP_CROSS_THREE_BY_FOUR,
   CROSS_FOUR_BY_THREE  = _CubemapLayoutType.CUBEMAP_CROSS_FOUR_BY_THREE,
   PANORAMA             = _CubemapLayoutType.CUBEMAP_PANORAMA
}

-- Texture parameters: wrap mode
local _TextureWrapMode <cimport, nodecl> = @enum {
   WRAP_REPEAT = 0,        -- Repeats texture in tiled mode
   WRAP_CLAMP,             -- Clamps texture to edge pixel in tiled mode
   WRAP_MIRROR_REPEAT,     -- Mirrors and repeats the texture in tiled mode
   WRAP_MIRROR_CLAMP       -- Mirrors and clamps to border the texture in tiled mode
}

global TextureWrapMode = @enum {
   REPEAT        = _TextureWrapMode.WRAP_REPEAT,
   CLAMP         = _TextureWrapMode.WRAP_CLAMP,
   MIRROR_REPEAT = _TextureWrapMode.WRAP_MIRROR_REPEAT,
   MIRROR_CLAMP  = _TextureWrapMode.WRAP_MIRROR_CLAMP
}

-- Font type, defines generation method
local _FontType <cimport, nodecl> = @enum {
   FONT_DEFAULT = 0,       -- Default font generation, anti-aliased
   FONT_BITMAP,            -- Bitmap font generation, no anti-aliasing
   FONT_SDF                -- SDF font generation, requires external shader
}

global FontType = @enum {
   DEFAULT = _FontType.FONT_DEFAULT,
   BITMAP  = _FontType.FONT_BITMAP,
   SDF     = _FontType.FONT_SDF
}

-- Color blending modes (pre-defined)
local _BlendMode <cimport, nodecl> = @enum {
   BLEND_ALPHA = 0,        -- Blend textures considering alpha (default)
   BLEND_ADDITIVE,         -- Blend textures adding colors
   BLEND_MULTIPLIED        -- Blend textures multiplying colors
}

global BlendMode = @enum {
   ALPHA      = _BlendMode.BLEND_ALPHA,
   ADDITIVE   = _BlendMode.BLEND_ADDITIVE,
   MULTIPLIED = _BlendMode.BLEND_MULTIPLIED
}

-- Gestures type
-- NOTE: It could be used as flags to enable only some gestures
local _GestureType <cimport, nodecl> = @enum {
   GESTURE_NONE        = 0,
   GESTURE_TAP         = 1,
   GESTURE_DOUBLETAP   = 2,
   GESTURE_HOLD        = 4,
   GESTURE_DRAG        = 8,
   GESTURE_SWIPE_RIGHT = 16,
   GESTURE_SWIPE_LEFT  = 32,
   GESTURE_SWIPE_UP    = 64,
   GESTURE_SWIPE_DOWN  = 128,
   GESTURE_PINCH_IN    = 256,
   GESTURE_PINCH_OUT   = 512
}

global GestureType = @enum {
   NONE         = _GestureType.GESTURE_NONE,
   TAP          = _GestureType.GESTURE_TAP,
   DOUBLETAP    = _GestureType.GESTURE_DOUBLETAP,
   HOLD         = _GestureType.GESTURE_HOLD,
   DRAG         = _GestureType.GESTURE_DRAG,
   SWIPE_RIGHT  = _GestureType.GESTURE_SWIPE_RIGHT,
   SWIPE_LEFT   = _GestureType.GESTURE_SWIPE_LEFT,
   SWIPE_UP     = _GestureType.GESTURE_SWIPE_UP,
   SWIPE_DOWN   = _GestureType.GESTURE_SWIPE_DOWN,
   PINCH_IN     = _GestureType.GESTURE_PINCH_IN,
   PINCH_OUT    = _GestureType.GESTURE_PINCH_OUT
}

-- Camera system modes
local _CameraMode <cimport, nodecl> = @enum {
   CAMERA_CUSTOM = 0,
   CAMERA_FREE,
   CAMERA_ORBITAL,
   CAMERA_FIRST_PERSON,
   CAMERA_THIRD_PERSON
}

global CameraMode = @enum {
   CUSTOM       = _CameraMode.CAMERA_CUSTOM,
   FREE         = _CameraMode.CAMERA_FREE,
   ORBITAL      = _CameraMode.CAMERA_ORBITAL,
   FIRST_PERSON = _CameraMode.CAMERA_FIRST_PERSON,
   THIRD_PERSON = _CameraMode.CAMERA_THIRD_PERSON
}

-- Camera projection modes
local _CameraType <cimport, nodecl> = @enum {
   CAMERA_PERSPECTIVE = 0,
   CAMERA_ORTHOGRAPHIC
}

global CameraType = @enum {
   PERSPECTIVE  = _CameraType.CAMERA_PERSPECTIVE,
   ORTHOGRAPHIC = _CameraType.CAMERA_ORTHOGRAPHIC
}

-- Type of n-patch
global NPatchType <cimport, nodecl> = @enum {
   NPT_9PATCH = 0,         -- Npatch defined by 3x3 tiles
   NPT_3PATCH_VERTICAL,    -- Npatch defined by 1x3 tiles
   NPT_3PATCH_HORIZONTAL   -- Npatch defined by 3x1 tiles
}

-----------------------------------
-- import enums ]                --
-----------------------------------

-- This is a callback, is used as parameter by "SetTraceLogCallback" (in core module)
-- since is used as parameter type, I decided to declare it as record
global TraceLogCallback <cimport, nodecl> = @record{}

-- import colors --[
local LIGHTGRAY:  Color <cimport, nodecl>; local GRAY:       Color <cimport, nodecl>
local DARKGRAY:   Color <cimport, nodecl>; local YELLOW:     Color <cimport, nodecl>
local GOLD:       Color <cimport, nodecl>; local ORANGE:     Color <cimport, nodecl>
local PINK:       Color <cimport, nodecl>; local RED:        Color <cimport, nodecl>
local MAROON:     Color <cimport, nodecl>; local GREEN:      Color <cimport, nodecl>
local LIME:       Color <cimport, nodecl>; local DARKGREEN:  Color <cimport, nodecl>
local SKYBLUE:    Color <cimport, nodecl>; local BLUE:       Color <cimport, nodecl>
local DARKBLUE:   Color <cimport, nodecl>; local PURPLE:     Color <cimport, nodecl>
local VIOLET:     Color <cimport, nodecl>; local DARKPURPLE: Color <cimport, nodecl>
local BEIGE:      Color <cimport, nodecl>; local BROWN:      Color <cimport, nodecl>
local DARKBROWN:  Color <cimport, nodecl>; local WHITE:      Color <cimport, nodecl>
local BLACK:      Color <cimport, nodecl>; local BLANK:      Color <cimport, nodecl>
local MAGENTA:    Color <cimport, nodecl>; local RAYWHITE:   Color <cimport, nodecl>

global RaylibColors: record {
   Lightgray: Color, Gray:     Color, Darkgray:  Color, Yellow: Color, Gold:   Color, Orange:     Color,
   Pink:      Color, Red:      Color, Maroon:    Color, Green:  Color, Lime:   Color, Darkgreen:  Color,
   Skyblue:   Color, Blue:     Color, Darkblue:  Color, Purple: Color, Violet: Color, Darkpurple: Color,
   Beige:     Color, Brown:    Color, Darkbrown: Color, White:  Color, Black:  Color, Blank:      Color,
   Magenta:   Color, Raywhite: Color
} = {
   LIGHTGRAY       , GRAY           , DARKGRAY        , YELLOW       , GOLD         , ORANGE           ,
   PINK            , RED            , MAROON          , GREEN        , LIME         , DARKGREEN        ,
   SKYBLUE         , BLUE           , DARKBLUE        , PURPLE       , VIOLET       , DARKPURPLE       ,
   BEIGE           , BROWN          , DARKBROWN       , WHITE        , BLACK        , BLANK            ,
   MAGENTA         , RAYWHITE
}
-- ]


------------------------------------------------------------------------------------------------------------------------
-- === RECORDS === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === CORE MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Window-related functions
function Raylib.InitWindow(width: cint <autocast>, height: cint <autocast>, title: cstring)                                     <cimport'InitWindow'                 , nodecl> end -- Initialize window and OpenGL context
function Raylib.WindowShouldClose(): boolean                                                                                    <cimport'WindowShouldClose'          , nodecl> end -- Check if KEY_ESCAPE pressed or Close icon pressed
function Raylib.CloseWindow()                                                                                                   <cimport'CloseWindow'                , nodecl> end -- Close window and unload OpenGL context
function Raylib.IsWindowReady(): boolean                                                                                        <cimport'IsWindowReady'              , nodecl> end -- Check if window has been initialized successfully
function Raylib.IsWindowMinimized(): boolean                                                                                    <cimport'IsWindowMinimized'          , nodecl> end -- Check if window has been minimized (or lost focus)
function Raylib.IsWindowResized(): boolean                                                                                      <cimport'IsWindowResized'            , nodecl> end -- Check if window has been resized
function Raylib.IsWindowHidden(): boolean                                                                                       <cimport'IsWindowHidden'             , nodecl> end -- Check if window is currently hidden
function Raylib.ToggleFullscreen()                                                                                              <cimport'ToggleFullscreen'           , nodecl> end -- Toggle fullscreen mode (only PLATFORM_DESKTOP)
function Raylib.UnhideWindow()                                                                                                  <cimport'UnhideWindow'               , nodecl> end -- Show the window
function Raylib.HideWindow()                                                                                                    <cimport'HideWindow'                 , nodecl> end -- Hide the window
function Raylib.SetWindowIcon(image: Image)                                                                                     <cimport'SetWindowIcon'              , nodecl> end -- Set icon for window (only PLATFORM_DESKTOP)
function Raylib.SetWindowTitle(title: cstring)                                                                                  <cimport'SetWindowTitle'             , nodecl> end -- Set title for window (only PLATFORM_DESKTOP)
function Raylib.SetWindowPosition(x: cint <autocast>, y: cint <autocast>)                                                       <cimport'SetWindowPosition'          , nodecl> end -- Set window position on screen (only PLATFORM_DESKTOP)
function Raylib.SetWindowMonitor(monitor: cint <autocast>)                                                                      <cimport'SetWindowMonitor'           , nodecl> end -- Set monitor for the current window (fullscreen mode)
function Raylib.SetWindowMinSize(width: cint <autocast>, height: cint <autocast>)                                               <cimport'SetWindowMinSize'           , nodecl> end -- Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
function Raylib.SetWindowSize(width: cint <autocast>, height: cint <autocast>)                                                  <cimport'SetWindowSize'              , nodecl> end -- Set window dimensions
function Raylib.GetWindowHandle(): pointer                                                                                      <cimport'GetWindowHandle'            , nodecl> end -- Get native window handle
function Raylib.GetScreenWidth(): cint                                                                                          <cimport'GetScreenWidth'             , nodecl> end -- Get current screen width
function Raylib.GetScreenHeight(): cint                                                                                         <cimport'GetScreenHeight'            , nodecl> end -- Get current screen height
function Raylib.GetMonitorCount(): cint                                                                                         <cimport'GetMonitorCount'            , nodecl> end -- Get number of connected monitors
function Raylib.GetMonitorWidth(monitor: cint <autocast>): cint                                                                 <cimport'GetMonitorWidth'            , nodecl> end -- Get primary monitor width
function Raylib.GetMonitorHeight(monitor: cint <autocast>): cint                                                                <cimport'GetMonitorHeight'           , nodecl> end -- Get primary monitor height
function Raylib.GetMonitorPhysicalWidth(monitor: cint <autocast>): cint                                                         <cimport'GetMonitorPhysicalWidth'    , nodecl> end -- Get primary monitor physical width in millimetres
function Raylib.GetMonitorPhysicalHeight(monitor: cint <autocast>): cint                                                        <cimport'GetMonitorPhysicalHeight'   , nodecl> end -- Get primary monitor physical height in millimetres
function Raylib.GetWindowPosition(): Vector2                                                                                    <cimport'GetWindowPosition'          , nodecl> end -- Get window position XY on monitor
function Raylib.GetMonitorName(monitor: cint <autocast>): cstring                                                               <cimport'GetMonitorName'             , nodecl> end -- Get the human-readable, UTF-8 encoded name of the primary monitor
function Raylib.GetClipboardText(): cstring                                                                                     <cimport'GetClipboardText'           , nodecl> end -- Get clipboard text content
function Raylib.SetClipboardText(text: cstring)                                                                                 <cimport'SetClipboardText'           , nodecl> end -- Set clipboard text content

-- Cursor-related functions
function Raylib.ShowCursor()                                                                                                    <cimport'ShowCursor'                 , nodecl> end -- Shows cursor
function Raylib.HideCursor()                                                                                                    <cimport'HideCursor'                 , nodecl> end -- Hides cursor
function Raylib.IsCursorHidden(): boolean                                                                                       <cimport'IsCursorHidden'             , nodecl> end -- Check if cursor is not visible
function Raylib.EnableCursor()                                                                                                  <cimport'EnableCursor'               , nodecl> end -- Enables cursor (unlock cursor)
function Raylib.DisableCursor()                                                                                                 <cimport'DisableCursor'              , nodecl> end -- Disables cursor (lock cursor)

-- Drawing-related functions
function Raylib.ClearBackground(color: Color)                                                                                   <cimport'ClearBackground'            , nodecl> end -- Set background color (framebuffer clear color)
function Raylib.BeginDrawing()                                                                                                  <cimport'BeginDrawing'               , nodecl> end -- Setup canvas (framebuffer) to start drawing
function Raylib.EndDrawing()                                                                                                    <cimport'EndDrawing'                 , nodecl> end -- End canvas drawing and swap buffers (double buffering)
function Raylib.BeginMode2D(camera: Camera2D)                                                                                   <cimport'BeginMode2D'                , nodecl> end -- Initialize 2D mode with custom camera (2D)
function Raylib.EndMode2D()                                                                                                     <cimport'EndMode2D'                  , nodecl> end -- Ends 2D mode with custom camera
function Raylib.BeginMode3D(camera: Camera3D)                                                                                   <cimport'BeginMode3D'                , nodecl> end -- Initializes 3D mode with custom camera (3D)
function Raylib.EndMode3D()                                                                                                     <cimport'EndMode3D'                  , nodecl> end -- Ends 3D mode and returns to default 2D orthographic mode
function Raylib.BeginTextureMode(target: RenderTexture2D)                                                                       <cimport'BeginTextureMode'           , nodecl> end -- Initializes render texture for drawing
function Raylib.EndTextureMode()                                                                                                <cimport'EndTextureMode'             , nodecl> end -- Ends drawing to render texture
function Raylib.BeginScissorMode(x: cint <autocast>, y: cint <autocast>, width: cint <autocast>, height: cint <autocast>)       <cimport'BeginScissorMode'           , nodecl> end -- Begin scissor mode (define screen area for following drawing)
function Raylib.EndScissorMode()                                                                                                <cimport'EndScissorMode'             , nodecl> end -- End scissor mode

-- Screen-space-related functions
function Raylib.GetMouseRay(mousePosition: Vector2, camera: Camera): Ray                                                        <cimport'GetMouseRay'                , nodecl> end -- Returns a ray trace from mouse position
function Raylib.GetCameraMatrix(camera: Camera): Matrix                                                                         <cimport'GetCameraMatrix'            , nodecl> end -- Returns camera transform matrix (view matrix)
function Raylib.GetCameraMatrix2D(camera: Camera2D): Matrix                                                                     <cimport'GetCameraMatrix2D'          , nodecl> end -- Returns camera 2d transform matrix
function Raylib.GetWorldToScreen(position: Vector3, camera: Camera): Vector2                                                    <cimport'GetWorldToScreen'           , nodecl> end -- Returns the screen space position for a 3d world space position
function Raylib.GetWorldToScreenEx(position: Vector3, camera: Camera, width: cint <autocast>, height: cint <autocast>): Vector2 <cimport'GetWorldToScreenEx'         , nodecl> end -- Returns size position for a 3d world space position
function Raylib.GetWorldToScreen2D(position: Vector2, camera: Camera2D): Vector2                                                <cimport'GetWorldToScreen2D'         , nodecl> end -- Returns the screen space position for a 2d camera world space position
function Raylib.GetScreenToWorld2D(position: Vector2, camera: Camera2D): Vector2                                                <cimport'GetScreenToWorld2D'         , nodecl> end -- Returns the world space position for a 2d camera screen space position

-- Timing-related functions
function Raylib.SetTargetFPS(fps: cint <autocast>)                                                                              <cimport'SetTargetFPS'               , nodecl> end -- Set target FPS (maximum)
function Raylib.GetFPS(): cint                                                                                                  <cimport'GetFPS'                     , nodecl> end -- Returns current FPS
function Raylib.GetFrameTime(): float32                                                                                         <cimport'GetFrameTime'               , nodecl> end -- Returns time in seconds for last frame drawn
function Raylib.GetTime(): float64                                                                                              <cimport'GetTime'                    , nodecl> end -- Returns elapsed time in seconds since InitWindow()

-- Color-related functions
function Raylib.ColorToInt(color: Color): cint                                                                                  <cimport'ColorToInt'                 , nodecl> end -- Returns hexadecimal value for a Color
function Raylib.ColorNormalize(color: Color): Vector4                                                                           <cimport'ColorNormalize'             , nodecl> end -- Returns color normalized as float [0..1]
function Raylib.ColorFromNormalized(normalized: Vector4): Color                                                                 <cimport'ColorFromNormalized'        , nodecl> end -- Returns color from normalized values [0..1]
function Raylib.ColorToHSV(color: Color): Vector3                                                                               <cimport'ColorToHSV'                 , nodecl> end -- Returns HSV values for a Color
function Raylib.ColorFromHSV(hsv: Vector3): Color                                                                               <cimport'ColorFromHSV'               , nodecl> end -- Returns a Color from HSV values
function Raylib.GetColor(hexValue: cint <autocast>): Color                                                                      <cimport'GetColor'                   , nodecl> end -- Returns a Color struct from hexadecimal value
function Raylib.Fade(color: Color, alpha: float32 <autocast>): Color                                                            <cimport'Fade'                       , nodecl> end -- Color fade-in or fade-out, alpha goes from 0.0f to 1.0f

-- Misc. functions
function Raylib.SetConfigFlags(flags: cuint )                                                                                   <cimport'SetConfigFlags'             , nodecl> end -- Setup window configuration flags (view FLAGS)
function Raylib.SetTraceLogLevel(logType: cint <autocast>)                                                                      <cimport'SetTraceLogLevel'           , nodecl> end -- Set the current threshold (minimum) log level
function Raylib.SetTraceLogExit(logType: cint <autocast>)                                                                       <cimport'SetTraceLogExit'            , nodecl> end -- Set the exit threshold (minimum) log level
function Raylib.SetTraceLogCallback(callback: TraceLogCallback)                                                                 <cimport'SetTraceLogCallback'        , nodecl> end -- Set a trace log callback to enable custom logging
function Raylib.TraceLog(logType: cint <autocast>, text: cstring, ...)                                                          <cimport'TraceLog'                   , nodecl> end -- Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR)
function Raylib.TakeScreenshot(fileName: cstring)                                                                               <cimport'TakeScreenshot'             , nodecl> end -- Takes a screenshot of current screen (saved a .png)
function Raylib.GetRandomValue(min: cint <autocast>, max: cint <autocast>): cint                                                <cimport'GetRandomValue'             , nodecl> end -- Returns a random value between min and max (both included)

-- Files management functions
function Raylib.FileExists(fileName: cstring): boolean                                                                          <cimport'FileExists'                 , nodecl> end -- Check if file exists
function Raylib.IsFileExtension(fileName: cstring, ext: cstring): boolean                                                       <cimport'IsFileExtension'            , nodecl> end -- Check file extension
function Raylib.DirectoryExists(dirPath: cstring): boolean                                                                      <cimport'DirectoryExists'            , nodecl> end -- Check if a directory path exists
function Raylib.GetExtension(fileName: cstring): cstring                                                                        <cimport'GetExtension'               , nodecl> end -- Get pointer to extension for a filename string
function Raylib.GetFileName(filePath: cstring): cstring                                                                         <cimport'GetFileName'                , nodecl> end -- Get pointer to filename for a path string
function Raylib.GetFileNameWithoutExt(filePath: cstring): cstring                                                               <cimport'GetFileNameWithoutExt'      , nodecl> end -- Get filename string without extension (uses static string)
function Raylib.GetDirectoryPath(filePath: cstring): cstring                                                                    <cimport'GetDirectoryPath'           , nodecl> end -- Get full path for a given fileName with path (uses static string)
function Raylib.GetPrevDirectoryPath(dirPath: cstring): cstring                                                                 <cimport'GetPrevDirectoryPath'       , nodecl> end -- Get previous directory path for a given path (uses static string)
function Raylib.GetWorkingDirectory(): cstring                                                                                  <cimport'GetWorkingDirectory'        , nodecl> end -- Get current working directory (uses static string)
function Raylib.GetDirectoryFiles(dirPath: cstring, count: cint*): cstring[0]*                                                  <cimport'GetDirectoryFiles'          , nodecl> end -- Get filenames in a directory path (memory should be freed)
function Raylib.ClearDirectoryFiles()                                                                                           <cimport'ClearDirectoryFiles'        , nodecl> end -- Clear directory files paths buffers (free memory)
function Raylib.ChangeDirectory(dir: cstring): boolean                                                                          <cimport'ChangeDirectory'            , nodecl> end -- Change working directory, returns true if success
function Raylib.IsFileDropped(): boolean                                                                                        <cimport'IsFileDropped'              , nodecl> end -- Check if a file has been dropped into window
function Raylib.GetDroppedFiles(count: cint*): cstring[0]*                                                                      <cimport'GetDroppedFiles'            , nodecl> end -- Get dropped files names (memory should be freed)
function Raylib.ClearDroppedFiles()                                                                                             <cimport'ClearDroppedFiles'          , nodecl> end -- Clear dropped files paths buffer (free memory)
function Raylib.GetFileModTime(fileName: cstring): clong                                                                        <cimport'GetFileModTime'             , nodecl> end -- Get file modification time (last write time)

function Raylib.CompressData(data: cuchar*, dataLength: cint <autocast>, compDataLength: cint*): cuchar*                        <cimport'CompressData'               , nodecl> end -- Compress data (DEFLATE algorythm)
function Raylib.DecompressData(compData: cuchar*, compDataLength: cint <autocast>, dataLength: cint*): cuchar*                  <cimport'DecompressData'             , nodecl> end -- Decompress data (DEFLATE algorythm)

-- Persistent storage management
function Raylib.StorageSaveValue(position: cint <autocast>, value: cint <autocast>)                                             <cimport'StorageSaveValue'           , nodecl> end -- Save integer value to storage file (to defined position)
function Raylib.StorageLoadValue(position: cint <autocast>): cint                                                               <cimport'StorageLoadValue'           , nodecl> end -- Load integer value from storage file (from defined position)

function Raylib.OpenURL(url: cstring)                                                                                           <cimport'OpenURL'                    , nodecl> end -- Open URL with default system browser (if available)

--------------------------------------------------------------------------------------
-- Input Handling Functions
--------------------------------------------------------------------------------------

-- Input-related functions: keyb
function Raylib.IsKeyPressed(key: cint <autocast>): boolean                                                                     <cimport'IsKeyPressed'               , nodecl> end -- Detect if a key has been pressed once
function Raylib.IsKeyDown(key: cint <autocast>): boolean                                                                        <cimport'IsKeyDown'                  , nodecl> end -- Detect if a key is being pressed
function Raylib.IsKeyReleased(key: cint <autocast>): boolean                                                                    <cimport'IsKeyReleased'              , nodecl> end -- Detect if a key has been released once
function Raylib.IsKeyUp(key: cint <autocast>): boolean                                                                          <cimport'IsKeyUp'                    , nodecl> end -- Detect if a key is NOT being pressed
function Raylib.GetKeyPressed(): cint                                                                                           <cimport'GetKeyPressed'              , nodecl> end -- Get latest key pressed
function Raylib.SetExitKey(key: cint <autocast>)                                                                                <cimport'SetExitKey'                 , nodecl> end -- Set a custom key to exit program (default is ESC)

-- Input-related functions: gamepads
function Raylib.IsGamepadAvailable(gamepad: cint <autocast>): boolean                                                           <cimport'IsGamepadAvailable'         , nodecl> end -- Detect if a gamepad is available
function Raylib.IsGamepadName(gamepad: cint <autocast>, name: cstring): boolean                                                 <cimport'IsGamepadName'              , nodecl> end -- Check gamepad name (if available)
function Raylib.GetGamepadName(gamepad: cint <autocast>): cstring                                                               <cimport'GetGamepadName'             , nodecl> end -- Return gamepad internal name id
function Raylib.IsGamepadButtonPressed(gamepad: cint <autocast>, button: cint <autocast>): boolean                              <cimport'IsGamepadButtonPressed'     , nodecl> end -- Detect if a gamepad button has been pressed once
function Raylib.IsGamepadButtonDown(gamepad: cint <autocast>, button: cint <autocast>): boolean                                 <cimport'IsGamepadButtonDown'        , nodecl> end -- Detect if a gamepad button is being pressed
function Raylib.IsGamepadButtonReleased(gamepad: cint <autocast>, button: cint <autocast>): boolean                             <cimport'IsGamepadButtonReleased'    , nodecl> end -- Detect if a gamepad button has been released once
function Raylib.IsGamepadButtonUp(gamepad: cint <autocast>, button: cint <autocast>): boolean                                   <cimport'IsGamepadButtonUp'          , nodecl> end -- Detect if a gamepad button is NOT being pressed
function Raylib.GetGamepadButtonPressed(): cint                                                                                 <cimport'GetGamepadButtonPressed'    , nodecl> end -- Get the last gamepad button pressed
function Raylib.GetGamepadAxisCount(gamepad: cint <autocast>): cint                                                             <cimport'GetGamepadAxisCount'        , nodecl> end -- Return gamepad axis count for a gamepad
function Raylib.GetGamepadAxisMovement(gamepad: cint <autocast>, axis: cint <autocast>): float32                                <cimport'GetGamepadAxisMovement'     , nodecl> end -- Return axis movement value for a gamepad axis

-- Input-related functions: mouse
function Raylib.IsMouseButtonPressed(button: cint <autocast>): boolean                                                          <cimport'IsMouseButtonPressed'       , nodecl> end -- Detect if a mouse button has been pressed once
function Raylib.IsMouseButtonDown(button: cint <autocast>): boolean                                                             <cimport'IsMouseButtonDown'          , nodecl> end -- Detect if a mouse button is being pressed
function Raylib.IsMouseButtonReleased(button: cint <autocast>): boolean                                                         <cimport'IsMouseButtonReleased'      , nodecl> end -- Detect if a mouse button has been released once
function Raylib.IsMouseButtonUp(button: cint <autocast>): boolean                                                               <cimport'IsMouseButtonUp'            , nodecl> end -- Detect if a mouse button is NOT being pressed
function Raylib.GetMouseX(): cint                                                                                               <cimport'GetMouseX'                  , nodecl> end -- Returns mouse position X
function Raylib.GetMouseY(): cint                                                                                               <cimport'GetMouseY'                  , nodecl> end -- Returns mouse position Y
function Raylib.GetMousePosition(): Vector2                                                                                     <cimport'GetMousePosition'           , nodecl> end -- Returns mouse position XY
function Raylib.SetMousePosition(x: cint <autocast>, y: cint <autocast>)                                                        <cimport'SetMousePosition'           , nodecl> end -- Set mouse position XY
function Raylib.SetMouseOffset(offsetX: cint <autocast>, offsetY: cint <autocast>)                                              <cimport'SetMouseOffset'             , nodecl> end -- Set mouse offset
function Raylib.SetMouseScale(scaleX: float32 <autocast>, scaleY: float32 <autocast>)                                           <cimport'SetMouseScale'              , nodecl> end -- Set mouse scaling
function Raylib.GetMouseWheelMove(): cint                                                                                       <cimport'GetMouseWheelMove'          , nodecl> end -- Returns mouse wheel movement Y

-- Input-related functions: touch
function Raylib.GetTouchX(): cint                                                                                               <cimport'GetTouchX'                  , nodecl> end -- Returns touch position X for touch point 0 (relative to screen size)
function Raylib.GetTouchY(): cint                                                                                               <cimport'GetTouchY'                  , nodecl> end -- Returns touch position Y for touch point 0 (relative to screen size)
function Raylib.GetTouchPosition(index: cint <autocast>): Vector2                                                               <cimport'GetTouchPosition'           , nodecl> end -- Returns touch position XY for a touch point index (relative to screen size)

--------------------------------------------------------------------------------------
-- Gestures and Touch Handling Functions (Module: gestures)
--------------------------------------------------------------------------------------
function Raylib.SetGesturesEnabled(gestureFlags: cuint)                                                                         <cimport'SetGesturesEnabled'         , nodecl> end -- Enable a set of gestures using flags
function Raylib.IsGestureDetected(gesture: cint <autocast>): boolean                                                            <cimport'IsGestureDetected'          , nodecl> end -- Check if a gesture have been detected
function Raylib.GetGestureDetected(): cint                                                                                      <cimport'GetGestureDetected'         , nodecl> end -- Get latest detected gesture
function Raylib.GetTouchPointsCount(): cint                                                                                     <cimport'GetTouchPointsCount'        , nodecl> end -- Get touch points count
function Raylib.GetGestureHoldDuration(): float32                                                                               <cimport'GetGestureHoldDuration'     , nodecl> end -- Get gesture hold time in milliseconds
function Raylib.GetGestureDragVector(): Vector2                                                                                 <cimport'GetGestureDragVector'       , nodecl> end -- Get gesture drag vector
function Raylib.GetGestureDragAngle(): float32                                                                                  <cimport'GetGestureDragAngle'        , nodecl> end -- Get gesture drag angle
function Raylib.GetGesturePinchVector(): Vector2                                                                                <cimport'GetGesturePinchVector'      , nodecl> end -- Get gesture pinch delta
function Raylib.GetGesturePinchAngle(): float32                                                                                 <cimport'GetGesturePinchAngle'       , nodecl> end -- Get gesture pinch angle

--------------------------------------------------------------------------------------
-- Camera System Functions (Module: camera)
--------------------------------------------------------------------------------------
function Raylib.SetCameraMode(camera: Camera, mode: cint <autocast>)                                                            <cimport'SetCameraMode'              , nodecl> end -- Set camera mode (multiple camera modes available)
function Raylib.UpdateCamera(camera: Camera*)                                                                                   <cimport'UpdateCamera'               , nodecl> end -- Update camera position for selected mode

function Raylib.SetCameraPanControl(panKey: cint <autocast>)                                                                    <cimport'SetCameraPanControl'        , nodecl> end -- Set camera pan key to combine with mouse movement (free camera)
function Raylib.SetCameraAltControl(altKey: cint <autocast>)                                                                    <cimport'SetCameraAltControl'        , nodecl> end -- Set camera alt key to combine with mouse movement (free camera)
function Raylib.SetCameraSmoothZoomControl(szKey: cint <autocast>)                                                              <cimport'SetCameraSmoothZoomControl' , nodecl> end -- Set camera smooth zoom key to combine with mouse (free camera)
function Raylib.SetCameraMoveControls(frontKey: cint <autocast>, backKey: cint <autocast>, rightKey: cint <autocast>, leftKey: cint <autocast>, upKey: cint <autocast>, downKey: cint <autocast>) <cimport'SetCameraMoveControls', nodecl> end -- Set camera move controls (1st person and 3rd person cameras)

------------------------------------------------------------------------------------------------------------------------
-- === CORE MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === SHAPES MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Basic shapes drawing functions
function Raylib.DrawPixel(posX: cint <autocast>, posY: cint <autocast>, color: Color)                                                                                                                             <cimport'DrawPixel'                  , nodecl> end -- Draw a pixel
function Raylib.DrawPixelV(position: Vector2, color: Color)                                                                                                                                                       <cimport'DrawPixelV'                 , nodecl> end -- Draw a pixel (Vector version)
function Raylib.DrawLine(startPosX: cint <autocast>, startPosY: cint <autocast>, endPosX: cint <autocast>, endPosY: cint <autocast>, color: Color)                                                                <cimport'DrawLine'                   , nodecl> end -- Draw a line
function Raylib.DrawLineV(startPos: Vector2, endPos: Vector2, color: Color)                                                                                                                                       <cimport'DrawLineV'                  , nodecl> end -- Draw a line (Vector version)
function Raylib.DrawLineEx(startPos: Vector2, endPos: Vector2, thick: float32 <autocast>, color: Color)                                                                                                           <cimport'DrawLineEx'                 , nodecl> end -- Draw a line defining thickness
function Raylib.DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: float32 <autocast>, color: Color)                                                                                                       <cimport'DrawLineBezier'             , nodecl> end -- Draw a line using cubic-bezier curves in-out
function Raylib.DrawLineStrip(points: Vector2*, numPoints: cint <autocast>, color: Color)                                                                                                                         <cimport'DrawLineStrip'              , nodecl> end -- Draw lines sequence
function Raylib.DrawCircle(centerX: cint <autocast>, centerY: cint <autocast>, radius: float32 <autocast>, color: Color)                                                                                          <cimport'DrawCircle'                 , nodecl> end -- Draw a color-filled circle
function Raylib.DrawCircleSector(center: Vector2, radius: float32 <autocast>, startAngle: cint <autocast>, endAngle: cint <autocast>, segments: cint <autocast>, color: Color)                                    <cimport'DrawCircleSector'           , nodecl> end -- Draw a piece of a circle
function Raylib.DrawCircleSectorLines(center: Vector2, radius: float32 <autocast>, startAngle: cint <autocast>, endAngle: cint <autocast>, segments: cint <autocast>, color: Color)                               <cimport'DrawCircleSectorLines'      , nodecl> end -- Draw circle sector outline
function Raylib.DrawCircleGradient(centerX: cint <autocast>, centerY: cint <autocast>, radius: float32 <autocast>, color1: Color, color2: Color)                                                                  <cimport'DrawCircleGradient'         , nodecl> end -- Draw a gradient-filled circle
function Raylib.DrawCircleV(center: Vector2, radius: float32 <autocast>, color: Color)                                                                                                                            <cimport'DrawCircleV'                , nodecl> end -- Draw a color-filled circle (Vector version)
function Raylib.DrawCircleLines(centerX: cint <autocast>, centerY: cint <autocast>, radius: float32 <autocast>, color: Color)                                                                                     <cimport'DrawCircleLines'            , nodecl> end -- Draw circle outline
function Raylib.DrawEllipse(centerX: cint <autocast>, centerY: cint <autocast>, radiusH: float32 <autocast>, radiusV: float32 <autocast>, color: Color)                                                           <cimport'DrawEllipse'                , nodecl> end -- Draw ellipse
function Raylib.DrawEllipseLines(centerX: cint <autocast>, centerY: cint <autocast>, radiusH: float32 <autocast>, radiusV: float32 <autocast>, color: Color)                                                      <cimport'DrawEllipseLines'           , nodecl> end -- Draw ellipse outline
function Raylib.DrawRing(center: Vector2, innerRadius: float32 <autocast>, outerRadius: float32 <autocast>, startAngle: cint <autocast>, endAngle: cint <autocast>, segments: cint <autocast>, color: Color)      <cimport'DrawRing'                   , nodecl> end -- Draw ring
function Raylib.DrawRingLines(center: Vector2, innerRadius: float32 <autocast>, outerRadius: float32 <autocast>, startAngle: cint <autocast>, endAngle: cint <autocast>, segments: cint <autocast>, color: Color) <cimport'DrawRingLines'              , nodecl> end -- Draw ring outline
function Raylib.DrawRectangle(posX: cint <autocast>, posY: cint <autocast>, width: cint <autocast>, height: cint <autocast>, color: Color)                                                                        <cimport'DrawRectangle'              , nodecl> end -- Draw a color-filled rectangle
function Raylib.DrawRectangleV(position: Vector2, size: Vector2, color: Color)                                                                                                                                    <cimport'DrawRectangleV'             , nodecl> end -- Draw a color-filled rectangle (Vector version)
function Raylib.DrawRectangleRec(rec: Rectangle, color: Color)                                                                                                                                                    <cimport'DrawRectangleRec'           , nodecl> end -- Draw a color-filled rectangle
function Raylib.DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: float32 <autocast>, color: Color)                                                                                                     <cimport'DrawRectanglePro'           , nodecl> end -- Draw a color-filled rectangle with pro parameters
function Raylib.DrawRectangleGradientV(posX: cint <autocast>, posY: cint <autocast>, width: cint <autocast>, height: cint <autocast>, color1: Color, color2: Color)                                               <cimport'DrawRectangleGradientV'     , nodecl> end -- Draw a vertical-gradient-filled rectangle
function Raylib.DrawRectangleGradientH(posX: cint <autocast>, posY: cint <autocast>, width: cint <autocast>, height: cint <autocast>, color1: Color, color2: Color)                                               <cimport'DrawRectangleGradientH'     , nodecl> end -- Draw a horizontal-gradient-filled rectangle
function Raylib.DrawRectangleGradientEx(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)                                                                                                       <cimport'DrawRectangleGradientEx'    , nodecl> end -- Draw a gradient-filled rectangle with custom vertex colors
function Raylib.DrawRectangleLines(posX: cint <autocast>, posY: cint <autocast>, width: cint <autocast>, height: cint <autocast>, color: Color)                                                                   <cimport'DrawRectangleLines'         , nodecl> end -- Draw rectangle outline
function Raylib.DrawRectangleLinesEx(rec: Rectangle, lineThick: cint <autocast>, color: Color)                                                                                                                    <cimport'DrawRectangleLinesEx'       , nodecl> end -- Draw rectangle outline with extended parameters
function Raylib.DrawRectangleRounded(rec: Rectangle, roundness: float32 <autocast>, segments: cint <autocast>, color: Color)                                                                                      <cimport'DrawRectangleRounded'       , nodecl> end -- Draw rectangle with rounded edges
function Raylib.DrawRectangleRoundedLines(rec: Rectangle, roundness: float32 <autocast>, segments: cint <autocast>, lineThick: cint <autocast>, color: Color)                                                     <cimport'DrawRectangleRoundedLines'  , nodecl> end -- Draw rectangle with rounded edges outline
function Raylib.DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)                                                                                                                                 <cimport'DrawTriangle'               , nodecl> end -- Draw a color-filled triangle (vertex in counter-clockwise order!)
function Raylib.DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)                                                                                                                            <cimport'DrawTriangleLines'          , nodecl> end -- Draw triangle outline (vertex in counter-clockwise order!)
function Raylib.DrawTriangleFan(points: Vector2*, numPoints: cint <autocast>, color: Color)                                                                                                                       <cimport'DrawTriangleFan'            , nodecl> end -- Draw a triangle fan defined by points (first vertex is the center)
function Raylib.DrawTriangleStrip(points: Vector2*, pointsCount: cint <autocast>, color: Color)                                                                                                                   <cimport'DrawTriangleStrip'          , nodecl> end -- Draw a triangle strip defined by points
function Raylib.DrawPoly(center: Vector2, sides: cint <autocast>, radius: float32 <autocast>, rotation: float32 <autocast>, color: Color)                                                                         <cimport'DrawPoly'                   , nodecl> end -- Draw a regular polygon (Vector version)
function Raylib.DrawPolyLines(center: Vector2, sides: cint <autocast>, radius: float32 <autocast>, rotation: float32 <autocast>, color: Color)                                                                    <cimport'DrawPolyLines'              , nodecl> end -- Draw a polygon outline of n sides

-- Basic shapes collision detection functions
function Raylib.CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): boolean                                                                                                                                     <cimport'CheckCollisionRecs'         , nodecl> end -- Check collision between two rectangles
function Raylib.CheckCollisionCircles(center1: Vector2, radius1: float32 <autocast>, center2: Vector2, radius2: float32 <autocast>): boolean                                                                      <cimport'CheckCollisionCircles'      , nodecl> end -- Check collision between two circles
function Raylib.CheckCollisionCircleRec(center: Vector2, radius: float32 <autocast>, rec: Rectangle): boolean                                                                                                     <cimport'CheckCollisionCircleRec'    , nodecl> end -- Check collision between circle and rectangle
function Raylib.GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle                                                                                                                                      <cimport'GetCollisionRec'            , nodecl> end -- Get collision rectangle for two rectangles collision
function Raylib.CheckCollisionPointRec(point: Vector2, rec: Rectangle): boolean                                                                                                                                   <cimport'CheckCollisionPointRec'     , nodecl> end -- Check if point is inside rectangle
function Raylib.CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: float32 <autocast>): boolean                                                                                                   <cimport'CheckCollisionPointCircle'  , nodecl> end -- Check if point is inside circle
function Raylib.CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): boolean                                                                                                       <cimport'CheckCollisionPointTriangle', nodecl> end -- Check if point is inside a triangle

------------------------------------------------------------------------------------------------------------------------
-- === SHAPES MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === TEXTURES MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Image/Texture2D data loading/unloading/saving functions
function Raylib.LoadImage(fileName: cstring): Image                                                                                                                            <cimport'LoadImage'              , nodecl> end -- Load image from file into CPU memory (RAM)
function Raylib.LoadImageEx(pixels: Color*, width: cint <autocast>, height: cint <autocast>): Image                                                                            <cimport'LoadImageEx'            , nodecl> end -- Load image from Color array data (RGBA - 32bit)
function Raylib.LoadImagePro(data: pointer, width: cint <autocast>, height: cint <autocast>, format: cint <autocast>): Image                                                   <cimport'LoadImagePro'           , nodecl> end -- Load image from raw data with parameters
function Raylib.LoadImageRaw(fileName: cstring, width: cint <autocast>, height: cint <autocast>, format: cint <autocast>, headerSize: cint <autocast>): Image                  <cimport'LoadImageRaw'           , nodecl> end -- Load image from RAW file data
function Raylib.ExportImage(image: Image, fileName: cstring)                                                                                                                   <cimport'ExportImage'            , nodecl> end -- Export image data to file
function Raylib.ExportImageAsCode(image: Image, fileName: cstring)                                                                                                             <cimport'ExportImageAsCode'      , nodecl> end -- Export image as code file defining an array of bytes
function Raylib.LoadTexture(fileName: cstring): Texture2D                                                                                                                      <cimport'LoadTexture'            , nodecl> end -- Load texture from file into GPU memory (VRAM)
function Raylib.LoadTextureFromImage(image: Image): Texture2D                                                                                                                  <cimport'LoadTextureFromImage'   , nodecl> end -- Load texture from image data
function Raylib.LoadTextureCubemap(image: Image, layoutType: cint <autocast>): TextureCubemap                                                                                  <cimport'LoadTextureCubemap'     , nodecl> end -- Load cubemap from image, multiple image cubemap layouts supported
function Raylib.LoadRenderTexture(width: cint <autocast>, height: cint <autocast>): RenderTexture2D                                                                            <cimport'LoadRenderTexture'      , nodecl> end -- Load texture for rendering (framebuffer)
function Raylib.UnloadImage(image: Image)                                                                                                                                      <cimport'UnloadImage'            , nodecl> end -- Unload image from CPU memory (RAM)
function Raylib.UnloadTexture(texture: Texture2D)                                                                                                                              <cimport'UnloadTexture'          , nodecl> end -- Unload texture from GPU memory (VRAM)
function Raylib.UnloadRenderTexture(target: RenderTexture2D)                                                                                                                   <cimport'UnloadRenderTexture'    , nodecl> end -- Unload render texture from GPU memory (VRAM)
function Raylib.GetImageData(image: Image): Color*                                                                                                                             <cimport'GetImageData'           , nodecl> end -- Get pixel data from image as a Color struct array
function Raylib.GetImageDataNormalized(image: Image): Vector4*                                                                                                                 <cimport'GetImageDataNormalized' , nodecl> end -- Get pixel data from image as Vector4 array (float normalized)
function Raylib.GetImageAlphaBorder(image: Image, threshold: float32 <autocast>): Rectangle                                                                                    <cimport'GetImageAlphaBorder'    , nodecl> end -- Get image alpha border rectangle
function Raylib.GetPixelDataSize(width: cint <autocast>, height: cint <autocast>, format: cint <autocast>): cint                                                               <cimport'GetPixelDataSize'       , nodecl> end -- Get pixel data size in bytes (image or texture)
function Raylib.GetTextureData(texture: Texture2D): Image                                                                                                                      <cimport'GetTextureData'         , nodecl> end -- Get pixel data from GPU texture and return an Image
function Raylib.GetScreenData(): Image                                                                                                                                         <cimport'GetScreenData'          , nodecl> end -- Get pixel data from screen buffer and return an Image (screenshot)
function Raylib.UpdateTexture(texture: Texture2D, pixels: pointer)                                                                                                             <cimport'UpdateTexture'          , nodecl> end -- Update GPU texture with new data

-- Image manipulation functions
function Raylib.ImageCopy(image: Image): Image                                                                                                                                 <cimport'ImageCopy'              , nodecl> end -- Create an image duplicate (useful for transformations)
function Raylib.ImageFromImage(image: Image, rec: Rectangle): Image                                                                                                            <cimport'ImageFromImage'         , nodecl> end -- Create an image from another image piece
function Raylib.ImageToPOT(image: Image*, fillColor: Color)                                                                                                                    <cimport'ImageToPOT'             , nodecl> end -- Convert image to POT (power-of-two)
function Raylib.ImageFormat(image: Image*, newFormat: cint <autocast>)                                                                                                         <cimport'ImageFormat'            , nodecl> end -- Convert image data to desired format
function Raylib.ImageAlphaMask(image: Image*, alphaMask: Image)                                                                                                                <cimport'ImageAlphaMask'         , nodecl> end -- Apply alpha mask to image
function Raylib.ImageAlphaClear(image: Image*, color: Color, threshold: float32 <autocast>)                                                                                    <cimport'ImageAlphaClear'        , nodecl> end -- Clear alpha channel to desired color
function Raylib.ImageAlphaCrop(image: Image*, threshold: float32 <autocast>)                                                                                                   <cimport'ImageAlphaCrop'         , nodecl> end -- Crop image depending on alpha value
function Raylib.ImageAlphaPremultiply(image: Image*)                                                                                                                           <cimport'ImageAlphaPremultiply'  , nodecl> end -- Premultiply alpha channel
function Raylib.ImageCrop(image: Image*, crop: Rectangle)                                                                                                                      <cimport'ImageCrop'              , nodecl> end -- Crop an image to a defined rectangle
function Raylib.ImageResize(image: Image*, newWidth: cint <autocast>, newHeight: cint <autocast>)                                                                              <cimport'ImageResize'            , nodecl> end -- Resize image (Bicubic scaling algorithm)
function Raylib.ImageResizeNN(image: Image*, newWidth: cint ,newHeight: cint <autocast>)                                                                                       <cimport'ImageResizeNN'          , nodecl> end -- Resize image (Nearest-Neighbor scaling algorithm)
function Raylib.ImageResizeCanvas(image: Image*, newWidth: cint <autocast>, newHeight: cint <autocast>, offsetX: cint <autocast>, offsetY: cint <autocast>, color: Color)      <cimport'ImageResizeCanvas'      , nodecl> end -- Resize canvas and fill with color
function Raylib.ImageMipmaps(image: Image*)                                                                                                                                    <cimport'ImageMipmaps'           , nodecl> end -- Generate all mipmap levels for a provided image
function Raylib.ImageDither(image: Image*, rBpp: cint <autocast>, gBpp: cint <autocast>, bBpp: cint <autocast>, aBpp: cint <autocast>)                                         <cimport'ImageDither'            , nodecl> end -- Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
function Raylib.ImageExtractPalette(image: Image, maxPaletteSize: cint <autocast>, extractCount: cint*): Color*                                                                <cimport'ImageExtractPalette'    , nodecl> end -- Extract color palette from image to maximum size (memory should be freed)
function Raylib.ImageText(text: cstring, fontSize: cint <autocast>, color: Color): Image                                                                                       <cimport'ImageText'              , nodecl> end -- Create an image from text (default font)
function Raylib.ImageTextEx(font: Font <autocast>, text: cstring, fontSize: float32 <autocast>, spacing: float32 <autocast>, tint: Color): Image                               <cimport'ImageTextEx'            , nodecl> end -- Create an image from text (custom sprite font)
function Raylib.ImageDraw(dst: Image*, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)                                                                          <cimport'ImageDraw'              , nodecl> end -- Draw a source image within a destination image (tint applied to source)
function Raylib.ImageDrawRectangle(dst: Image*, rec: Rectangle, color: Color)                                                                                                  <cimport'ImageDrawRectangle'     , nodecl> end -- Draw rectangle within an image
function Raylib.ImageDrawRectangleLines(dst: Image*, rec: Rectangle, thick: cint <autocast>, color: Color)                                                                     <cimport'ImageDrawRectangleLines', nodecl> end -- Draw rectangle lines within an image
function Raylib.ImageDrawText(dst: Image*, position: Vector2, text: cstring, fontSize: cint <autocast>, color: Color)                                                          <cimport'ImageDrawText'          , nodecl> end -- Draw text (default font) within an image (destination)
function Raylib.ImageDrawTextEx(dst: Image*, position: Vector2, font: Font <autocast>, text: cstring, fontSize: float32 <autocast>, spacing: float32 <autocast>, color: Color) <cimport'ImageDrawTextEx'        , nodecl> end -- Draw text (custom sprite font) within an image (destination)
function Raylib.ImageFlipVertical(image: Image*)                                                                                                                               <cimport'ImageFlipVertical'      , nodecl> end -- Flip image vertically
function Raylib.ImageFlipHorizontal(image: Image*)                                                                                                                             <cimport'ImageFlipHorizontal'    , nodecl> end -- Flip image horizontally
function Raylib.ImageRotateCW(image: Image*)                                                                                                                                   <cimport'ImageRotateCW'          , nodecl> end -- Rotate image clockwise 90deg
function Raylib.ImageRotateCCW(image: Image*)                                                                                                                                  <cimport'ImageRotateCCW'         , nodecl> end -- Rotate image counter-clockwise 90deg
function Raylib.ImageColorTint(image: Image*, color: Color)                                                                                                                    <cimport'ImageColorTint'         , nodecl> end -- Modify image color: tint
function Raylib.ImageColorInvert(image: Image*)                                                                                                                                <cimport'ImageColorInvert'       , nodecl> end -- Modify image color: invert
function Raylib.ImageColorGrayscale(image: Image*)                                                                                                                             <cimport'ImageColorGrayscale'    , nodecl> end -- Modify image color: grayscale
function Raylib.ImageColorContrast(image: Image*, contrast: float32 <autocast>)                                                                                                <cimport'ImageColorContrast'     , nodecl> end -- Modify image color: contrast (-100 to 100)
function Raylib.ImageColorBrightness(image: Image*, brightness: cint <autocast>)                                                                                               <cimport'ImageColorBrightness'   , nodecl> end -- Modify image color: brightness (-255 to 255)
function Raylib.ImageColorReplace(image: Image*, color: Color, replace: Color)                                                                                                 <cimport'ImageColorReplace'      , nodecl> end -- Modify image color: replace color

-- Image generation functions
function Raylib.GenImageColor(width: cint <autocast>, height: cint <autocast>, color: Color): Image                                                                            <cimport'GenImageColor'          , nodecl> end -- Generate image: plain color
function Raylib.GenImageGradientV(width: cint <autocast>, height: cint <autocast>, top: Color, bottom: Color): Image                                                           <cimport'GenImageGradientV'      , nodecl> end -- Generate image: vertical gradient
function Raylib.GenImageGradientH(width: cint <autocast>, height: cint <autocast>, left: Color, right: Color): Image                                                           <cimport'GenImageGradientH'      , nodecl> end -- Generate image: horizontal gradient
function Raylib.GenImageGradientRadial(width: cint <autocast>, height: cint <autocast>, density: float32 <autocast>, inner: Color, outer: Color): Image                        <cimport'GenImageGradientRadial' , nodecl> end -- Generate image: radial gradient
function Raylib.GenImageChecked(width: cint <autocast>, height: cint <autocast>, checksX: cint <autocast>, checksY: cint <autocast>, col1: Color, col2: Color): Image          <cimport'GenImageChecked'        , nodecl> end -- Generate image: checked
function Raylib.GenImageWhiteNoise(width: cint <autocast>, height: cint <autocast>, factor: float32 <autocast>): Image                                                         <cimport'GenImageWhiteNoise'     , nodecl> end -- Generate image: white noise
function Raylib.GenImagePerlinNoise(width: cint <autocast>, height: cint <autocast>, offsetX: cint <autocast>, offsetY: cint <autocast>, scale: float32 <autocast>): Image     <cimport'GenImagePerlinNoise'    , nodecl> end -- Generate image: perlin noise
function Raylib.GenImageCellular(width: cint <autocast>, height: cint <autocast>, tileSize: cint <autocast>): Image                                                            <cimport'GenImageCellular'       , nodecl> end -- Generate image: cellular algorithm. Bigger tileSize means bigger cells

-- Texture2D configuration functions
function Raylib.GenTextureMipmaps(texture: Texture2D*)                                                                                                                         <cimport'GenTextureMipmaps'      , nodecl> end -- Generate GPU mipmaps for a texture
function Raylib.SetTextureFilter(texture: Texture2D, filterMode: cint <autocast>)                                                                                              <cimport'SetTextureFilter'       , nodecl> end -- Set texture scaling filter mode
function Raylib.SetTextureWrap(texture: Texture2D, wrapMode: cint <autocast>)                                                                                                  <cimport'SetTextureWrap'         , nodecl> end -- Set texture wrapping mode

-- Texture2D drawing functions
function Raylib.DrawTexture(texture: Texture2D, posX: cint <autocast>, posY: cint <autocast>, tint: Color)                                                                     <cimport'DrawTexture'            , nodecl> end -- Draw a Texture2D
function Raylib.DrawTextureV(texture: Texture2D, position: Vector2, tint: Color)                                                                                               <cimport'DrawTextureV'           , nodecl> end -- Draw a Texture2D with position defined as Vector2
function Raylib.DrawTextureEx(texture: Texture2D, position: Vector2, rotation: float32 <autocast>, scale: float32 <autocast>, tint: Color)                                     <cimport'DrawTextureEx'          , nodecl> end -- Draw a Texture2D with extended parameters
function Raylib.DrawTextureRec(texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color)                                                                       <cimport'DrawTextureRec'         , nodecl> end -- Draw a part of a texture defined by a rectangle
function Raylib.DrawTextureQuad(texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color)                                                            <cimport'DrawTextureQuad'        , nodecl> end -- Draw texture quad with tiling and offset parameters
function Raylib.DrawTexturePro(texture: Texture2D, sourceRec: Rectangle, destRec: Rectangle, origin: Vector2, rotation: float32 <autocast>, tint: Color)                       <cimport'DrawTexturePro'         , nodecl> end -- Draw a part of a texture defined by a rectangle with 'pro' parameters
function Raylib.DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, destRec: Rectangle, origin: Vector2, rotation: float32 <autocast>, tint: Color)                  <cimport'DrawTextureNPatch'      , nodecl> end -- Draws a texture (or part of it) that stretches or shrinks nicely

------------------------------------------------------------------------------------------------------------------------
-- === TEXTURES MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === TEXT MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Font loading/unloading functions
function Raylib.GetFontDefault(): Font                                                                                                                                                         <cimport'GetFontDefault'    , nodecl> end -- Get the default Font
function Raylib.LoadFont(fileName: cstring): Font                                                                                                                                              <cimport'LoadFont'          , nodecl> end -- Load font from file into GPU memory (VRAM)
function Raylib.LoadFontEx(fileName: cstring, fontSize: cint <autocast>, fontChars: cint*, charsCount: cint <autocast>): Font                                                                  <cimport'LoadFontEx'        , nodecl> end -- Load font from file with extended parameters
function Raylib.LoadFontFromImage(image: Image, key: Color, firstChar: cint <autocast>): Font                                                                                                  <cimport'LoadFontFromImage' , nodecl> end -- Load font from Image (XNA style)
function Raylib.LoadFontData(fileName: cstring, fontSize: cint <autocast>, fontChars: cint*, charsCount: cint <autocast>, type: cint <autocast>): CharInfo*                                    <cimport'LoadFontData'      , nodecl> end -- Load font data for further use
function Raylib.GenImageFontAtlas(chars: CharInfo*, recs: Rectangle[0]*, charsCount: cint <autocast>, fontSize: cint <autocast>, padding: cint <autocast>, packMethod: cint <autocast>): Image <cimport'GenImageFontAtlas' , nodecl> end -- Generate image font atlas using chars info
function Raylib.UnloadFont(font: Font <autocast>)                                                                                                                                              <cimport'UnloadFont'        , nodecl> end -- Unload Font from GPU memory (VRAM)

-- Text drawing functions
function Raylib.DrawFPS(posX: cint <autocast>, posY: cint <autocast>)                                                                                                                          <cimport'DrawFPS'           , nodecl> end -- Shows current FPS
function Raylib.DrawText(text: cstring, posX: cint <autocast>, posY: cint <autocast>, fontSize: cint <autocast>, color: Color)                                                                 <cimport'DrawText'          , nodecl> end -- Draw text (using default font)
function Raylib.DrawTextEx(font: Font <autocast>, text: cstring, position: Vector2, fontSize: float32 <autocast>, spacing: float32 <autocast>, tint: Color)                                    <cimport'DrawTextEx'        , nodecl> end -- Draw text using font and additional parameters
function Raylib.DrawTextRec(font: Font <autocast>, text: cstring, rec: Rectangle, fontSize: float32 <autocast>, spacing: float32 <autocast>, wordWrap: boolean, tint: Color)                   <cimport'DrawTextRec'       , nodecl> end -- Draw text using font inside rectangle limits
function Raylib.DrawTextRecEx(font: Font <autocast>, text: cstring, rec: Rectangle, fontSize: float32 <autocast>, spacing: float32 <autocast>, wordWrap: boolean, tint: Color, selectStart: cint <autocast>, selectLength: cint <autocast>, selectTint: Color, selectBackTint: Color) <cimport'DrawTextRecEx', nodecl> end -- Draw text using font inside rectangle limits with support for text selection
function Raylib.DrawTextCodepoint(font: Font <autocast>, codepoint: cint <autocast>, position: Vector2, scale: float32 <autocast>, tint: Color)                                                <cimport'DrawTextCodepoint' , nodecl> end -- Draw one character (codepoint)

-- Text misc. functions
function Raylib.MeasureText(text: cstring, fontSize: cint <autocast>): cint                                                                                                                    <cimport'MeasureText'       , nodecl> end -- Measure string width for default font
function Raylib.MeasureTextEx(font: Font <autocast>, text: cstring, fontSize: float32 <autocast>, spacing: float32 <autocast>): Vector2                                                        <cimport'MeasureTextEx'     , nodecl> end -- Measure string size for Font
function Raylib.GetGlyphIndex(font: Font <autocast>, codepoint: cint <autocast>): cint                                                                                                         <cimport'GetGlyphIndex'     , nodecl> end -- Get index position for a unicode character on font

-- Text strings management functions (no utf8 strings, only byte chars)
-- NOTE: Some strings allocate memory internally for returned strings, just be careful!
function Raylib.TextCopy(dst: cstring, src: cstring): cint                                                                                                                                     <cimport'TextCopy'          , nodecl> end -- Copy one string to another, returns bytes copied
function Raylib.TextIsEqual(text1: cstring, text2: cstring): boolean                                                                                                                           <cimport'TextIsEqual'       , nodecl> end -- Check if two text string are equal
function Raylib.TextLength(text: cstring): cuint                                                                                                                                               <cimport'TextLength'        , nodecl> end -- Get text length, checks for '\0' ending
function Raylib.TextFormat(text: cstring, ...): cstring                                                                                                                                        <cimport'TextFormat'        , nodecl> end -- Text formatting with variables (sprintf style)
function Raylib.TextSubtext(text: cstring, position: cint <autocast>, length: cint <autocast>): cstring                                                                                        <cimport'TextSubtext'       , nodecl> end -- Get a piece of a text string
function Raylib.TextReplace(text: cstring, replace: cstring, by: cstring): cstring                                                                                                             <cimport'TextReplace'       , nodecl> end -- Replace text string (memory must be freed!)
function Raylib.TextInsert(text: cstring, insert: cstring, position: cint <autocast>): cstring                                                                                                 <cimport'TextInsert'        , nodecl> end -- Insert text in a position (memory must be freed!)
function Raylib.TextJoin(textList: cstring[0]*, count: cint <autocast>, delimiter: cstring): cstring                                                                                           <cimport'TextJoin'          , nodecl> end -- Join text strings with delimiter
function Raylib.TextSplit(text: cstring, delimiter: cchar, count: cint*): cstring*                                                                                                             <cimport'TextSplit'         , nodecl> end -- Split text into multiple strings
function Raylib.TextAppend(text: cstring, append: cstring, position: cint*)                                                                                                                    <cimport'TextAppend'        , nodecl> end -- Append text at specific position and move cursor!
function Raylib.TextFindIndex(text: cstring, find: cstring): cint                                                                                                                              <cimport'TextFindIndex'     , nodecl> end -- Find first text occurrence within a string
function Raylib.TextToUpper(text: cstring): cstring                                                                                                                                            <cimport'TextToUpper'       , nodecl> end -- Get upper case version of provided string
function Raylib.TextToLower(text: cstring): cstring                                                                                                                                            <cimport'TextToLower'       , nodecl> end -- Get lower case version of provided string
function Raylib.TextToPascal(text: cstring): cstring                                                                                                                                           <cimport'TextToPascal'      , nodecl> end -- Get Pascal case notation version of provided string
function Raylib.TextToInteger(text: cstring): cint                                                                                                                                             <cimport'TextToInteger'     , nodecl> end -- Get integer value from text (negative values not supported)
function Raylib.TextToUtf8(codepoints: cint*, length: cint <autocast>): cstring                                                                                                                <cimport'TextToUtf8'        , nodecl> end -- Encode text codepoint into utf8 text (memory must be freed!)

-- UTF8 text strings management functions
function Raylib.GetCodepoints(text: cstring, count: cint*): cint*                                                                                                                              <cimport'GetCodepoints'     , nodecl> end -- Get all codepoints in a string, codepoints count returned by parameters
function Raylib.GetCodepointsCount(text: cstring): cint                                                                                                                                        <cimport'GetCodepointsCount', nodecl> end -- Get total number of characters (codepoints) in a UTF8 encoded string
function Raylib.GetNextCodepoint(text: cstring, bytesProcessed: cint*): cint                                                                                                                   <cimport'GetNextCodepoint'  , nodecl> end -- Returns next codepoint in a UTF8 encoded string; 0x3f('?') is returned on failure
function Raylib.CodepointToUtf8(codepoint: cint <autocast>, byteLength: cint*): cstring                                                                                                        <cimport'CodepointToUtf8'   , nodecl> end -- Encode codepoint into utf8 text (char array length returned as parameter)

------------------------------------------------------------------------------------------------------------------------
-- === TEXT MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === MODELS MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Basic geometric 3D shapes drawing functions
function Raylib.DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color)                                                                                                             <cimport'DrawLine3D'                , nodecl> end -- Draw a line in 3D world space
function Raylib.DrawPoint3D(position: Vector3, color: Color)                                                                                                                             <cimport'DrawPoint3D'               , nodecl> end -- Draw a point in 3D space, actually a small line
function Raylib.DrawCircle3D(center: Vector3, radius: float32 <autocast>, rotationAxis: Vector3, rotationAngle: float32 <autocast>, color: Color)                                        <cimport'DrawCircle3D'              , nodecl> end -- Draw a circle in 3D world space
function Raylib.DrawCube(position: Vector3, width: float32 <autocast>, height: float32 <autocast>, length: float32 <autocast>, color: Color)                                             <cimport'DrawCube'                  , nodecl> end -- Draw cube
function Raylib.DrawCubeV(position: Vector3, size: Vector3, color: Color)                                                                                                                <cimport'DrawCubeV'                 , nodecl> end -- Draw cube (Vector version)
function Raylib.DrawCubeWires(position: Vector3, width: float32 <autocast>, height: float32 <autocast>, length: float32 <autocast>, color: Color)                                        <cimport'DrawCubeWires'             , nodecl> end -- Draw cube wires
function Raylib.DrawCubeWiresV(position: Vector3, size: Vector3, color: Color)                                                                                                           <cimport'DrawCubeWiresV'            , nodecl> end -- Draw cube wires (Vector version)
function Raylib.DrawCubeTexture(texture: Texture2D, position: Vector3, width: float32 <autocast>, height: float32 <autocast>, length: float32 <autocast>, color: Color)                  <cimport'DrawCubeTexture'           , nodecl> end -- Draw cube textured
function Raylib.DrawSphere(centerPos: Vector3, radius: float32 <autocast>, color: Color)                                                                                                 <cimport'DrawSphere'                , nodecl> end -- Draw sphere
function Raylib.DrawSphereEx(centerPos: Vector3, radius: float32 <autocast>, rings: cint <autocast>, slices: cint <autocast>, color: Color)                                              <cimport'DrawSphereEx'              , nodecl> end -- Draw sphere with extended parameters
function Raylib.DrawSphereWires(centerPos: Vector3, radius: float32 <autocast>, rings: cint <autocast>, slices: cint <autocast>, color: Color)                                           <cimport'DrawSphereWires'           , nodecl> end -- Draw sphere wires
function Raylib.DrawCylinder(position: Vector3, radiusTop: float32 <autocast>, radiusBottom: float32 <autocast>, height: float32 <autocast>, slices: cint <autocast>, color: Color)      <cimport'DrawCylinder'              , nodecl> end -- Draw a cylinder/cone
function Raylib.DrawCylinderWires(position: Vector3, radiusTop: float32 <autocast>, radiusBottom: float32 <autocast>, height: float32 <autocast>, slices: cint <autocast>, color: Color) <cimport'DrawCylinderWires'         , nodecl> end -- Draw a cylinder/cone wires
function Raylib.DrawPlane(centerPos: Vector3, size: Vector2, color: Color)                                                                                                               <cimport'DrawPlane'                 , nodecl> end -- Draw a plane XZ
function Raylib.DrawRay(ray: Ray, color: Color)                                                                                                                                          <cimport'DrawRay'                   , nodecl> end -- Draw a ray line
function Raylib.DrawGrid(slices: cint <autocast>, spacing: float32 <autocast>)                                                                                                           <cimport'DrawGrid'                  , nodecl> end -- Draw a grid (centered at (0, 0, 0))
function Raylib.DrawGizmo(position: Vector3)                                                                                                                                             <cimport'DrawGizmo'                 , nodecl> end -- Draw simple gizmo

-- Model loading/unloading functions
function Raylib.LoadModel(fileName: cstring): Model                                                                                                                                      <cimport'LoadModel'                 , nodecl> end -- Load model from files (meshes and materials)
function Raylib.LoadModelFromMesh(mesh: Mesh): Model                                                                                                                                     <cimport'LoadModelFromMesh'         , nodecl> end -- Load model from generated mesh (default material)
function Raylib.UnloadModel(model: Model)                                                                                                                                                <cimport'UnloadModel'               , nodecl> end -- Unload model from memory (RAM and/or VRAM)

-- Mesh loading/unloading functions
function Raylib.LoadMeshes(fileName: cstring, meshCount: cint*): Mesh*                                                                                                                   <cimport'LoadMeshes'                , nodecl> end -- Load meshes from model file
function Raylib.ExportMesh(mesh: Mesh, fileName: cstring)                                                                                                                                <cimport'ExportMesh'                , nodecl> end -- Export mesh data to file
function Raylib.UnloadMesh(mesh: Mesh)                                                                                                                                                   <cimport'UnloadMesh'                , nodecl> end -- Unload mesh from memory (RAM and/or VRAM)

-- Material loading/unloading functions
function Raylib.LoadMaterials(fileName: cstring, materialCount: cint*): Material*                                                                                                        <cimport'LoadMaterials'             , nodecl> end -- Load materials from model file
function Raylib.LoadMaterialDefault(): Material                                                                                                                                          <cimport'LoadMaterialDefault'       , nodecl> end -- Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
function Raylib.UnloadMaterial(material: Material)                                                                                                                                       <cimport'UnloadMaterial'            , nodecl> end -- Unload material from GPU memory (VRAM)
function Raylib.SetMaterialTexture(material: Material*, mapType: cint <autocast>, texture: Texture2D)                                                                                    <cimport'SetMaterialTexture'        , nodecl> end -- Set texture for a material map type (MAP_DIFFUSE, MAP_SPECULAR...)
function Raylib.SetModelMeshMaterial(model: Model*, meshId: cint <autocast>, materialId: cint <autocast>)                                                                                <cimport'SetModelMeshMaterial'      , nodecl> end -- Set material for a mesh

-- Model animations loading/unloading functions
function Raylib.LoadModelAnimations(fileName: cstring, animsCount: cint*): ModelAnimation*                                                                                               <cimport'LoadModelAnimations'       , nodecl> end -- Load model animations from file
function Raylib.UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: cint <autocast>)                                                                                         <cimport'UpdateModelAnimation'      , nodecl> end -- Update model animation pose
function Raylib.UnloadModelAnimation(anim: ModelAnimation)                                                                                                                               <cimport'UnloadModelAnimation'      , nodecl> end -- Unload animation data
function Raylib.IsModelAnimationValid(model: Model, anim: ModelAnimation): boolean                                                                                                       <cimport'IsModelAnimationValid'     , nodecl> end -- Check model animation skeleton match

-- Mesh generation functions
function Raylib.GenMeshPoly(sides: cint <autocast>, radius: float32 <autocast>): Mesh                                                                                                    <cimport'GenMeshPoly'               , nodecl> end -- Generate polygonal mesh
function Raylib.GenMeshPlane(width: float32 <autocast>, length: float32 <autocast>, resX: cint <autocast>, resZ: cint <autocast>): Mesh                                                  <cimport'GenMeshPlane'              , nodecl> end -- Generate plane mesh (with subdivisions)
function Raylib.GenMeshCube(width: float32 <autocast>, height: float32 <autocast>, length: float32 <autocast>): Mesh                                                                     <cimport'GenMeshCube'               , nodecl> end -- Generate cuboid mesh
function Raylib.GenMeshSphere(radius: float32 <autocast>, rings: cint <autocast>, slices: cint <autocast>): Mesh                                                                         <cimport'GenMeshSphere'             , nodecl> end -- Generate sphere mesh (standard sphere)
function Raylib.GenMeshHemiSphere(radius: float32 <autocast>, rings: cint <autocast>, slices: cint <autocast>): Mesh                                                                     <cimport'GenMeshHemiSphere'         , nodecl> end -- Generate half-sphere mesh (no bottom cap)
function Raylib.GenMeshCylinder(radius: float32 <autocast>, height: float32 <autocast>, slices: cint <autocast>): Mesh                                                                   <cimport'GenMeshCylinder'           , nodecl> end -- Generate cylinder mesh
function Raylib.GenMeshTorus(radius: float32 <autocast>, size: float32 <autocast>, radSeg: cint <autocast>, sides: cint <autocast>): Mesh                                                <cimport'GenMeshTorus'              , nodecl> end -- Generate torus mesh
function Raylib.GenMeshKnot(radius: float32 <autocast>, size: float32 <autocast>, radSeg: cint <autocast>, sides: cint <autocast>): Mesh                                                 <cimport'GenMeshKnot'               , nodecl> end -- Generate trefoil knot mesh
function Raylib.GenMeshHeightmap(heightmap: Image, size: Vector3): Mesh                                                                                                                  <cimport'GenMeshHeightmap'          , nodecl> end -- Generate heightmap mesh from image data
function Raylib.GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3): Mesh                                                                                                                <cimport'GenMeshCubicmap'           , nodecl> end -- Generate cubes-based map mesh from image data

-- Mesh manipulation functions
function Raylib.MeshBoundingBox(mesh: Mesh): BoundingBox                                                                                                                                 <cimport'MeshBoundingBox'           , nodecl> end -- Compute mesh bounding box limits
function Raylib.MeshTangents(mesh: Mesh*)                                                                                                                                                <cimport'MeshTangents'              , nodecl> end -- Compute mesh tangents
function Raylib.MeshBinormals(mesh: Mesh*)                                                                                                                                               <cimport'MeshBinormals'             , nodecl> end -- Compute mesh binormals

-- Model drawing functions
function Raylib.DrawModel(model: Model, position: Vector3, scale: float32 <autocast>, tint: Color)                                                                                       <cimport'DrawModel'                 , nodecl> end -- Draw a model (with texture if set)
function Raylib.DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float32 <autocast>, scale: Vector3, tint: Color)                                      <cimport'DrawModelEx'               , nodecl> end -- Draw a model with extended parameters
function Raylib.DrawModelWires(model: Model, position: Vector3, scale: float32 <autocast>, tint: Color)                                                                                  <cimport'DrawModelWires'            , nodecl> end -- Draw a model wires (with texture if set)
function Raylib.DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float32 <autocast>, scale: Vector3, tint: Color)                                 <cimport'DrawModelWiresEx'          , nodecl> end -- Draw a model wires (with texture if set) with extended parameters
function Raylib.DrawBoundingBox(box: BoundingBox, color: Color)                                                                                                                          <cimport'DrawBoundingBox'           , nodecl> end -- Draw bounding box (wires)
function Raylib.DrawBillboard(camera: Camera, texture: Texture2D, center: Vector3, size: float32 <autocast>, tint: Color)                                                                <cimport'DrawBillboard'             , nodecl> end -- Draw a billboard texture
function Raylib.DrawBillboardRec(camera: Camera, texture: Texture2D, sourceRec: Rectangle, center: Vector3, size: float32 <autocast>, tint: Color)                                       <cimport'DrawBillboardRec'          , nodecl> end -- Draw a billboard texture defined by sourceRec

-- Collision detection functions
function Raylib.CheckCollisionSpheres(centerA: Vector3, radiusA: float32 <autocast>, centerB: Vector3, radiusB: float32 <autocast>): boolean                                             <cimport'CheckCollisionSpheres'     , nodecl> end -- Detect collision between two spheres
function Raylib.CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox): boolean                                                                                                       <cimport'CheckCollisionBoxes'       , nodecl> end -- Detect collision between two bounding boxes
function Raylib.CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: float32 <autocast>): boolean                                                                          <cimport'CheckCollisionBoxSphere'   , nodecl> end -- Detect collision between box and sphere
function Raylib.CheckCollisionRaySphere(ray: Ray, center: Vector3, radius: float32 <autocast>): boolean                                                                                  <cimport'CheckCollisionRaySphere'   , nodecl> end -- Detect collision between ray and sphere
function Raylib.CheckCollisionRaySphereEx(ray: Ray, center: Vector3, radius: float32 <autocast>, collisionPoint: Vector3*): boolean                                                      <cimport'CheckCollisionRaySphereExt', nodecl> end -- Detect collision between ray and sphere, returns collision point
function Raylib.CheckCollisionRayBox(ray: Ray, box: BoundingBox): boolean                                                                                                                <cimport'CheckCollisionRayBox'      , nodecl> end -- Detect collision between ray and box
function Raylib.GetCollisionRayModel(ray: Ray, model: Model): RayHitInfo                                                                                                                 <cimport'GetCollisionRayModel'      , nodecl> end -- Get collision info between ray and model
function Raylib.GetCollisionRayTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3): RayHitInfo                                                                                     <cimport'GetCollisionRayTriangle'   , nodecl> end -- Get collision info between ray and triangle
function Raylib.GetCollisionRayGround(ray: Ray, groundHeight: float32 <autocast>): RayHitInfo                                                                                            <cimport'GetCollisionRayGround'     , nodecl> end -- Get collision info between ray and ground plane (Y-normal plane)

------------------------------------------------------------------------------------------------------------------------
-- === MODELS MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === SHADERS MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Shader loading/unloading functions
function Raylib.LoadText(fileName: cstring): cstring                                                                                               <cimport'LoadText'             , nodecl> end -- Load chars array from text file
function Raylib.LoadShader(vsFileName: cstring, fsFileName: cstring): Shader                                                                       <cimport'LoadShader'           , nodecl> end -- Load shader from files and bind default locations
function Raylib.LoadShaderCode(vsCode: cstring, fsCode: cstring): Shader                                                                           <cimport'LoadShaderCode'       , nodecl> end -- Load shader from code strings and bind default locations
function Raylib.UnloadShader(shader: Shader)                                                                                                       <cimport'UnloadShader'         , nodecl> end -- Unload shader from GPU memory (VRAM)

function Raylib.GetShaderDefault(): Shader                                                                                                         <cimport'GetShaderDefault'     , nodecl> end -- Get default shader
function Raylib.GetTextureDefault(): Texture2D                                                                                                     <cimport'GetTextureDefault'    , nodecl> end -- Get default texture
function Raylib.GetShapesTexture(): Texture2D                                                                                                      <cimport'GetShapesTexture'     , nodecl> end -- Get texture to draw shapes
function Raylib.GetShapesTextureRec(): Rectangle                                                                                                   <cimport'GetShapesTextureRec'  , nodecl> end -- Get texture rectangle to draw shapes
function Raylib.SetShapesTexture(texture: Texture2D, source: Rectangle)                                                                            <cimport'SetShapesTexture'     , nodecl> end -- Define default texture used to draw shapes

-- Shader configuration functions
function Raylib.GetShaderLocation(shader: Shader, uniformName: cstring): cint                                                                      <cimport'GetShaderLocation'    , nodecl> end -- Get shader uniform location
function Raylib.SetShaderValue(shader: Shader, uniformLoc: cint <autocast>, value: pointer, uniformType: cint <autocast>)                          <cimport'SetShaderValue'       , nodecl> end -- Set shader uniform value
function Raylib.SetShaderValueV(shader: Shader, uniformLoc: cint <autocast>, value: pointer, uniformType: cint <autocast>, count: cint <autocast>) <cimport'SetShaderValueV'      , nodecl> end -- Set shader uniform value vector
function Raylib.SetShaderValueMatrix(shader: Shader, uniformLoc: cint <autocast>, mat: Matrix)                                                     <cimport'SetShaderValueMatrix' , nodecl> end -- Set shader uniform value (matrix 4x4)
function Raylib.SetShaderValueTexture(shader: Shader, uniformLoc: cint <autocast>, texture: Texture2D)                                             <cimport'SetShaderValueTexture', nodecl> end -- Set shader uniform value for texture
function Raylib.SetMatrixProjection(proj: Matrix)                                                                                                  <cimport'SetMatrixProjection'  , nodecl> end -- Set a custom projection matrix (replaces internal projection matrix)
function Raylib.SetMatrixModelview(view: Matrix)                                                                                                   <cimport'SetMatrixModelview'   , nodecl> end -- Set a custom modelview matrix (replaces internal modelview matrix)
function Raylib.GetMatrixModelview(): Matrix                                                                                                       <cimport'GetMatrixModelview'   , nodecl> end -- Get internal modelview matrix
function Raylib.GetMatrixProjection(): Matrix                                                                                                      <cimport'GetMatrixProjection'  , nodecl> end -- Get internal projection matrix

-- Shading begin/                end functions
function Raylib.BeginShaderMode(shader: Shader)                                                                                                    <cimport'BeginShaderMode'      , nodecl> end -- Begin custom shader drawing
function Raylib.EndShaderMode()                                                                                                                    <cimport'EndShaderMode'        , nodecl> end -- End custom shader drawing (use default shader)
function Raylib.BeginBlendMode(mode: cint <autocast>)                                                                                              <cimport'BeginBlendMode'       , nodecl> end -- Begin blending mode (alpha, additive, multiplied)
function Raylib.EndBlendMode()                                                                                                                     <cimport'EndBlendMode'         , nodecl> end -- End blending mode (reset to default: alpha blending)

-- VR control functions
function Raylib.InitVrSimulator()                                                                                                                  <cimport'InitVrSimulator'      , nodecl> end -- Init VR simulator for selected device parameters
function Raylib.CloseVrSimulator()                                                                                                                 <cimport'CloseVrSimulator'     , nodecl> end -- Close VR simulator for current device
function Raylib.UpdateVrTracking(camera: Camera*)                                                                                                  <cimport'UpdateVrTracking'     , nodecl> end -- Update VR tracking (position and orientation) and camera
function Raylib.SetVrConfiguration(info: VrDeviceInfo, distortion: Shader)                                                                         <cimport'SetVrConfiguration'   , nodecl> end -- Set stereo rendering configuration parameters
function Raylib.IsVrSimulatorReady(): boolean                                                                                                      <cimport'IsVrSimulatorReady'   , nodecl> end -- Detect if VR simulator is ready
function Raylib.ToggleVrMode()                                                                                                                     <cimport'ToggleVrMode'         , nodecl> end -- Enable/Disable VR experience
function Raylib.BeginVrDrawing()                                                                                                                   <cimport'BeginVrDrawing'       , nodecl> end -- Begin VR simulator stereo rendering
function Raylib.EndVrDrawing()                                                                                                                     <cimport'EndVrDrawing'         , nodecl> end -- End VR simulator stereo rendering

------------------------------------------------------------------------------------------------------------------------
-- === SHADERS MODULE === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === AUDIO MODULE === [
------------------------------------------------------------------------------------------------------------------------

-- Audio device management functions
function Raylib.InitAudioDevice()                                                                                                                                  <cimport'InitAudioDevice'       , nodecl> end -- Initialize audio device and context
function Raylib.CloseAudioDevice()                                                                                                                                 <cimport'CloseAudioDevice'      , nodecl> end -- Close the audio device and context (and music stream)
function Raylib.IsAudioDeviceReady(): boolean                                                                                                                      <cimport'IsAudioDeviceReady'    , nodecl> end -- Check if audio device is ready
function Raylib.SetMasterVolume(volume: float32 <autocast>)                                                                                                        <cimport'SetMasterVolume'       , nodecl> end -- Set master volume (listener)

-- Wave/Sound loading/unloading functions
function Raylib.LoadWave(fileName: cstring): Wave                                                                                                                  <cimport'LoadWave'              , nodecl> end -- Load wave data from file
function Raylib.LoadWaveEx(data: pointer, sampleCount: cint <autocast>, sampleRate: cint <autocast>, sampleSize: cint <autocast>, channels: cint <autocast>): Wave <cimport'LoadWaveEx'            , nodecl> end -- Load wave data from raw array data
function Raylib.LoadSound(fileName: cstring): Sound                                                                                                                <cimport'LoadSound'             , nodecl> end -- Load sound from file
function Raylib.LoadSoundFromWave(wave: Wave): Sound                                                                                                               <cimport'LoadSoundFromWave'     , nodecl> end -- Load sound from wave data
function Raylib.UpdateSound(sound: Sound, data: pointer, samplesCount: cint <autocast>)                                                                            <cimport'UpdateSound'           , nodecl> end -- Update sound buffer with new data
function Raylib.UnloadWave(wave: Wave)                                                                                                                             <cimport'UnloadWave'            , nodecl> end -- Unload wave data
function Raylib.UnloadSound(sound: Sound)                                                                                                                          <cimport'UnloadSound'           , nodecl> end -- Unload sound
function Raylib.ExportWave(wave: Wave, fileName: cstring)                                                                                                          <cimport'ExportWave'            , nodecl> end -- Export wave data to file
function Raylib.ExportWaveAsCode(wave: Wave, fileName: cstring)                                                                                                    <cimport'ExportWaveAsCode'      , nodecl> end -- Export wave sample data to code (.h)

-- Wave/Sound management functions
function Raylib.PlaySound(sound: Sound)                                                                                                                            <cimport'PlaySound'             , nodecl> end -- Play a sound
function Raylib.StopSound(sound: Sound)                                                                                                                            <cimport'StopSound'             , nodecl> end -- Stop playing a sound
function Raylib.PauseSound(sound: Sound)                                                                                                                           <cimport'PauseSound'            , nodecl> end -- Pause a sound
function Raylib.ResumeSound(sound: Sound)                                                                                                                          <cimport'ResumeSound'           , nodecl> end -- Resume a paused sound
function Raylib.PlaySoundMulti(sound: Sound)                                                                                                                       <cimport'PlaySoundMulti'        , nodecl> end -- Play a sound (using multichannel buffer pool)
function Raylib.StopSoundMulti()                                                                                                                                   <cimport'StopSoundMulti'        , nodecl> end -- Stop any sound playing (using multichannel buffer pool)
function Raylib.GetSoundsPlaying(): cint                                                                                                                           <cimport'GetSoundsPlaying'      , nodecl> end -- Get number of sounds playing in the multichannel
function Raylib.IsSoundPlaying(sound: Sound): boolean                                                                                                              <cimport'IsSoundPlaying'        , nodecl> end -- Check if a sound is currently playing
function Raylib.SetSoundVolume(sound: Sound, volume: float32 <autocast>)                                                                                           <cimport'SetSoundVolume'        , nodecl> end -- Set volume for a sound (1.0 is max level)
function Raylib.SetSoundPitch(sound: Sound, pitch: float32 <autocast>)                                                                                             <cimport'SetSoundPitch'         , nodecl> end -- Set pitch for a sound (1.0 is base level)
function Raylib.WaveFormat(wave: Wave*, sampleRate: cint <autocast>, sampleSize: cint <autocast>, channels: cint <autocast>)                                       <cimport'WaveFormat'            , nodecl> end -- Convert wave data to desired format
function Raylib.WaveCopy(wave: Wave): Wave                                                                                                                         <cimport'WaveCopy'              , nodecl> end -- Copy a wave to a new wave
function Raylib.WaveCrop(wave: Wave*, initSample: cint <autocast>, finalSample: cint <autocast>)                                                                   <cimport'WaveCrop'              , nodecl> end -- Crop a wave to defined samples range
function Raylib.GetWaveData(wave: Wave): float32*                                                                                                                  <cimport'GetWaveData'           , nodecl> end -- Get samples data from wave as a floats array

-- Music management functions
function Raylib.LoadMusicStream(fileName: cstring): Music                                                                                                          <cimport'LoadMusicStream'       , nodecl> end -- Load music stream from file
function Raylib.UnloadMusicStream(music: Music)                                                                                                                    <cimport'UnloadMusicStream'     , nodecl> end -- Unload music stream
function Raylib.PlayMusicStream(music: Music)                                                                                                                      <cimport'PlayMusicStream'       , nodecl> end -- Start music playing
function Raylib.UpdateMusicStream(music: Music)                                                                                                                    <cimport'UpdateMusicStream'     , nodecl> end -- Updates buffers for music streaming
function Raylib.StopMusicStream(music: Music)                                                                                                                      <cimport'StopMusicStream'       , nodecl> end -- Stop music playing
function Raylib.PauseMusicStream(music: Music)                                                                                                                     <cimport'PauseMusicStream'      , nodecl> end -- Pause music playing
function Raylib.ResumeMusicStream(music: Music)                                                                                                                    <cimport'ResumeMusicStream'     , nodecl> end -- Resume playing paused music
function Raylib.IsMusicPlaying(music: Music): boolean                                                                                                              <cimport'IsMusicPlaying'        , nodecl> end -- Check if music is playing
function Raylib.SetMusicVolume(music: Music, volume: float32 <autocast>)                                                                                           <cimport'SetMusicVolume'        , nodecl> end -- Set volume for music (1.0 is max level)
function Raylib.SetMusicPitch(music: Music, pitch: float32 <autocast>)                                                                                             <cimport'SetMusicPitch'         , nodecl> end -- Set pitch for a music (1.0 is base level)
function Raylib.SetMusicLoopCount(music: Music, count: cint <autocast>)                                                                                            <cimport'SetMusicLoopCount'     , nodecl> end -- Set music loop count (loop repeats)
function Raylib.GetMusicTimeLength(music: Music): float32                                                                                                          <cimport'GetMusicTimeLength'    , nodecl> end -- Get music time length (in seconds)
function Raylib.GetMusicTimePlayed(music: Music): float32                                                                                                          <cimport'GetMusicTimePlayed'    , nodecl> end -- Get current music time played (in seconds)

-- AudioStream management functions
function Raylib.InitAudioStream(sampleRate: cuint, sampleSize: cuint, channels: cuint): AudioStream                                                                <cimport'InitAudioStream'       , nodecl> end -- Init audio stream (to stream raw audio pcm data)
function Raylib.UpdateAudioStream(stream: AudioStream, data: pointer, samplesCount: cint <autocast>)                                                               <cimport'UpdateAudioStream'     , nodecl> end -- Update audio stream buffers with data
function Raylib.CloseAudioStream(stream: AudioStream)                                                                                                              <cimport'CloseAudioStream'      , nodecl> end -- Close audio stream and free memory
function Raylib.IsAudioBufferProcessed(stream: AudioStream): boolean                                                                                               <cimport'IsAudioBufferProcessed', nodecl> end -- Check if any audio stream buffers requires refill
function Raylib.PlayAudioStream(stream: AudioStream)                                                                                                               <cimport'PlayAudioStream'       , nodecl> end -- Play audio stream
function Raylib.PauseAudioStream(stream: AudioStream)                                                                                                              <cimport'PauseAudioStream'      , nodecl> end -- Pause audio stream
function Raylib.ResumeAudioStream(stream: AudioStream)                                                                                                             <cimport'ResumeAudioStream'     , nodecl> end -- Resume audio stream
function Raylib.IsAudioStreamPlaying(stream: AudioStream): boolean                                                                                                 <cimport'IsAudioStreamPlaying'  , nodecl> end -- Check if audio stream is playing
function Raylib.StopAudioStream(stream: AudioStream)                                                                                                               <cimport'StopAudioStream'       , nodecl> end -- Stop audio stream
function Raylib.SetAudioStreamVolume(stream: AudioStream, volume: float32 <autocast>)                                                                              <cimport'SetAudioStreamVolume'  , nodecl> end -- Set volume for audio stream (1.0 is max level)
function Raylib.SetAudioStreamPitch(stream: AudioStream, pitch: float32 <autocast>)                                                                                <cimport'SetAudioStreamPitch'   , nodecl> end -- Set pitch for audio stream (1.0 is base level)

------------------------------------------------------------------------------------------------------------------------
-- === AUDIO MODULE === ]
-----------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === RAYLIB === ]
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- === RAYMATH === [
------------------------------------------------------------------------------------

-- NOTE: Helper types to be used instead of array return types for *ToFloat functions
global  Float3: type = @record{ v: float32[3]  }
global Float16: type = @record{ v: float32[16] }

------------------------------------------------------------------------------------
-- Defines and Macros [
------------------------------------------------------------------------------------

global PI     : number <cimport, nodecl>
global DEG2RAD: number <cimport, nodecl>
global RAD2DEG: number <cimport, nodecl>

function Raymath.MatrixToFloat(mat: Matrix): float32[16]  <cimport'MatrixToFloat' , nodecl> end -- Return float vector for Matrix
function Raymath.Vector3ToFloat(vec: Vector3): float32[3] <cimport'Vector3ToFloat', nodecl> end -- Return float vector for Vector3

------------------------------------------------------------------------------------
-- Defines and Macros ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Utils math [
------------------------------------------------------------------------------------

function Raymath.Clamp(value: float32 <autocast>, min: float32 <autocast>, max: float32 <autocast>): float32    <cimport'Clamp', nodecl> end -- Clamp float value
function Raymath.Lerp(start: float32 <autocast>, _end: float32 <autocast>, amount: float32 <autocast>): float32 <cimport'Lerp' , nodecl> end -- Calculate linear interpolation between two floats

------------------------------------------------------------------------------------
-- Module Functions Definition - Utils math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Vector2 math [
------------------------------------------------------------------------------------

function Raymath.Vector2Zero(): Vector2                                                     <cimport'Vector2Zero'      , nodecl> end -- Vector with components value 0.0f
function Raymath.Vector2One(): Vector2                                                      <cimport'Vector2One'       , nodecl> end -- Vector with components value 1.0f
function Raymath.Vector2Add(v1: Vector2, v2: Vector2): Vector2                              <cimport'Vector2Add'       , nodecl> end -- Add two vectors (v1 + v2)
function Raymath.Vector2Subtract(v1: Vector2, v2: Vector2): Vector2                         <cimport'Vector2Subtract'  , nodecl> end -- Subtract two vectors (v1 - v2)
function Raymath.Vector2Length(v: Vector2): float32                                         <cimport'Vector2Length'    , nodecl> end -- Calculate vector length
function Raymath.Vector2DotProduct(v1: Vector2, v2: Vector2): float32                       <cimport'Vector2DotProduct', nodecl> end -- Calculate two vectors dot product
function Raymath.Vector2Distance(v1: Vector2, v2: Vector2): float32                         <cimport'Vector2Distance'  , nodecl> end -- Calculate distance between two vectors
function Raymath.Vector2Angle(v1: Vector2, v2: Vector2): float32                            <cimport'Vector2Angle'     , nodecl> end -- Calculate angle from two vectors in X-axis
function Raymath.Vector2Scale(v: Vector2, scale: float32 <autocast>): Vector2               <cimport'Vector2Scale'     , nodecl> end -- Scale vector (multiply by value)
function Raymath.Vector2MultiplyV(v1: Vector2, v2: Vector2): Vector2                        <cimport'Vector2MultiplyV' , nodecl> end -- Multiply vector by vector
function Raymath.Vector2Negate(v: Vector2): Vector2                                         <cimport'Vector2Negate'    , nodecl> end -- Negate vector
function Raymath.Vector2Divide(v: Vector2, div: float32 <autocast>): Vector2                <cimport'Vector2Divide'    , nodecl> end -- Divide vector by a float value
function Raymath.Vector2DivideV(v1: Vector2, v2: Vector2): Vector2                          <cimport'Vector2DivideV'   , nodecl> end -- Divide vector by vector
function Raymath.Vector2Normalize(v: Vector2): Vector2                                      <cimport'Vector2Normalize' , nodecl> end -- Normalize provided vector
function Raymath.Vector2Lerp(v1: Vector2, v2: Vector2, amount: float32 <autocast>): Vector2 <cimport'Vector2Lerp'      , nodecl> end -- Calculate linear interpolation between two vectors

------------------------------------------------------------------------------------
-- Applying to Vector2 record - Vector2 math [
------------------------------------------------------------------------------------

function Vector2.Zero(): Vector2                                                     <cimport'Vector2Zero'      , nodecl> end -- Vector with components value 0.0f
function Vector2.One(): Vector2                                                      <cimport'Vector2One'       , nodecl> end -- Vector with components value 1.0f
function Vector2.Add(v1: Vector2, v2: Vector2): Vector2                              <cimport'Vector2Add'       , nodecl> end -- Add two vectors (v1 + v2)
function Vector2.Subtract(v1: Vector2, v2: Vector2): Vector2                         <cimport'Vector2Subtract'  , nodecl> end -- Subtract two vectors (v1 - v2)
function Vector2.Length(v: Vector2): float32                                         <cimport'Vector2Length'    , nodecl> end -- Calculate vector length
function Vector2.DotProduct(v1: Vector2, v2: Vector2): float32                       <cimport'Vector2DotProduct', nodecl> end -- Calculate two vectors dot product
function Vector2.Distance(v1: Vector2, v2: Vector2): float32                         <cimport'Vector2Distance'  , nodecl> end -- Calculate distance between two vectors
function Vector2.Angle(v1: Vector2, v2: Vector2): float32                            <cimport'Vector2Angle'     , nodecl> end -- Calculate angle from two vectors in X-axis
function Vector2.Scale(v: Vector2, scale: float32 <autocast>): Vector2               <cimport'Vector2Scale'     , nodecl> end -- Scale vector (multiply by value)
function Vector2.MultiplyV(v1: Vector2, v2: Vector2): Vector2                        <cimport'Vector2MultiplyV' , nodecl> end -- Multiply vector by vector
function Vector2.Negate(v: Vector2): Vector2                                         <cimport'Vector2Negate'    , nodecl> end -- Negate vector
function Vector2.Divide(v: Vector2, div: float32 <autocast>): Vector2                <cimport'Vector2Divide'    , nodecl> end -- Divide vector by a float value
function Vector2.DivideV(v1: Vector2, v2: Vector2): Vector2                          <cimport'Vector2DivideV'   , nodecl> end -- Divide vector by vector
function Vector2.Normalize(v: Vector2): Vector2                                      <cimport'Vector2Normalize' , nodecl> end -- Normalize provided vector
function Vector2.Lerp(v1: Vector2, v2: Vector2, amount: float32 <autocast>): Vector2 <cimport'Vector2Lerp'      , nodecl> end -- Calculate linear interpolation between two vectors

------------------------------------------------------------------------------------
-- Operator overloading to Vector2 record - Vector2 math [
------------------------------------------------------------------------------------

function Vector2.__add(v1: Vector2, v2: Vector2): Vector2                            <cimport'Vector2Add'       , nodecl> end -- Add two vectors (v1 + v2)
function Vector2.__sub(v1: Vector2, v2: Vector2): Vector2                            <cimport'Vector2Subtract'  , nodecl> end -- Subtract two vectors (v1 - v2)
function Vector2.__len(v: Vector2): float32                                          <cimport'Vector2Length'    , nodecl> end -- Calculate vector length
function Vector2.__unm(v: Vector2): Vector2                                          <cimport'Vector2Negate'    , nodecl> end -- Negate vector

function Vector2.__mul(v: Vector2, multiplier: #[concept(function(m) return m.type.is_vector2 or m.type.is_arithmetic end)]#): Vector2 <inline>
   ## if multiplier.type.is_vector2 then
      return Vector2.MultiplyV(v, multiplier)
   ## else
      return Vector2.Scale(v, multiplier)
   ## end
end  -- either "Multiply vector by vector" or "Scale vector (multiply by value)"

function Vector2.__div(v: Vector2, divisor: #[concept(function(d) return d.type.is_vector2 or d.type.is_arithmetic end)]#): Vector2 <inline>
   ## if divisor.type.is_vector2 then
      return Vector2.DivideV(v, divisor)
   ## else
      return Vector2.Divide(v, divisor)
   ## end
end  -- either "Divide vector by vector" or "Divide vector by a float value"

------------------------------------------------------------------------------------
-- Operator overloading to Vector2 record - Vector2 math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Applying to Vector2 record - Vector2 math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Vector2 math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Vector3 math [
------------------------------------------------------------------------------------
function Raymath.Vector3Zero(void): Vector3                                                 <cimport'Vector3Zero'              , nodecl> end -- Vector with components value 0.0f
function Raymath.Vector3One(void): Vector3                                                  <cimport'Vector3One'               , nodecl> end -- Vector with components value 1.0f
function Raymath.Vector3Add(v1: Vector3, v2: Vector3): Vector3                              <cimport'Vector3Add'               , nodecl> end -- Add two vectors
function Raymath.Vector3Subtract(v1: Vector3, v2: Vector3): Vector3                         <cimport'Vector3Subtract'          , nodecl> end -- Subtract two vectors
function Raymath.Vector3Scale(v: Vector3, scalar: float32 <autocast>): Vector3              <cimport'Vector3Scale'             , nodecl> end -- Multiply vector by scalar
function Raymath.Vector3Multiply(v1: Vector3, v2: Vector3): Vector3                         <cimport'Vector3Multiply'          , nodecl> end -- Multiply vector by vector
function Raymath.Vector3CrossProduct(v1: Vector3, v2: Vector3): Vector3                     <cimport'Vector3CrossProduct'      , nodecl> end -- Calculate two vectors cross product
function Raymath.Vector3Perpendicular(v: Vector3): Vector3                                  <cimport'Vector3Perpendicular'     , nodecl> end -- Calculate one vector perpendicular vector
function Raymath.Vector3Length(v: Vector3): float32                                         <cimport'Vector3Length'            , nodecl> end -- Calculate vector length
function Raymath.Vector3DotProduct(v1: Vector3, v2: Vector3): float32                       <cimport'Vector3DotProduct'        , nodecl> end -- Calculate two vectors dot product
function Raymath.Vector3Distance(v1: Vector3, v2: Vector3): float32                         <cimport'Vector3Distance'          , nodecl> end -- Calculate distance between two vectors
function Raymath.Vector3Negate(v: Vector3): Vector3                                         <cimport'Vector3Negate'            , nodecl> end -- Negate provided vector (invert direction)
function Raymath.Vector3Divide(v: Vector3, div: float32 <autocast>): Vector3                <cimport'Vector3Divide'            , nodecl> end -- Divide vector by a float value
function Raymath.Vector3DivideV(v1: Vector3, v2: Vector3): Vector3                          <cimport'Vector3DivideV'           , nodecl> end -- Divide vector by vector
function Raymath.Vector3Normalize(v: Vector3): Vector3                                      <cimport'Vector3Normalize'         , nodecl> end -- Normalize provided vector

-- Orthonormalize provided vectors
-- Makes vectors normalized and orthogonal to each other
-- Gram-Schmidt function implementation
function Raymath.Vector3OrthoNormalize(v1: Vector3*, v2: Vector3*): void                    <cimport'Vector3OrthoNormalize'    , nodecl> end

function Raymath.Vector3Transform(v: Vector3, mat: Matrix): Vector3                         <cimport'Vector3Transform'         , nodecl> end -- Transforms a Vector3 by a given Matrix
function Raymath.Vector3RotateByQuaternion(v: Vector3, q: Quaternion): Vector3              <cimport'Vector3RotateByQuaternion', nodecl> end -- Transform a vector by quaternion rotation
function Raymath.Vector3Lerp(v1: Vector3, v2: Vector3, amount: float32 <autocast>): Vector3 <cimport'Vector3Lerp'              , nodecl> end -- Calculate linear interpolation between two vectors
function Raymath.Vector3Reflect(v: Vector3, normal: Vector3): Vector3                       <cimport'Vector3Reflect'           , nodecl> end -- Calculate reflected vector to normal
function Raymath.Vector3Min(v1: Vector3, v2: Vector3): Vector3                              <cimport'Vector3Min'               , nodecl> end -- Return min value for each pair of components
function Raymath.Vector3Max(v1: Vector3, v2: Vector3): Vector3                              <cimport'Vector3Max'               , nodecl> end -- Return max value for each pair of components

-- Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
-- NOTE: Assumes P is on the plane of the triangle
function Raymath.Vector3Barycenter(p: Vector3, a: Vector3, b: Vector3, c: Vector3): Vector3 <cimport'Vector3Barycenter'        , nodecl> end
function Raymath.Vector3ToFloatV(v: Vector3): Float3                                        <cimport'Vector3ToFloatV'          , nodecl> end -- Returns Vector3 as float array

------------------------------------------------------------------------------------
-- Applying to Vector3 record - Vector3 math [
------------------------------------------------------------------------------------

function Vector3.Zero(): Vector3                                                     <cimport'Vector3Zero'              , nodecl> end -- Vector with components value 0.0f
function Vector3.One(): Vector3                                                      <cimport'Vector3One'               , nodecl> end -- Vector with components value 1.0f
function Vector3.Add(v1: Vector3, v2: Vector3): Vector3                              <cimport'Vector3Add'               , nodecl> end -- Add two vectors
function Vector3.Subtract(v1: Vector3, v2: Vector3): Vector3                         <cimport'Vector3Subtract'          , nodecl> end -- Subtract two vectors
function Vector3.Scale(v: Vector3, scalar: float32 <autocast>): Vector3              <cimport'Vector3Scale'             , nodecl> end -- Multiply vector by scalar
function Vector3.Multiply(v1: Vector3, v2: Vector3): Vector3                         <cimport'Vector3Multiply'          , nodecl> end -- Multiply vector by vector
function Vector3.CrossProduct(v1: Vector3, v2: Vector3): Vector3                     <cimport'Vector3CrossProduct'      , nodecl> end -- Calculate two vectors cross product
function Vector3.Perpendicular(v: Vector3): Vector3                                  <cimport'Vector3Perpendicular'     , nodecl> end -- Calculate one vector perpendicular vector
function Vector3.Length(v: Vector3): float32                                         <cimport'Vector3Length'            , nodecl> end -- Calculate vector length
function Vector3.DotProduct(v1: Vector3, v2: Vector3): float32                       <cimport'Vector3DotProduct'        , nodecl> end -- Calculate two vectors dot product
function Vector3.Distance(v1: Vector3, v2: Vector3): float32                         <cimport'Vector3Distance'          , nodecl> end -- Calculate distance between two vectors
function Vector3.Negate(v: Vector3): Vector3                                         <cimport'Vector3Negate'            , nodecl> end -- Negate provided vector (invert direction)
function Vector3.Divide(v: Vector3, div: float32 <autocast>): Vector3                <cimport'Vector3Divide'            , nodecl> end -- Divide vector by a float value
function Vector3.DivideV(v1: Vector3, v2: Vector3): Vector3                          <cimport'Vector3DivideV'           , nodecl> end -- Divide vector by vector
function Vector3.Normalize(v: Vector3): Vector3                                      <cimport'Vector3Normalize'         , nodecl> end -- Normalize provided vector

-- Orthonormalize provided vectors
-- Makes vectors normalized and orthogonal to each other
-- Gram-Schmidt function implementation
function Vector3.OrthoNormalize(v1: Vector3*, v2: Vector3*)                          <cimport'Vector3OrthoNormalize'    , nodecl> end

function Vector3.Transform(v: Vector3, mat: Matrix): Vector3                         <cimport'Vector3Transform'         , nodecl> end -- Transforms a Vector3 by a given Matrix
function Vector3.RotateByQuaternion(v: Vector3, q: Quaternion): Vector3              <cimport'Vector3RotateByQuaternion', nodecl> end -- Transform a vector by quaternion rotation
function Vector3.Lerp(v1: Vector3, v2: Vector3, amount: float32 <autocast>): Vector3 <cimport'Vector3Lerp'              , nodecl> end -- Calculate linear interpolation between two vectors
function Vector3.Reflect(v: Vector3, normal: Vector3): Vector3                       <cimport'Vector3Reflect'           , nodecl> end -- Calculate reflected vector to normal
function Vector3.Min(v1: Vector3, v2: Vector3): Vector3                              <cimport'Vector3Min'               , nodecl> end -- Return min value for each pair of components
function Vector3.Max(v1: Vector3, v2: Vector3): Vector3                              <cimport'Vector3Max'               , nodecl> end -- Return max value for each pair of components

-- Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
-- NOTE: Assumes P is on the plane of the triangle
function Vector3.Barycenter(p: Vector3, a: Vector3, b: Vector3, c: Vector3): Vector3 <cimport'Vector3Barycenter'        , nodecl> end
function Vector3.ToFloatV(v: Vector3): Float3                                        <cimport'Vector3ToFloatV'          , nodecl> end -- Returns Vector3 as float array

------------------------------------------------------------------------------------
-- Operator overloading to Vector3 record - Vector3 math [
------------------------------------------------------------------------------------

function Vector3.__add(v1: Vector3, v2: Vector3): Vector3                            <cimport'Vector3Add'               , nodecl> end -- Add two vectors
function Vector3.__sub(v1: Vector3, v2: Vector3): Vector3                            <cimport'Vector3Subtract'          , nodecl> end -- Subtract two vectors
function Vector3.__len(v: Vector3): float32                                          <cimport'Vector3Length'            , nodecl> end -- Calculate vector length
function Vector3.__unm(v: Vector3): Vector3                                          <cimport'Vector3Negate'            , nodecl> end -- Negate provided vector (invert direction)

function Vector3.__mul(v: Vector3, multiplier: #[concept(function(m) return m.type.is_vector3 or m.type.is_arithmetic end)]#): Vector3 <inline>
   ## if m.type.is_vector3 then
      return Vector3.MultiplyV(v, multiplier)
   ## else
      return Vector3.Scale(v, multiplier)
   ## end
end -- either "Multiply vector by vector" or "Multiply vector by scalar"

function Vector3.__div(v: Vector3, divisor: #[concept(function(d) return d.type.is_vector3 or d.type.is_arithmetic end)]#): Vector3 <inline>
   ## if d.type.is_vector3 then
      return Vector3.DivideV(v, divisor)
   ## else
      return Vector3.Divide(v, divisor)
   ## end
end -- either "Divide vector by vector" or "Divide vector by a float value"

------------------------------------------------------------------------------------
-- Operator overloading to Vector3 record - Vector3 math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Applying to Vector3 record - Vector3 math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Vector3 math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Matrix math [
------------------------------------------------------------------------------------

function Raymath.MatrixDeterminant(mat: Matrix): float32                                                                                                                                              <cimport'MatrixDeterminant', nodecl> end -- Compute matrix determinant
function Raymath.MatrixTrace(mat: Matrix): float32                                                                                                                                                    <cimport'MatrixTrace'      , nodecl> end -- Returns the trace of the matrix (sum of the values along the diagonal)
function Raymath.MatrixTranspose(mat: Matrix): Matrix                                                                                                                                                 <cimport'MatrixTranspose'  , nodecl> end -- Transposes provided matrix
function Raymath.MatrixInvert(mat: Matrix): Matrix                                                                                                                                                    <cimport'MatrixInvert'     , nodecl> end -- Invert provided matrix
function Raymath.MatrixNormalize(mat: Matrix): Matrix                                                                                                                                                 <cimport'MatrixNormalize'  , nodecl> end -- Normalize provided matrix
function Raymath.MatrixIdentity(): Matrix                                                                                                                                                             <cimport'MatrixIdentity'   , nodecl> end -- Returns identity matrix
function Raymath.MatrixAdd(left: Matrix, right: Matrix): Matrix                                                                                                                                       <cimport'MatrixAdd'        , nodecl> end -- Add two matrices
function Raymath.MatrixSubtract(left: Matrix, right: Matrix): Matrix                                                                                                                                  <cimport'MatrixSubtract'   , nodecl> end -- Subtract two matrices (left - right)
function Raymath.MatrixTranslate(x: float32 <autocast>, y: float32 <autocast>, z: float32 <autocast>): Matrix                                                                                         <cimport'MatrixTranslate'  , nodecl> end -- Returns translation matrix

-- Create rotation matrix from axis and angle
-- NOTE: Angle should be provided in radians
function Raymath.MatrixRotate(axis: Vector3, angle: float32 <autocast>): Matrix                                                                                                                       <cimport'MatrixRotate'     , nodecl> end

function Raymath.MatrixRotateXYZ(ang: Vector3): Matrix                                                                                                                                                <cimport'MatrixRotateXYZ'  , nodecl> end -- Returns xyz-rotation matrix (angles in radians)
function Raymath.MatrixRotateX(angle: float32 <autocast>): Matrix                                                                                                                                     <cimport'MatrixRotateX'    , nodecl> end -- Returns x-rotation matrix (angle in radians)
function Raymath.MatrixRotateY(angle: float32 <autocast>): Matrix                                                                                                                                     <cimport'MatrixRotateY'    , nodecl> end -- Returns y-rotation matrix (angle in radians)
function Raymath.MatrixRotateZ(angle: float32 <autocast>): Matrix                                                                                                                                     <cimport'MatrixRotateZ'    , nodecl> end -- Returns z-rotation matrix (angle in radians)
function Raymath.MatrixScale(x: float32 <autocast>, y: float32 <autocast>, z: float32 <autocast>): Matrix                                                                                             <cimport'MatrixScale'      , nodecl> end -- Returns scaling matrix

-- Returns two matrix multiplication
-- NOTE: When multiplying matrices... the order matters!
function Raymath.MatrixMultiply(left: Matrix, right: Matrix): Matrix                                                                                                                                  <cimport'MatrixMultiply'   , nodecl> end

function Raymath.MatrixFrustum(left: float64 <autocast>, right: float64 <autocast>, bottom: float64 <autocast>, top: float64 <autocast>, near: float64 <autocast>, far: float64 <autocast>): Matrix   <cimport'MatrixFrustum'    , nodecl> end -- Returns perspective projection matrix

-- Returns perspective projection matrix
-- NOTE: Angle should be provided in radians
function Raymath.MatrixPerspective(fovy: float64 <autocast>, aspect: float64 <autocast>, near: float64 <autocast>, far: float64 <autocast>): Matrix                                                   <cimport'MatrixPerspective', nodecl> end

function Raymath.MatrixOrtho(left: float64 <autocast>, right: float64 <autocast>, bottom: float64 <autocast>, top: float64 <autocast>, near: float64 <autocast>, far: float64 <autocast>): Matrix     <cimport'MatrixOrtho'      , nodecl> end -- Returns orthographic projection matrix
function Raymath.MatrixLookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix                                                                                                                     <cimport'MatrixLookAt'     , nodecl> end -- Returns camera look-at matrix (view matrix)
function Raymath.MatrixToFloatV(mat: Matrix): Float16                                                                                                                                                 <cimport'MatrixToFloatV'   , nodecl> end -- Returns float array of matrix data

------------------------------------------------------------------------------------
-- Applying to Matrix record - Matrix math [
------------------------------------------------------------------------------------

function Matrix.Determinant(mat: Matrix): float32                                                                                                                                              <cimport'MatrixDeterminant', nodecl> end -- Compute matrix determinant
function Matrix.Trace(mat: Matrix): float32                                                                                                                                                    <cimport'MatrixTrace'      , nodecl> end -- Returns the trace of the matrix (sum of the values along the diagonal)
function Matrix.Transpose(mat: Matrix): Matrix                                                                                                                                                 <cimport'MatrixTranspose'  , nodecl> end -- Transposes provided matrix
function Matrix.Invert(mat: Matrix): Matrix                                                                                                                                                    <cimport'MatrixInvert'     , nodecl> end -- Invert provided matrix
function Matrix.Normalize(mat: Matrix): Matrix                                                                                                                                                 <cimport'MatrixNormalize'  , nodecl> end -- Normalize provided matrix
function Matrix.Identity(): Matrix                                                                                                                                                             <cimport'MatrixIdentity'   , nodecl> end -- Returns identity matrix
function Matrix.Add(left: Matrix, right: Matrix): Matrix                                                                                                                                       <cimport'MatrixAdd'        , nodecl> end -- Add two matrices
function Matrix.Subtract(left: Matrix, right: Matrix): Matrix                                                                                                                                  <cimport'MatrixSubtract'   , nodecl> end -- Subtract two matrices (left - right)
function Matrix.Translate(x: float32 <autocast>, y: float32 <autocast>, z: float32 <autocast>): Matrix                                                                                         <cimport'MatrixTranslate'  , nodecl> end -- Returns translation matrix

-- Create rotation matrix from axis and angle
-- NOTE: Angle should be provided in radians
function Matrix.Rotate(axis: Vector3, angle: float32 <autocast>): Matrix                                                                                                                       <cimport'MatrixRotate'     , nodecl> end

function Matrix.RotateXYZ(ang: Vector3): Matrix                                                                                                                                                <cimport'MatrixRotateXYZ'  , nodecl> end -- Returns xyz-rotation matrix (angles in radians)
function Matrix.RotateX(angle: float32 <autocast>): Matrix                                                                                                                                     <cimport'MatrixRotateX'    , nodecl> end -- Returns x-rotation matrix (angle in radians)
function Matrix.RotateY(angle: float32 <autocast>): Matrix                                                                                                                                     <cimport'MatrixRotateY'    , nodecl> end -- Returns y-rotation matrix (angle in radians)
function Matrix.RotateZ(angle: float32 <autocast>): Matrix                                                                                                                                     <cimport'MatrixRotateZ'    , nodecl> end -- Returns z-rotation matrix (angle in radians)
function Matrix.Scale(x: float32 <autocast>, y: float32 <autocast>, z: float32 <autocast>): Matrix                                                                                             <cimport'MatrixScale'      , nodecl> end -- Returns scaling matrix

-- Returns two matrix multiplication
-- NOTE: When multiplying matrices... the order matters!
function Matrix.Multiply(left: Matrix, right: Matrix): Matrix                                                                                                                                  <cimport'MatrixMultiply'   , nodecl> end

function Matrix.Frustum(left: float64 <autocast>, right: float64 <autocast>, bottom: float64 <autocast>, top: float64 <autocast>, near: float64 <autocast>, far: float64 <autocast>): Matrix   <cimport'MatrixFrustum'    , nodecl> end -- Returns perspective projection matrix

-- Returns perspective projection matrix
-- NOTE: Angle should be provided in radians
function Matrix.Perspective(fovy: float64 <autocast>, aspect: float64 <autocast>, near: float64 <autocast>, far: float64 <autocast>): Matrix                                                   <cimport'MatrixPerspective', nodecl> end

function Matrix.Ortho(left: float64 <autocast>, right: float64 <autocast>, bottom: float64 <autocast>, top: float64 <autocast>, near: float64 <autocast>, far: float64 <autocast>): Matrix     <cimport'MatrixOrtho'      , nodecl> end -- Returns orthographic projection matrix
function Matrix.LookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix                                                                                                                     <cimport'MatrixLookAt'     , nodecl> end -- Returns camera look-at matrix (view matrix)
function Matrix.ToFloatV(mat: Matrix): Float16                                                                                                                                                 <cimport'MatrixToFloatV'   , nodecl> end -- Returns float array of matrix data

------------------------------------------------------------------------------------
-- Operator overloading to Matrix record - Matrix math [
------------------------------------------------------------------------------------

function Matrix._add(left: Matrix, right: Matrix): Matrix                                                                                                                                      <cimport'MatrixAdd'        , nodecl> end -- Add two matrices
function Matrix._sub(left: Matrix, right: Matrix): Matrix                                                                                                                                      <cimport'MatrixSubtract'   , nodecl> end -- Subtract two matrices (left - right)

-- Returns two matrix multiplication
-- NOTE: When multiplying matrices... the order matters!
function Matrix._mul(left: Matrix, right: Matrix): Matrix                                                                                                                                      <cimport'MatrixMultiply'   , nodecl> end

------------------------------------------------------------------------------------
-- Operator overloading to Matrix record - Matrix math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Applying to Matrix record - Matrix math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Matrix math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Quaternion math [
------------------------------------------------------------------------------------

function Raymath.QuaternionIdentity(): Quaternion                                                                     <cimport'QuaternionIdentity'            , nodecl> end -- Returns identity quaternion
function Raymath.QuaternionLength(q: Quaternion): float32                                                             <cimport'QuaternionLength'              , nodecl> end-- Computes the length of a quaternion
function Raymath.QuaternionNormalize(q: Quaternion): Quaternion                                                       <cimport'QuaternionNormalize'           , nodecl> end-- Normalize provided quaternion
function Raymath.QuaternionInvert(q: Quaternion): Quaternion                                                          <cimport'QuaternionInvert'              , nodecl> end-- Invert provided quaternion
function Raymath.QuaternionMultiply(q1: Quaternion, q2: Quaternion): Quaternion                                       <cimport'QuaternionMultiply'            , nodecl> end-- Calculate two quaternion multiplication
function Raymath.QuaternionLerp(q1: Quaternion, q2: Quaternion, amount: float32): Quaternion                          <cimport'QuaternionLerp'                , nodecl> end-- Calculate linear interpolation between two quaternions
function Raymath.QuaternionNlerp(q1: Quaternion, q2: Quaternion, amount: float32): Quaternion                         <cimport'QuaternionNlerp'               , nodecl> end-- Calculate slerp-optimized interpolation between two quaternions
function Raymath.QuaternionSlerp(q1: Quaternion, q2: Quaternion, amount: float32): Quaternion                         <cimport'QuaternionSlerp'               , nodecl> end-- Calculates spherical linear interpolation between two quaternions
function Raymath.QuaternionFromVector3ToVector3(from: Vector3, to: Vector3): Quaternion                               <cimport'QuaternionFromVector3ToVector3', nodecl> end-- Calculate quaternion based on the rotation from one vector to another
function Raymath.QuaternionFromMatrix(mat: Matrix): Quaternion                                                        <cimport'QuaternionFromMatrix'          , nodecl> end-- Returns a quaternion for a given rotation matrix
function Raymath.QuaternionToMatrix(q: Quaternion): Matrix                                                            <cimport'QuaternionToMatrix'            , nodecl> end-- Returns a matrix for a given quaternion

-- Returns rotation quaternion for an angle and axis
-- NOTE: angle must be provided in radians
function Raymath.QuaternionFromAxisAngle(axis: Vector3, angle: float32): Quaternion                                   <cimport'QuaternionFromAxisAngle'       , nodecl> end

function Raymath.QuaternionToAxisAngle(q: Quaternion, outAxis: Vector3*, outAngle: float32*)                          <cimport'QuaternionToAxisAngle'         , nodecl> end-- Returns the rotation angle and axis for a given quaternion
function Raymath.QuaternionFromEuler(roll: float32, pitch: float32, yaw: float32): Quaternion                         <cimport'QuaternionFromEuler'           , nodecl> end-- Returns he quaternion equivalent to Euler angles

-- Return the Euler angles equivalent to quaternion (roll, pitch, yaw)
-- NOTE: Angles are returned in a Vector3 struct in degrees
function Raymath.QuaternionToEuler(q: Quaternion): Vector3                                                            <cimport'QuaternionToEuler'             , nodecl> end

function Raymath.QuaternionTransform(q: Quaternion, mat: Matrix): Quaternion                                          <cimport'QuaternionTransform'           , nodecl> end-- Transform a quaternion given a transformation matrix

------------------------------------------------------------------------------------
-- Applying to Matrix record - Matrix math [
------------------------------------------------------------------------------------

function Quaternion.Identity(): Quaternion                                                                              <cimport'QuaternionIdentity'            , nodecl> end -- Returns identity quaternion
function Quaternion.Length(q: Quaternion): float32                                                                      <cimport'QuaternionLength'              , nodecl> end-- Computes the length of a quaternion
function Quaternion.Normalize(q: Quaternion): Quaternion                                                                <cimport'QuaternionNormalize'           , nodecl> end-- Normalize provided quaternion
function Quaternion.Invert(q: Quaternion): Quaternion                                                                   <cimport'QuaternionInvert'              , nodecl> end-- Invert provided quaternion
function Quaternion.Multiply(q1: Quaternion, q2: Quaternion): Quaternion                                                <cimport'QuaternionMultiply'            , nodecl> end-- Calculate two quaternion multiplication
function Quaternion.Lerp(q1: Quaternion, q2: Quaternion, amount: float32 <autocast>): Quaternion                        <cimport'QuaternionLerp'                , nodecl> end-- Calculate linear interpolation between two quaternions
function Quaternion.Nlerp(q1: Quaternion, q2: Quaternion, amount: float32 <autocast>): Quaternion                       <cimport'QuaternionNlerp'               , nodecl> end-- Calculate slerp-optimized interpolation between two quaternions
function Quaternion.Slerp(q1: Quaternion, q2: Quaternion, amount: float32 <autocast>): Quaternion                       <cimport'QuaternionSlerp'               , nodecl> end-- Calculates spherical linear interpolation between two quaternions
function Quaternion.FromVector3ToVector3(from: Vector3, to: Vector3): Quaternion                                        <cimport'QuaternionFromVector3ToVector3', nodecl> end-- Calculate quaternion based on the rotation from one vector to another
function Quaternion.FromMatrix(mat: Matrix): Quaternion                                                                 <cimport'QuaternionFromMatrix'          , nodecl> end-- Returns a quaternion for a given rotation matrix
function Quaternion.ToMatrix(q: Quaternion): Matrix                                                                     <cimport'QuaternionToMatrix'            , nodecl> end-- Returns a matrix for a given quaternion

-- Returns rotation quaternion for an angle and axis
-- NOTE: angle must be provided in radians
function Quaternion.FromAxisAngle(axis: Vector3, angle: float32 <autocast>): Quaternion                                 <cimport'QuaternionFromAxisAngle'       , nodecl> end

function Quaternion.ToAxisAngle(q: Quaternion, outAxis: Vector3*, outAngle: float32*)                                   <cimport'QuaternionToAxisAngle'         , nodecl> end-- Returns the rotation angle and axis for a given quaternion
function Quaternion.FromEuler(roll: float32 <autocast>, pitch: float32 <autocast>, yaw: float32 <autocast>): Quaternion <cimport'QuaternionFromEuler'           , nodecl> end-- Returns he quaternion equivalent to Euler angles

-- Return the Euler angles equivalent to quaternion (roll, pitch, yaw)
-- NOTE: Angles are returned in a Vector3 struct in degrees
function Quaternion.ToEuler(q: Quaternion): Vector3                                                                     <cimport'QuaternionToEuler'             , nodecl> end

function Quaternion.Transform(q: Quaternion, mat: Matrix): Quaternion                                                   <cimport'QuaternionTransform'           , nodecl> end-- Transform a quaternion given a transformation matrix

------------------------------------------------------------------------------------
-- Operator overloading to Matrix record - Matrix math [
------------------------------------------------------------------------------------

function Quaternion.__len(q: Quaternion): float32                                                                       <cimport'QuaternionLength'              , nodecl> end-- Computes the length of a quaternion
function Quaternion.__mul(q1: Quaternion, q2: Quaternion): Quaternion                                                   <cimport'QuaternionMultiply'            , nodecl> end-- Calculate two quaternion multiplication

------------------------------------------------------------------------------------
-- Operator overloading to Matrix record - Matrix math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Applying to Matrix record - Matrix math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------
-- Module Functions Definition - Quaternion math ]
------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
-- === RAYMATH === ]
------------------------------------------------------------------------------------------------------------------------
