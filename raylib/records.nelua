--[[ This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. ]]

## strict = true
## modname = 'raylib'

-- import structs from raylib.h [
global Vector2         <cimport, nodecl> = @record{x: float32, y: float32}                                           -- Vector2 type
global Vector3         <cimport, nodecl> = @record{x: float32, y: float32, z: float32}                                           -- Vector3 type
global Vector4         <cimport, nodecl> = @record{x: float32, y: float32, z: float32, w: float32}                                           -- Vector4 type
global Quaternion      <cimport, nodecl> = @record{x: float32, y: float32, z: float32, w: float32}                                           -- Quaternion type
global Matrix          <cimport, nodecl> = @record{ -- Matrix type (OpenGL style 4x4)
   m0: float32, m4: float32, m8 : float32, m12: float32,
   m1: float32, m5: float32, m9 : float32, m13: float32,
   m2: float32, m6: float32, m10: float32, m14: float32,
   m3: float32, m7: float32, m11: float32, m15: float32
}
global Color           <cimport, nodecl> = @record{r: cuchar, g: cuchar, b: cuchar, a: cuchar} -- Color type, RGBA (32bit)
global Rectangle       <cimport, nodecl> = @record{x: float32, y: float32, width: float32, height: float32}                                           -- Rectangle type

-- Image type, bpp always RGBA (32bit)
-- NOTE: Data stored in CPU memory (RAM)
global Image <cimport, nodecl> = @record{
   data: pointer, -- Image raw data
   width:   cint, -- Image base width
   height:  cint, -- Image base height
   mipmaps: cint, -- Mipmap levels, 1 by default
   format:  cint  -- Data format (PixelFormat type)
}

-- Texture2D type
-- NOTE: Data stored in GPU memory
global Texture2D <cimport, nodecl> = @record{
   id:     cuint, -- OpenGL texture id
   width:   cint, -- Texture base width
   height:  cint, -- Texture base height
   mipmaps: cint, -- Mipmap levels, 1 by default
   format:  cint  -- Data format (PixelFormat type)
}

-- Texture type, same as Texture2D
global Texture: type = @Texture2D

-- TextureCubemap type, actually, same as Texture2D
global TextureCubemap: type = @Texture2D

-- RenderTexture2D type, for texture rendering
global RenderTexture2D <cimport, nodecl> = @record{
   id:             cuint, -- OpenGL Framebuffer Object (FBO) id
   texture:    Texture2D, -- Color buffer attachment texture
   depth:      Texture2D, -- Depth buffer attachment texture
   depthTexture: boolean  -- Track if depth attachment is a texture or renderbuffer
}

-- RenderTexture type, same as RenderTexture2D
global RenderTexture: type = @RenderTexture2D

-- N-Patch layout info
global NPatchInfo <cimport, nodecl> = @record{
   sourceRec: Rectangle, -- Region in the texture
   left:           cint, -- left border offset
   top:            cint, -- top border offset
   right:          cint, -- right border offset
   bottom:         cint, -- bottom border offset
   type:           cint  -- layout of the n-patch: 3x3, 1x3 or 3x1
}

-- Font character info
global CharInfo <cimport, nodecl> = @record{
   value:     cint, -- Character value (Unicode)
   offsetX:   cint, -- Character offset X when drawing
   offsetY:   cint, -- Character offset Y when drawing
   advanceX:  cint, -- Character advance position X
   image:    Image, -- Character image data
}

-- Font type, includes texture and charSet array data
global Font <cimport, nodecl> = @record{
   baseSize:         cint, -- Base size (default chars height)
   charsCount:       cint, -- Number of characters
   texture:     Texture2D, -- Characters texture atlas
   recs:       Rectangle*, -- Characters rectangles in texture
   chars:       CharInfo*  -- Characters info data
}

-- Camera type, defines a camera position/orientation in 3d space
global Camera3D <cimport, nodecl> = @record{
   position: Vector3, -- Camera position
   target:   Vector3, -- Camera target it looks-at
   up:       Vector3, -- Camera up vector (rotation over its axis)
   fovy:     float32, -- Camera field-of-view apperture in Y (degrees) in perspective, used as near plane width in orthographic
   type:        cint  -- Camera type, defines projection type: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

global Camera: type = @Camera3D -- Camera type fallback, defaults to Camera3D


-- Camera2D type, defines a 2d camera
global Camera2D <cimport, nodecl> = @record{
   offset:   Vector2, -- Camera offset (displacement from target)
   target:   Vector2, -- Camera target (rotation and zoom origin)
   rotation: float32, -- Camera rotation in degrees
   zoom:     float32  -- Camera zoom (scaling), should be 1.0f by default
}

-- Vertex data definning a mesh
-- NOTE: Data stored in CPU memory (and GPU)
global Mesh <cimport, nodecl> = @record{
   vertexCount:      cint, -- Number of vertices stored in arrays
   triangleCount:    cint, -- Number of triangles stored (indexed or not)

   -- Default vertex data
   vertices:     float32*, -- Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
   texcoords:    float32*, -- Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
   texcoords2:   float32*, -- Vertex second texture coordinates (useful for lightmaps) (shader-location = 5)
   normals:      float32*, -- Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
   tangents:     float32*, -- Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
   colors:        cuchar*, -- Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
   indices:      cushort*, -- Vertex indices (in case vertex data comes indexed)

   -- Animation vertex data
   animVertices: float32*, -- Animated vertex positions (after bones transformations)
   animNormals:  float32*, -- Animated normals (after bones transformations)
   boneIds:         cint*, -- Vertex bone ids, up to 4 bones influence by vertex (skinning)
   boneWeights:  float32*, -- Vertex bone weight, up to 4 bones influence by vertex (skinning)

   -- OpenGL identifiers
   vaoId:           cuint, -- OpenGL Vertex Array Object id
   vboId:          cuint*  -- OpenGL Vertex Buffer Objects id (default vertex data)
}


-- Shader type (generic)
global Shader <cimport, nodecl> = @record{
   id:   cuint, -- Shader program id
   locs: cint*  -- Shader locations array (MAX_SHADER_LOCATIONS)
}

-- Material texture map
global MaterialMap <cimport, nodecl> = @record{
   texture: Texture2D, -- Material map texture
   color:       Color, -- Material map color
   value:     float32  -- Material map value
}

-- Material type (generic)
global Material <cimport, nodecl> = @record{
   shader:       Shader, -- Material shader
   maps:   MaterialMap*, -- Material maps array (MAX_MATERIAL_MAPS)
   params:     float32*  -- Material generic parameters (if required)
}

-- Transformation properties
global Transform <cimport, nodecl> = @record{
   translation:    Vector3, -- Translation
   rotation:    Quaternion, -- Rotation
   scale:          Vector3  -- Scale
}

-- Bone information
global BoneInfo <cimport, nodecl> = @record{
   name:   cchar[32], -- Bone name
   parent:      cint  -- Bone parent
}

-- Model type
global Model <cimport, nodecl> = @record{
   transform:        Matrix, -- Local transform matrix

   meshCount:          cint, -- Number of meshes
   meshes:            Mesh*, -- Meshes array

   materialCount:      cint, -- Number of materials
   materials:     Material*, -- Materials array
   meshMaterial:      cint*, -- Mesh material number

   -- Animation data
   boneCount:          cint, -- Number of bones
   bones:         BoneInfo*, -- Bones information (skeleton)
   bindPose:     Transform*  -- Bones base transformation (pose)
}

-- Model animation
global ModelAnimation <cimport, nodecl> = @record{
   boneCount:         cint, -- Number of bones
   bones:        BoneInfo*, -- Bones information (skeleton)

   frameCount:        cint, -- Number of animation frames
   framePoses: Transform**  -- Poses array by frame
}

-- Ray type (useful for raycast)
global Ray <cimport, nodecl> = @record{
   position:  Vector3, -- Ray position (origin)
   direction: Vector3  -- Ray direction
}

-- Raycast hit information
global RayHitInfo <cimport, nodecl> = @record{
   hit:      boolean, -- Did the ray hit something?
   distance: float32, -- Distance to nearest hit
   position: Vector3, -- Position of nearest hit
   normal:   Vector3  -- Surface normal of hit
}

-- Bounding box type
global BoundingBox <cimport, nodecl> = @record{
   min: Vector3, -- Minimum vertex box-corner
   max: Vector3  -- Maximum vertex box-corner
}

-- Wave type, defines audio wave data
global Wave <cimport, nodecl> = @record{
   sampleCount:   cuint, -- Total number of samples
   sampleRate:    cuint, -- Frequency (samples per second)
   sampleSize:    cuint, -- Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels:      cuint, -- Number of channels (1-mono, 2-stereo)
   data:        pointer  -- Buffer data pointer
}

global rAudioBuffer <cimport, nodecl> = @record{}

-- Audio stream type
-- NOTE: Useful to create custom audio streams not bound to a specific file
global AudioStream <cimport, nodecl> = @record{
   sampleRate:         cuint, -- Frequency (samples per second)
   sampleSize:         cuint, -- Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels:           cuint, -- Number of channels (1-mono, 2-stereo)

   buffer:     rAudioBuffer*  -- Pointer to internal data used by the audio system
}

-- Sound source type
global Sound <cimport, nodecl> = @record{
   sampleCount:       cuint, -- Total number of samples
   stream:      AudioStream  -- Audio stream
}

-- Music stream type (audio file streaming from memory)
-- NOTE: Anything longer than ~10 seconds should be streamed
global Music <cimport, nodecl> = @record{
   ctxType:            cint, -- Type of music context (audio filetype)
   ctxData:         pointer, -- Audio context data, depends on type

   sampleCount:       cuint, -- Total number of samples
   loopCount:         cuint, -- Loops count (times music will play), 0 means infinite loop

   stream:      AudioStream  -- Audio stream
}

-- Head-Mounted-Display device parameters
global VrDeviceInfo <cimport, nodecl> = @record{
   hResolution:                  cint, -- HMD horizontal resolution in pixels
   vResolution:                  cint, -- HMD vertical resolution in pixels
   hScreenSize:               float32, -- HMD horizontal size in meters
   vScreenSize:               float32, -- HMD vertical size in meters
   vScreenCenter:             float32, -- HMD screen center in meters
   eyeToScreenDistance:       float32, -- HMD distance between eye and display in meters
   lensSeparationDistance:    float32, -- HMD lens separation distance in meters
   interpupillaryDistance:    float32, -- HMD IPD (distance between pupils) in meters
   lensDistortionValues:   float32[4], -- HMD lens distortion constant parameters
   chromaAbCorrection:     float32[4]  -- HMD chromatic aberration correction parameters
}

--]

-- This is a callback, is used as parameter by "SetTraceLogCallback" (in core module)
-- since is used as parameter type, I decided to declare it as record
global TraceLogCallback <cimport, nodecl> = @record{}

-- import colors --[
local LIGHTGRAY:  Color <cimport, nodecl>; local GRAY:       Color <cimport, nodecl>
local DARKGRAY:   Color <cimport, nodecl>; local YELLOW:     Color <cimport, nodecl>
local GOLD:       Color <cimport, nodecl>; local ORANGE:     Color <cimport, nodecl>
local PINK:       Color <cimport, nodecl>; local RED:        Color <cimport, nodecl>
local MAROON:     Color <cimport, nodecl>; local GREEN:      Color <cimport, nodecl>
local LIME:       Color <cimport, nodecl>; local DARKGREEN:  Color <cimport, nodecl>
local SKYBLUE:    Color <cimport, nodecl>; local BLUE:       Color <cimport, nodecl>
local DARKBLUE:   Color <cimport, nodecl>; local PURPLE:     Color <cimport, nodecl>
local VIOLET:     Color <cimport, nodecl>; local DARKPURPLE: Color <cimport, nodecl>
local BEIGE:      Color <cimport, nodecl>; local BROWN:      Color <cimport, nodecl>
local DARKBROWN:  Color <cimport, nodecl>; local WHITE:      Color <cimport, nodecl>
local BLACK:      Color <cimport, nodecl>; local BLANK:      Color <cimport, nodecl>
local MAGENTA:    Color <cimport, nodecl>; local RAYWHITE:   Color <cimport, nodecl>

global RaylibColors: record {
   Lightgray: Color, Gray:     Color, Darkgray:  Color, Yellow: Color, Gold:   Color, Orange:     Color,
   Pink:      Color, Red:      Color, Maroon:    Color, Green:  Color, Lime:   Color, Darkgreen:  Color,
   Skyblue:   Color, Blue:     Color, Darkblue:  Color, Purple: Color, Violet: Color, Darkpurple: Color,
   Beige:     Color, Brown:    Color, Darkbrown: Color, White:  Color, Black:  Color, Blank:      Color,
   Magenta:   Color, Raywhite: Color
} = {
   LIGHTGRAY       , GRAY           , DARKGRAY        , YELLOW       , GOLD         , ORANGE           ,
   PINK            , RED            , MAROON          , GREEN        , LIME         , DARKGREEN        ,
   SKYBLUE         , BLUE           , DARKBLUE        , PURPLE       , VIOLET       , DARKPURPLE       ,
   BEIGE           , BROWN          , DARKBROWN       , WHITE        , BLACK        , BLANK            ,
   MAGENTA         , RAYWHITE
}
